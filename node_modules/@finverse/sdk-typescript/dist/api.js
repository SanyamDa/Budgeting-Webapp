"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Finverse Public
 * Documentation of the early finverse services
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: info@finverse.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManualPaymentConfirmationResponseStatusEnum = exports.MandateSenderAccountAccountTypeEnum = exports.MandateRecipientAccountAccountTypeEnum = exports.MandateAuthLinkCustomizationsUiModeEnum = exports.MandateAuthLinkCustomizationsLanguageEnum = exports.LoginMethodStatusEnum = exports.LinkTokenRequestAutomaticDataRefreshEnum = exports.LinkTokenRequestLanguageEnum = exports.LinkTokenRequestUiModeEnum = exports.LineItemItemTypeEnum = exports.IntegrationMetadataResponseIntegrationIdEnum = exports.IntegrationMetadataRequestIntegrationIdEnum = exports.InstitutionStatusEnum = exports.InstitutionUserTypeEnum = exports.InstitutionProductsSupportedEnum = exports.InstitutionInstitutionTypeEnum = exports.InstitutionTagsEnum = exports.GetMandateSenderUserTypeEnum = exports.GetMandateResponseStatusEnum = exports.GetMandateAuthResponseSenderTypeEnum = exports.GetMandateAuthResponseMandateStatusEnum = exports.GetMandateAuthLinkResponseTokenTypeEnum = exports.GetBalanceHistoryResponseSourceEnum = exports.FvErrorModelV2TypeEnum = exports.FvErrorModelTypeEnum = exports.FvEmbeddedErrorModelTypeEnum = exports.FeePaidByEnum = exports.FVCardDetailsFundingEnum = exports.FVCardStatusEnum = exports.DisputeResponseDisputeStatusEnum = exports.CustomerPaymentInstructionTypeEnum = exports.CreateRecipientAccountAccountTypeEnum = exports.CreatePaymentUserRequestUserTypeEnum = exports.CreatePaymentMethodRequestPaymentMethodTypeEnum = exports.CreatePaymentLinkRequestModeEnum = exports.CreatePaymentLinkMandateRequestSenderTypeEnum = exports.CreatePaymentAccountRequestAccountTypeEnum = exports.CreateMandateSenderUserTypeEnum = exports.CreateMandateResponseStatusEnum = exports.CreateMandateRequestWithDdaReferenceStatusEnum = exports.CreateCardRequestStatusEnum = exports.CardFvLinkResponseStatusEnum = exports.BadRequestModelV2ErrorTypeEnum = exports.AutopayEnrollmentConfigurationEnrollmentPrefillValueEnum = exports.AuthChecklistOptionsSubmittedByEnum = exports.AuthChecklistOptionsNameEnum = exports.AuthChecklistFactorRequiredEnum = exports.AuthChecklistFactorTypeEnum = exports.AccountTypeSubtypeEnum = exports.AccountTypeTypeEnum = void 0;
exports.ListPaymentsPaymentTypesEnum = exports.ListPaymentsPaymentTypeEnum = exports.ListPaymentsSenderTypeEnum = exports.ListPaymentsStatusesEnum = exports.ListMandatesSenderTypeEnum = exports.ListMandatesStatusesEnum = exports.ListDisputesStatusesEnum = exports.ListDetokenizedMandatesSenderTypeEnum = exports.ListDetokenizedMandatesStatusesEnum = exports.DefaultApi = exports.DefaultApiFactory = exports.DefaultApiFp = exports.DefaultApiAxiosParamCreator = exports.ListPaymentAccountsWithEnrichedDataAccountTypeEnum = exports.ListInstitutionsInstitutionTypeEnum = exports.GetLineItemsForDisplayPaymentTypeEnum = exports.CustomerApi = exports.CustomerApiFactory = exports.CustomerApiFp = exports.CustomerApiAxiosParamCreator = exports.UpdateTestPaymentStatusRequestStatusEnum = exports.UpdatePaymentUserRequestUserTypeEnum = exports.TransactionLimitsPeriodEnum = exports.SubmitAuthChecklistResponseMandateStatusEnum = exports.SenderDetailDetailsTypeEnum = exports.RefreshLoginIdentityLinkCustomizationsUiModeEnum = exports.RefreshLoginIdentityLinkCustomizationsLanguageEnum = exports.RecipientAccountResponseAccountTypeEnum = exports.RecipientAccountNumberTypeEnum = exports.PayoutSnapshotResponseTypeEnum = exports.PayoutSnapshotResponseStatusEnum = exports.PaymentUserWithoutEmailUserTypeEnum = exports.PaymentUserUserTypeEnum = exports.PaymentSetupOptionsPaymentMethodTypesEnum = exports.PaymentSetupOptionsFuturePaymentsEnum = exports.PaymentScheduleFrequencyEnum = exports.PaymentResponseStatusEnum = exports.PaymentResponseTypeEnum = exports.PaymentMethodIntegrationMetadataIntegrationIdEnum = exports.PaymentLinkTokenResponseTokenTypeEnum = exports.PaymentLinkResponseSessionStatusEnum = exports.PaymentLinkResponseStatusEnum = exports.PaymentLinkResponseModeEnum = exports.PaymentLinkCustomizationsUiModeEnum = exports.PaymentLinkCustomizationsLanguageEnum = exports.PaymentInstructionTypeEnum = exports.PaymentInfoPaymentsSupportedEnum = exports.PaymentFvLinkResponseStatusEnum = exports.PaymentAccountDetailsWithEnrichedDataAccountTypeEnum = exports.PaymentAccountDetailsAccountTypeEnum = void 0;
exports.PublicApi = exports.PublicApiFactory = exports.PublicApiFp = exports.PublicApiAxiosParamCreator = exports.GetBalanceHistorySourceEnum = exports.LoginIdentityApi = exports.LoginIdentityApiFactory = exports.LoginIdentityApiFp = exports.LoginIdentityApiAxiosParamCreator = exports.TokenGrantTypeEnum = exports.LinkApi = exports.LinkApiFactory = exports.LinkApiFp = exports.LinkApiAxiosParamCreator = exports.ListPayoutsPayoutTypesEnum = exports.ListPayoutsStatusesEnum = void 0;
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
exports.AccountTypeTypeEnum = {
    Deposit: 'DEPOSIT',
    Card: 'CARD',
    Investment: 'INVESTMENT',
    Loan: 'LOAN',
    Unknown: 'UNKNOWN',
};
exports.AccountTypeSubtypeEnum = {
    Current: 'CURRENT',
    Savings: 'SAVINGS',
    TimeDeposit: 'TIME_DEPOSIT',
    Other: 'OTHER',
    CreditCard: 'CREDIT_CARD',
    DebitCard: 'DEBIT_CARD',
    Securities: 'SECURITIES',
    Funds: 'FUNDS',
    Stocks: 'STOCKS',
    Bonds: 'BONDS',
    Mortgage: 'MORTGAGE',
    PersonalLoan: 'PERSONAL_LOAN',
    RevolvingLoan: 'REVOLVING_LOAN',
    Unknown: 'UNKNOWN',
};
exports.AuthChecklistFactorTypeEnum = {
    AccountIdentification: 'ACCOUNT_IDENTIFICATION',
    UserIdentification: 'USER_IDENTIFICATION',
    EnduserConsent: 'ENDUSER_CONSENT',
    AccountholderAuthentication: 'ACCOUNTHOLDER_AUTHENTICATION',
};
exports.AuthChecklistFactorRequiredEnum = {
    Yes: 'YES',
    No: 'NO',
    Optional: 'OPTIONAL',
};
exports.AuthChecklistOptionsNameEnum = {
    InstitutionCredentialsLogin: 'INSTITUTION_CREDENTIALS_LOGIN',
    InstitutionOauthLogin: 'INSTITUTION_OAUTH_LOGIN',
};
exports.AuthChecklistOptionsSubmittedByEnum = {
    CustomerApp: 'CUSTOMER_APP',
    FinverseLink: 'FINVERSE_LINK',
};
exports.AutopayEnrollmentConfigurationEnrollmentPrefillValueEnum = {
    Yes: 'YES',
    No: 'NO',
};
exports.BadRequestModelV2ErrorTypeEnum = {
    LinkError: 'LINK_ERROR',
    ApiError: 'API_ERROR',
};
exports.CardFvLinkResponseStatusEnum = {
    Unknown: 'UNKNOWN',
    Processing: 'PROCESSING',
    Succeeded: 'SUCCEEDED',
    Cancelled: 'CANCELLED',
    Failed: 'FAILED',
};
exports.CreateCardRequestStatusEnum = {
    Succeeded: 'SUCCEEDED',
};
exports.CreateMandateRequestWithDdaReferenceStatusEnum = {
    Succeeded: 'SUCCEEDED',
};
exports.CreateMandateResponseStatusEnum = {
    AuthorizationRequired: 'AUTHORIZATION_REQUIRED',
    Authorizing: 'AUTHORIZING',
    Processing: 'PROCESSING',
    Submitted: 'SUBMITTED',
    Succeeded: 'SUCCEEDED',
    Failed: 'FAILED',
    Revoked: 'REVOKED',
    ReadyToSubmit: 'READY_TO_SUBMIT',
    Closed: 'CLOSED',
    Cancelled: 'CANCELLED',
};
exports.CreateMandateSenderUserTypeEnum = {
    Individual: 'INDIVIDUAL',
    Business: 'BUSINESS',
};
exports.CreatePaymentAccountRequestAccountTypeEnum = {
    ExternalAccount: 'EXTERNAL_ACCOUNT',
};
exports.CreatePaymentLinkMandateRequestSenderTypeEnum = {
    Individual: 'INDIVIDUAL',
    Business: 'BUSINESS',
};
exports.CreatePaymentLinkRequestModeEnum = {
    Payment: 'PAYMENT',
    Setup: 'SETUP',
};
exports.CreatePaymentMethodRequestPaymentMethodTypeEnum = {
    Card: 'CARD',
    Mandate: 'MANDATE',
};
exports.CreatePaymentUserRequestUserTypeEnum = {
    Individual: 'INDIVIDUAL',
    Business: 'BUSINESS',
};
exports.CreateRecipientAccountAccountTypeEnum = {
    ExternalAccount: 'EXTERNAL_ACCOUNT',
};
exports.CustomerPaymentInstructionTypeEnum = {
    DebitAuthorization: 'DEBIT_AUTHORIZATION',
};
exports.DisputeResponseDisputeStatusEnum = {
    Unknown: 'UNKNOWN',
    Undefended: 'UNDEFENDED',
    ActionRequired: 'ACTION_REQUIRED',
    Processing: 'PROCESSING',
    Accepted: 'ACCEPTED',
    Lost: 'LOST',
    Won: 'WON',
};
exports.FVCardStatusEnum = {
    Unknown: 'UNKNOWN',
    Processing: 'PROCESSING',
    Succeeded: 'SUCCEEDED',
    Cancelled: 'CANCELLED',
    Failed: 'FAILED',
};
exports.FVCardDetailsFundingEnum = {
    Unknown: 'UNKNOWN',
    Credit: 'CREDIT',
    Debit: 'DEBIT',
    Prepaid: 'PREPAID',
};
exports.FeePaidByEnum = {
    Recipient: 'RECIPIENT',
    Sender: 'SENDER',
};
exports.FvEmbeddedErrorModelTypeEnum = {
    LinkError: 'LINK_ERROR',
    ApiError: 'API_ERROR',
};
exports.FvErrorModelTypeEnum = {
    LinkError: 'LINK_ERROR',
    ApiError: 'API_ERROR',
};
exports.FvErrorModelV2TypeEnum = {
    LinkError: 'LINK_ERROR',
    ApiError: 'API_ERROR',
};
exports.GetBalanceHistoryResponseSourceEnum = {
    Institution: 'INSTITUTION',
    Computed: 'COMPUTED',
};
exports.GetMandateAuthLinkResponseTokenTypeEnum = {
    Bearer: 'Bearer',
};
exports.GetMandateAuthResponseMandateStatusEnum = {
    Created: 'CREATED',
    Processing: 'PROCESSING',
    Submitted: 'SUBMITTED',
    Error: 'ERROR',
};
exports.GetMandateAuthResponseSenderTypeEnum = {
    Individual: 'INDIVIDUAL',
    Business: 'BUSINESS',
};
exports.GetMandateResponseStatusEnum = {
    AuthorizationRequired: 'AUTHORIZATION_REQUIRED',
    Authorizing: 'AUTHORIZING',
    Processing: 'PROCESSING',
    Submitted: 'SUBMITTED',
    Succeeded: 'SUCCEEDED',
    Failed: 'FAILED',
    Revoked: 'REVOKED',
};
exports.GetMandateSenderUserTypeEnum = {
    Individual: 'INDIVIDUAL',
    Business: 'BUSINESS',
};
exports.InstitutionTagsEnum = {
    Real: 'real',
    Test: 'test',
};
exports.InstitutionInstitutionTypeEnum = {
    Bank: 'BANK',
    Wallet: 'WALLET',
    Test: 'TEST',
};
exports.InstitutionProductsSupportedEnum = {
    Accounts: 'ACCOUNTS',
    Transactions: 'TRANSACTIONS',
    Statements: 'STATEMENTS',
    AccountNumbers: 'ACCOUNT_NUMBERS',
    Identity: 'IDENTITY',
    AutoDebitSetup: 'AUTO_DEBIT_SETUP',
};
exports.InstitutionUserTypeEnum = {
    Personal: 'PERSONAL',
    Individual: 'INDIVIDUAL',
    Business: 'BUSINESS',
};
exports.InstitutionStatusEnum = {
    Supported: 'SUPPORTED',
    Alpha: 'ALPHA',
    Beta: 'BETA',
};
exports.IntegrationMetadataRequestIntegrationIdEnum = {
    Rapidstor: 'RAPIDSTOR',
};
exports.IntegrationMetadataResponseIntegrationIdEnum = {
    Rapidstor: 'RAPIDSTOR',
};
exports.LineItemItemTypeEnum = {
    AmountDue: 'AMOUNT_DUE',
    Surcharge: 'SURCHARGE',
    Total: 'TOTAL',
};
exports.LinkTokenRequestUiModeEnum = {
    Iframe: 'iframe',
    Redirect: 'redirect',
    AutoRedirect: 'auto_redirect',
    Standalone: 'standalone',
};
exports.LinkTokenRequestLanguageEnum = {
    En: 'en',
    Vi: 'vi',
    Zh: 'zh',
};
exports.LinkTokenRequestAutomaticDataRefreshEnum = {
    On: 'ON',
    Off: 'OFF',
    ForcedOn: 'FORCED_ON',
};
exports.LoginMethodStatusEnum = {
    Supported: 'SUPPORTED',
    Alpha: 'ALPHA',
    Beta: 'BETA',
};
exports.MandateAuthLinkCustomizationsLanguageEnum = {
    En: 'en',
    Vi: 'vi',
    Zh: 'zh',
};
exports.MandateAuthLinkCustomizationsUiModeEnum = {
    Iframe: 'iframe',
    Redirect: 'redirect',
    AutoRedirect: 'auto_redirect',
    Standalone: 'standalone',
};
exports.MandateRecipientAccountAccountTypeEnum = {
    ExternalAccount: 'EXTERNAL_ACCOUNT',
    SettlementAccount: 'SETTLEMENT_ACCOUNT',
};
exports.MandateSenderAccountAccountTypeEnum = {
    ExternalAccount: 'EXTERNAL_ACCOUNT',
};
exports.ManualPaymentConfirmationResponseStatusEnum = {
    AuthorizationRequired: 'AUTHORIZATION_REQUIRED',
    Authorizing: 'AUTHORIZING',
    Processing: 'PROCESSING',
    Submitted: 'SUBMITTED',
    Executed: 'EXECUTED',
    Failed: 'FAILED',
    Revoked: 'REVOKED',
    Cancelled: 'CANCELLED',
    Created: 'CREATED',
};
exports.PaymentAccountDetailsAccountTypeEnum = {
    ExternalAccount: 'EXTERNAL_ACCOUNT',
    SettlementAccount: 'SETTLEMENT_ACCOUNT',
};
exports.PaymentAccountDetailsWithEnrichedDataAccountTypeEnum = {
    ExternalAccount: 'EXTERNAL_ACCOUNT',
    SettlementAccount: 'SETTLEMENT_ACCOUNT',
};
exports.PaymentFvLinkResponseStatusEnum = {
    AuthorizationRequired: 'AUTHORIZATION_REQUIRED',
    Authorizing: 'AUTHORIZING',
    Processing: 'PROCESSING',
    Submitted: 'SUBMITTED',
    Executed: 'EXECUTED',
    Failed: 'FAILED',
    Revoked: 'REVOKED',
    Cancelled: 'CANCELLED',
    Created: 'CREATED',
};
exports.PaymentInfoPaymentsSupportedEnum = {
    Mandate: 'MANDATE',
    DebitAuthorization: 'DEBIT_AUTHORIZATION',
};
exports.PaymentInstructionTypeEnum = {
    DebitAuthorization: 'DEBIT_AUTHORIZATION',
};
exports.PaymentLinkCustomizationsLanguageEnum = {
    En: 'en',
    Vi: 'vi',
    Zh: 'zh',
};
exports.PaymentLinkCustomizationsUiModeEnum = {
    Iframe: 'iframe',
    Redirect: 'redirect',
    AutoRedirect: 'auto_redirect',
    Standalone: 'standalone',
};
exports.PaymentLinkResponseModeEnum = {
    Payment: 'PAYMENT',
};
exports.PaymentLinkResponseStatusEnum = {
    Created: 'CREATED',
    Paid: 'PAID',
    Expired: 'EXPIRED',
};
exports.PaymentLinkResponseSessionStatusEnum = {
    Open: 'OPEN',
    Processing: 'PROCESSING',
    Complete: 'COMPLETE',
    Failed: 'FAILED',
};
exports.PaymentLinkTokenResponseTokenTypeEnum = {
    Bearer: 'Bearer',
};
exports.PaymentMethodIntegrationMetadataIntegrationIdEnum = {
    Stripe: 'STRIPE',
    Cybersource: 'CYBERSOURCE',
};
exports.PaymentResponseTypeEnum = {
    Mandate: 'MANDATE',
    Single: 'SINGLE',
    Card: 'CARD',
    Manual: 'MANUAL',
};
exports.PaymentResponseStatusEnum = {
    AuthorizationRequired: 'AUTHORIZATION_REQUIRED',
    Authorizing: 'AUTHORIZING',
    Processing: 'PROCESSING',
    Submitted: 'SUBMITTED',
    Executed: 'EXECUTED',
    Failed: 'FAILED',
    Revoked: 'REVOKED',
    Cancelled: 'CANCELLED',
    Created: 'CREATED',
};
exports.PaymentScheduleFrequencyEnum = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Quarterly: 'QUARTERLY',
    Yearly: 'YEARLY',
};
exports.PaymentSetupOptionsFuturePaymentsEnum = {
    Autopay: 'AUTOPAY',
    ClickToPay: 'CLICK_TO_PAY',
};
exports.PaymentSetupOptionsPaymentMethodTypesEnum = {
    Mandate: 'MANDATE',
    Single: 'SINGLE',
    Card: 'CARD',
    Manual: 'MANUAL',
};
exports.PaymentUserUserTypeEnum = {
    Individual: 'INDIVIDUAL',
    Business: 'BUSINESS',
};
exports.PaymentUserWithoutEmailUserTypeEnum = {
    Individual: 'INDIVIDUAL',
    Business: 'BUSINESS',
};
exports.PayoutSnapshotResponseStatusEnum = {
    Executed: 'EXECUTED',
    Created: 'CREATED',
    Processing: 'PROCESSING',
    ProcessingFunds: 'PROCESSING_FUNDS',
    Cancelled: 'CANCELLED',
    Failed: 'FAILED',
    Funded: 'FUNDED',
    Submitted: 'SUBMITTED',
};
exports.PayoutSnapshotResponseTypeEnum = {
    Manual: 'MANUAL',
    Scheduled: 'SCHEDULED',
};
exports.RecipientAccountNumberTypeEnum = {
    Local: 'LOCAL',
    Iban: 'IBAN',
};
exports.RecipientAccountResponseAccountTypeEnum = {
    ExternalAccount: 'EXTERNAL_ACCOUNT',
    SettlementAccount: 'SETTLEMENT_ACCOUNT',
};
exports.RefreshLoginIdentityLinkCustomizationsLanguageEnum = {
    En: 'en',
    Vi: 'vi',
    Zh: 'zh',
};
exports.RefreshLoginIdentityLinkCustomizationsUiModeEnum = {
    Iframe: 'iframe',
    Redirect: 'redirect',
    AutoRedirect: 'auto_redirect',
    Standalone: 'standalone',
};
exports.SenderDetailDetailsTypeEnum = {
    HkId: 'HK_ID',
    Passport: 'PASSPORT',
    HkBusinessRegistration: 'HK_BUSINESS_REGISTRATION',
    HkCertificateOfIncorporation: 'HK_CERTIFICATE_OF_INCORPORATION',
};
exports.SubmitAuthChecklistResponseMandateStatusEnum = {
    Created: 'CREATED',
    Processing: 'PROCESSING',
    Submitted: 'SUBMITTED',
    Error: 'ERROR',
};
exports.TransactionLimitsPeriodEnum = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Quarterly: 'QUARTERLY',
    Yearly: 'YEARLY',
};
exports.UpdatePaymentUserRequestUserTypeEnum = {
    Individual: 'INDIVIDUAL',
    Business: 'BUSINESS',
};
exports.UpdateTestPaymentStatusRequestStatusEnum = {
    Executed: 'EXECUTED',
};
/**
 * CustomerApi - axios parameter creator
 * @export
 */
const CustomerApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Allows a customer to authorize a specific mandate
         * @param {string} mandateId The mandate_id that is being authorized
         * @param {AuthorizeMandateRequest} authorizeMandateRequest request body for authorizing a mandate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeMandate: (mandateId_1, authorizeMandateRequest_1, ...args_1) => __awaiter(this, [mandateId_1, authorizeMandateRequest_1, ...args_1], void 0, function* (mandateId, authorizeMandateRequest, options = {}) {
            // verify required parameter 'mandateId' is not null or undefined
            (0, common_1.assertParamExists)('authorizeMandate', 'mandateId', mandateId);
            // verify required parameter 'authorizeMandateRequest' is not null or undefined
            (0, common_1.assertParamExists)('authorizeMandate', 'authorizeMandateRequest', authorizeMandateRequest);
            const localVarPath = `/mandates/{mandateId}/authorize`.replace(`{${'mandateId'}}`, encodeURIComponent(String(mandateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(authorizeMandateRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * CREATE Mandate
         * @param {CreateMandateRequest} createMandateRequest request body for creating mandate
         * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMandate: (createMandateRequest_1, idempotencyKey_1, ...args_1) => __awaiter(this, [createMandateRequest_1, idempotencyKey_1, ...args_1], void 0, function* (createMandateRequest, idempotencyKey, options = {}) {
            // verify required parameter 'createMandateRequest' is not null or undefined
            (0, common_1.assertParamExists)('createMandate', 'createMandateRequest', createMandateRequest);
            const localVarPath = `/mandates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createMandateRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create new Payment
         * @param {CreatePaymentRequest} createPaymentRequest request body for creating payment
         * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayment: (createPaymentRequest_1, idempotencyKey_1, ...args_1) => __awaiter(this, [createPaymentRequest_1, idempotencyKey_1, ...args_1], void 0, function* (createPaymentRequest, idempotencyKey, options = {}) {
            // verify required parameter 'createPaymentRequest' is not null or undefined
            (0, common_1.assertParamExists)('createPayment', 'createPaymentRequest', createPaymentRequest);
            const localVarPath = `/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createPaymentRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * create payment account
         * @param {CreatePaymentAccountRequest} createPaymentAccountRequest request body for creating payment account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentAccount: (createPaymentAccountRequest_1, ...args_1) => __awaiter(this, [createPaymentAccountRequest_1, ...args_1], void 0, function* (createPaymentAccountRequest, options = {}) {
            // verify required parameter 'createPaymentAccountRequest' is not null or undefined
            (0, common_1.assertParamExists)('createPaymentAccount', 'createPaymentAccountRequest', createPaymentAccountRequest);
            const localVarPath = `/payment_accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createPaymentAccountRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new payment instruction to be used when linking to perform new payment
         * @param {CustomerPaymentInstruction} paymentInstruction Request body for starting a new Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentInstruction: (paymentInstruction_1, ...args_1) => __awaiter(this, [paymentInstruction_1, ...args_1], void 0, function* (paymentInstruction, options = {}) {
            // verify required parameter 'paymentInstruction' is not null or undefined
            (0, common_1.assertParamExists)('createPaymentInstruction', 'paymentInstruction', paymentInstruction);
            const localVarPath = `/payments/instruction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(paymentInstruction, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a payment user
         * @param {CreatePaymentUserRequest} createPaymentUserRequest request body for creating payment user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentUser: (createPaymentUserRequest_1, ...args_1) => __awaiter(this, [createPaymentUserRequest_1, ...args_1], void 0, function* (createPaymentUserRequest, options = {}) {
            // verify required parameter 'createPaymentUserRequest' is not null or undefined
            (0, common_1.assertParamExists)('createPaymentUser', 'createPaymentUserRequest', createPaymentUserRequest);
            const localVarPath = `/payment_users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createPaymentUserRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete payment account
         * @param {string} paymentAccountId The payment account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentAccount: (paymentAccountId_1, ...args_1) => __awaiter(this, [paymentAccountId_1, ...args_1], void 0, function* (paymentAccountId, options = {}) {
            // verify required parameter 'paymentAccountId' is not null or undefined
            (0, common_1.assertParamExists)('deletePaymentAccount', 'paymentAccountId', paymentAccountId);
            const localVarPath = `/payment_accounts/{paymentAccountId}`.replace(`{${'paymentAccountId'}}`, encodeURIComponent(String(paymentAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * generate a link token that can be used to create link
         * @param {LinkTokenRequest} linkTokenRequest token request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateLinkToken: (linkTokenRequest_1, ...args_1) => __awaiter(this, [linkTokenRequest_1, ...args_1], void 0, function* (linkTokenRequest, options = {}) {
            // verify required parameter 'linkTokenRequest' is not null or undefined
            (0, common_1.assertParamExists)('generateLinkToken', 'linkTokenRequest', linkTokenRequest);
            const localVarPath = `/link/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(linkTokenRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific institution by institutionId
         * @param {string} institutionId The institution id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstitution: (institutionId_1, ...args_1) => __awaiter(this, [institutionId_1, ...args_1], void 0, function* (institutionId, options = {}) {
            // verify required parameter 'institutionId' is not null or undefined
            (0, common_1.assertParamExists)('getInstitution', 'institutionId', institutionId);
            const localVarPath = `/institutions/{institutionId}`.replace(`{${'institutionId'}}`, encodeURIComponent(String(institutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', ['institution'], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get line items for display
         * @param {GetLineItemsForDisplayPaymentTypeEnum} paymentType The payment type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLineItemsForDisplay: (paymentType_1, ...args_1) => __awaiter(this, [paymentType_1, ...args_1], void 0, function* (paymentType, options = {}) {
            // verify required parameter 'paymentType' is not null or undefined
            (0, common_1.assertParamExists)('getLineItemsForDisplay', 'paymentType', paymentType);
            const localVarPath = `/calculate/line_items/{paymentType}`.replace(`{${'paymentType'}}`, encodeURIComponent(String(paymentType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific loginIdentity
         * @param {string} loginIdentityId The login identity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginIdentityById: (loginIdentityId_1, ...args_1) => __awaiter(this, [loginIdentityId_1, ...args_1], void 0, function* (loginIdentityId, options = {}) {
            // verify required parameter 'loginIdentityId' is not null or undefined
            (0, common_1.assertParamExists)('getLoginIdentityById', 'loginIdentityId', loginIdentityId);
            const localVarPath = `/login_identity/{loginIdentityId}`.replace(`{${'loginIdentityId'}}`, encodeURIComponent(String(loginIdentityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a history of events for a specific loginIdentity
         * @param {string} loginIdentityId The login identity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginIdentityHistory: (loginIdentityId_1, ...args_1) => __awaiter(this, [loginIdentityId_1, ...args_1], void 0, function* (loginIdentityId, options = {}) {
            // verify required parameter 'loginIdentityId' is not null or undefined
            (0, common_1.assertParamExists)('getLoginIdentityHistory', 'loginIdentityId', loginIdentityId);
            const localVarPath = `/login_identity/{loginIdentityId}/history`.replace(`{${'loginIdentityId'}}`, encodeURIComponent(String(loginIdentityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get Mandate details by mandate_id
         * @param {string} mandateId mandate id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMandate: (mandateId_1, ...args_1) => __awaiter(this, [mandateId_1, ...args_1], void 0, function* (mandateId, options = {}) {
            // verify required parameter 'mandateId' is not null or undefined
            (0, common_1.assertParamExists)('getMandate', 'mandateId', mandateId);
            const localVarPath = `/mandates/{mandateId}`.replace(`{${'mandateId'}}`, encodeURIComponent(String(mandateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get Mandate Authorization by mandate id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMandateAuth: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/mandates/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get link to launch FV Link UI in mandate authorization mode
         * @param {GetMandateAuthLinkRequest} getMandateAuthLinkRequest request body for mandate authorization link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMandateAuthLink: (getMandateAuthLinkRequest_1, ...args_1) => __awaiter(this, [getMandateAuthLinkRequest_1, ...args_1], void 0, function* (getMandateAuthLinkRequest, options = {}) {
            // verify required parameter 'getMandateAuthLinkRequest' is not null or undefined
            (0, common_1.assertParamExists)('getMandateAuthLink', 'getMandateAuthLinkRequest', getMandateAuthLinkRequest);
            const localVarPath = `/mandates/link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(getMandateAuthLinkRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get Payment details by payment_id
         * @param {string} paymentId payment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment: (paymentId_1, ...args_1) => __awaiter(this, [paymentId_1, ...args_1], void 0, function* (paymentId, options = {}) {
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('getPayment', 'paymentId', paymentId);
            const localVarPath = `/payments/{paymentId}`.replace(`{${'paymentId'}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get payment instructions by payment_instruction_id
         * @param {string} paymentInstructionId The id of a payment instruction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentInstruction: (paymentInstructionId_1, ...args_1) => __awaiter(this, [paymentInstructionId_1, ...args_1], void 0, function* (paymentInstructionId, options = {}) {
            // verify required parameter 'paymentInstructionId' is not null or undefined
            (0, common_1.assertParamExists)('getPaymentInstruction', 'paymentInstructionId', paymentInstructionId);
            const localVarPath = `/payments/instruction/{paymentInstructionId}`.replace(`{${'paymentInstructionId'}}`, encodeURIComponent(String(paymentInstructionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a payment user
         * @param {string} paymentUserId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentUser: (paymentUserId_1, ...args_1) => __awaiter(this, [paymentUserId_1, ...args_1], void 0, function* (paymentUserId, options = {}) {
            // verify required parameter 'paymentUserId' is not null or undefined
            (0, common_1.assertParamExists)('getPaymentUser', 'paymentUserId', paymentUserId);
            const localVarPath = `/payment_users/{paymentUserId}`.replace(`{${'paymentUserId'}}`, encodeURIComponent(String(paymentUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a list of institutions
         * @param {string} [country] (Deprecated) The country the institution belongs to
         * @param {Array<string>} [countries] The countries the institution belongs to
         * @param {string} [productsSupported] The products that this institution supports
         * @param {ListInstitutionsInstitutionTypeEnum} [institutionType] The type of institution
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInstitutions: (country_1, countries_1, productsSupported_1, institutionType_1, ...args_1) => __awaiter(this, [country_1, countries_1, productsSupported_1, institutionType_1, ...args_1], void 0, function* (country, countries, productsSupported, institutionType, options = {}) {
            const localVarPath = `/institutions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', ['institution'], configuration);
            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }
            if (countries) {
                localVarQueryParameter['countries'] = countries.join(base_1.COLLECTION_FORMATS.csv);
            }
            if (productsSupported !== undefined) {
                localVarQueryParameter['products_supported'] = productsSupported;
            }
            if (institutionType !== undefined) {
                localVarQueryParameter['institution_type'] = institutionType;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get payment account by user id
         * @param {string} paymentUserId The payment user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentAccounts: (paymentUserId_1, ...args_1) => __awaiter(this, [paymentUserId_1, ...args_1], void 0, function* (paymentUserId, options = {}) {
            // verify required parameter 'paymentUserId' is not null or undefined
            (0, common_1.assertParamExists)('listPaymentAccounts', 'paymentUserId', paymentUserId);
            const localVarPath = `/payment_users/{paymentUserId}/payment_accounts`.replace(`{${'paymentUserId'}}`, encodeURIComponent(String(paymentUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get payment account for customer app
         * @param {ListPaymentAccountsWithEnrichedDataAccountTypeEnum} [accountType] The account_type to filter for
         * @param {Array<string>} [currencies] The currencies to filter for
         * @param {number} [offset] default is 0
         * @param {number} [limit] default is 500, max is 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentAccountsWithEnrichedData: (accountType_1, currencies_1, offset_1, limit_1, ...args_1) => __awaiter(this, [accountType_1, currencies_1, offset_1, limit_1, ...args_1], void 0, function* (accountType, currencies, offset, limit, options = {}) {
            const localVarPath = `/payment_accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            if (accountType !== undefined) {
                localVarQueryParameter['account_type'] = accountType;
            }
            if (currencies) {
                localVarQueryParameter['currencies'] = currencies.join(base_1.COLLECTION_FORMATS.csv);
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Refresh an access token
         * @param {RefreshRequest} refreshRequest The refresh token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: (refreshRequest_1, ...args_1) => __awaiter(this, [refreshRequest_1, ...args_1], void 0, function* (refreshRequest, options = {}) {
            // verify required parameter 'refreshRequest' is not null or undefined
            (0, common_1.assertParamExists)('refreshToken', 'refreshRequest', refreshRequest);
            const localVarPath = `/auth/token/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(refreshRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update InstitutionID and SenderType for Mandate
         * @param {SetMandateInstitutionRequest} updateRequest request body for updating mandate institutionId and senderType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMandateInstitution: (updateRequest_1, ...args_1) => __awaiter(this, [updateRequest_1, ...args_1], void 0, function* (updateRequest, options = {}) {
            // verify required parameter 'updateRequest' is not null or undefined
            (0, common_1.assertParamExists)('setMandateInstitution', 'updateRequest', updateRequest);
            const localVarPath = `/mandates/institution_selection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Submit authorization checklist items
         * @param {SubmitAuthChecklistRequest} submitAuthChecklistRequest request body for submitting auth checklist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitAuthChecklist: (submitAuthChecklistRequest_1, ...args_1) => __awaiter(this, [submitAuthChecklistRequest_1, ...args_1], void 0, function* (submitAuthChecklistRequest, options = {}) {
            // verify required parameter 'submitAuthChecklistRequest' is not null or undefined
            (0, common_1.assertParamExists)('submitAuthChecklist', 'submitAuthChecklistRequest', submitAuthChecklistRequest);
            const localVarPath = `/mandates/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(submitAuthChecklistRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update payment
         * @param {string} paymentId payment id
         * @param {UpdatePaymentRequest} updatePaymentRequest request body for updating payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePayment: (paymentId_1, updatePaymentRequest_1, ...args_1) => __awaiter(this, [paymentId_1, updatePaymentRequest_1, ...args_1], void 0, function* (paymentId, updatePaymentRequest, options = {}) {
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('updatePayment', 'paymentId', paymentId);
            // verify required parameter 'updatePaymentRequest' is not null or undefined
            (0, common_1.assertParamExists)('updatePayment', 'updatePaymentRequest', updatePaymentRequest);
            const localVarPath = `/payments/{paymentId}`.replace(`{${'paymentId'}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updatePaymentRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update the status of a test manual payment
         * @param {string} paymentId The test payment ID
         * @param {UpdateTestPaymentStatusRequest} paymentStatus Request body for updating the test manual payment status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTestPaymentStatus: (paymentId_1, paymentStatus_1, ...args_1) => __awaiter(this, [paymentId_1, paymentStatus_1, ...args_1], void 0, function* (paymentId, paymentStatus, options = {}) {
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('updateTestPaymentStatus', 'paymentId', paymentId);
            // verify required parameter 'paymentStatus' is not null or undefined
            (0, common_1.assertParamExists)('updateTestPaymentStatus', 'paymentStatus', paymentStatus);
            const localVarPath = `/testing/payments/{paymentId}/status`.replace(`{${'paymentId'}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(paymentStatus, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.CustomerApiAxiosParamCreator = CustomerApiAxiosParamCreator;
/**
 * CustomerApi - functional programming interface
 * @export
 */
const CustomerApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CustomerApiAxiosParamCreator)(configuration);
    return {
        /**
         * Allows a customer to authorize a specific mandate
         * @param {string} mandateId The mandate_id that is being authorized
         * @param {AuthorizeMandateRequest} authorizeMandateRequest request body for authorizing a mandate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeMandate(mandateId, authorizeMandateRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.authorizeMandate(mandateId, authorizeMandateRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.authorizeMandate']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * CREATE Mandate
         * @param {CreateMandateRequest} createMandateRequest request body for creating mandate
         * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMandate(createMandateRequest, idempotencyKey, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createMandate(createMandateRequest, idempotencyKey, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.createMandate']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create new Payment
         * @param {CreatePaymentRequest} createPaymentRequest request body for creating payment
         * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayment(createPaymentRequest, idempotencyKey, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createPayment(createPaymentRequest, idempotencyKey, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.createPayment']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * create payment account
         * @param {CreatePaymentAccountRequest} createPaymentAccountRequest request body for creating payment account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentAccount(createPaymentAccountRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createPaymentAccount(createPaymentAccountRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.createPaymentAccount']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create a new payment instruction to be used when linking to perform new payment
         * @param {CustomerPaymentInstruction} paymentInstruction Request body for starting a new Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentInstruction(paymentInstruction, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createPaymentInstruction(paymentInstruction, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.createPaymentInstruction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create a payment user
         * @param {CreatePaymentUserRequest} createPaymentUserRequest request body for creating payment user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentUser(createPaymentUserRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createPaymentUser(createPaymentUserRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.createPaymentUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * delete payment account
         * @param {string} paymentAccountId The payment account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentAccount(paymentAccountId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deletePaymentAccount(paymentAccountId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.deletePaymentAccount']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * generate a link token that can be used to create link
         * @param {LinkTokenRequest} linkTokenRequest token request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateLinkToken(linkTokenRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.generateLinkToken(linkTokenRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.generateLinkToken']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a specific institution by institutionId
         * @param {string} institutionId The institution id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstitution(institutionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInstitution(institutionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.getInstitution']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get line items for display
         * @param {GetLineItemsForDisplayPaymentTypeEnum} paymentType The payment type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLineItemsForDisplay(paymentType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getLineItemsForDisplay(paymentType, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.getLineItemsForDisplay']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a specific loginIdentity
         * @param {string} loginIdentityId The login identity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginIdentityById(loginIdentityId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getLoginIdentityById(loginIdentityId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.getLoginIdentityById']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a history of events for a specific loginIdentity
         * @param {string} loginIdentityId The login identity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginIdentityHistory(loginIdentityId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getLoginIdentityHistory(loginIdentityId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.getLoginIdentityHistory']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get Mandate details by mandate_id
         * @param {string} mandateId mandate id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMandate(mandateId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getMandate(mandateId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.getMandate']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get Mandate Authorization by mandate id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMandateAuth(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getMandateAuth(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.getMandateAuth']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get link to launch FV Link UI in mandate authorization mode
         * @param {GetMandateAuthLinkRequest} getMandateAuthLinkRequest request body for mandate authorization link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMandateAuthLink(getMandateAuthLinkRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getMandateAuthLink(getMandateAuthLinkRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.getMandateAuthLink']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get Payment details by payment_id
         * @param {string} paymentId payment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment(paymentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPayment(paymentId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.getPayment']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get payment instructions by payment_instruction_id
         * @param {string} paymentInstructionId The id of a payment instruction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentInstruction(paymentInstructionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPaymentInstruction(paymentInstructionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.getPaymentInstruction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a payment user
         * @param {string} paymentUserId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentUser(paymentUserId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPaymentUser(paymentUserId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.getPaymentUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a list of institutions
         * @param {string} [country] (Deprecated) The country the institution belongs to
         * @param {Array<string>} [countries] The countries the institution belongs to
         * @param {string} [productsSupported] The products that this institution supports
         * @param {ListInstitutionsInstitutionTypeEnum} [institutionType] The type of institution
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInstitutions(country, countries, productsSupported, institutionType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listInstitutions(country, countries, productsSupported, institutionType, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.listInstitutions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get payment account by user id
         * @param {string} paymentUserId The payment user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentAccounts(paymentUserId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPaymentAccounts(paymentUserId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.listPaymentAccounts']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get payment account for customer app
         * @param {ListPaymentAccountsWithEnrichedDataAccountTypeEnum} [accountType] The account_type to filter for
         * @param {Array<string>} [currencies] The currencies to filter for
         * @param {number} [offset] default is 0
         * @param {number} [limit] default is 500, max is 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentAccountsWithEnrichedData(accountType, currencies, offset, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPaymentAccountsWithEnrichedData(accountType, currencies, offset, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.listPaymentAccountsWithEnrichedData']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Refresh an access token
         * @param {RefreshRequest} refreshRequest The refresh token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(refreshRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.refreshToken(refreshRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.refreshToken']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update InstitutionID and SenderType for Mandate
         * @param {SetMandateInstitutionRequest} updateRequest request body for updating mandate institutionId and senderType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMandateInstitution(updateRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.setMandateInstitution(updateRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.setMandateInstitution']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Submit authorization checklist items
         * @param {SubmitAuthChecklistRequest} submitAuthChecklistRequest request body for submitting auth checklist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitAuthChecklist(submitAuthChecklistRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitAuthChecklist(submitAuthChecklistRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.submitAuthChecklist']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update payment
         * @param {string} paymentId payment id
         * @param {UpdatePaymentRequest} updatePaymentRequest request body for updating payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePayment(paymentId, updatePaymentRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updatePayment(paymentId, updatePaymentRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.updatePayment']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update the status of a test manual payment
         * @param {string} paymentId The test payment ID
         * @param {UpdateTestPaymentStatusRequest} paymentStatus Request body for updating the test manual payment status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTestPaymentStatus(paymentId, paymentStatus, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateTestPaymentStatus(paymentId, paymentStatus, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerApi.updateTestPaymentStatus']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.CustomerApiFp = CustomerApiFp;
/**
 * CustomerApi - factory interface
 * @export
 */
const CustomerApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CustomerApiFp)(configuration);
    return {
        /**
         * Allows a customer to authorize a specific mandate
         * @param {string} mandateId The mandate_id that is being authorized
         * @param {AuthorizeMandateRequest} authorizeMandateRequest request body for authorizing a mandate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeMandate(mandateId, authorizeMandateRequest, options) {
            return localVarFp
                .authorizeMandate(mandateId, authorizeMandateRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * CREATE Mandate
         * @param {CreateMandateRequest} createMandateRequest request body for creating mandate
         * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMandate(createMandateRequest, idempotencyKey, options) {
            return localVarFp
                .createMandate(createMandateRequest, idempotencyKey, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Create new Payment
         * @param {CreatePaymentRequest} createPaymentRequest request body for creating payment
         * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayment(createPaymentRequest, idempotencyKey, options) {
            return localVarFp
                .createPayment(createPaymentRequest, idempotencyKey, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * create payment account
         * @param {CreatePaymentAccountRequest} createPaymentAccountRequest request body for creating payment account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentAccount(createPaymentAccountRequest, options) {
            return localVarFp
                .createPaymentAccount(createPaymentAccountRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Create a new payment instruction to be used when linking to perform new payment
         * @param {CustomerPaymentInstruction} paymentInstruction Request body for starting a new Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentInstruction(paymentInstruction, options) {
            return localVarFp
                .createPaymentInstruction(paymentInstruction, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Create a payment user
         * @param {CreatePaymentUserRequest} createPaymentUserRequest request body for creating payment user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentUser(createPaymentUserRequest, options) {
            return localVarFp
                .createPaymentUser(createPaymentUserRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * delete payment account
         * @param {string} paymentAccountId The payment account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentAccount(paymentAccountId, options) {
            return localVarFp.deletePaymentAccount(paymentAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * generate a link token that can be used to create link
         * @param {LinkTokenRequest} linkTokenRequest token request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateLinkToken(linkTokenRequest, options) {
            return localVarFp.generateLinkToken(linkTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific institution by institutionId
         * @param {string} institutionId The institution id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstitution(institutionId, options) {
            return localVarFp.getInstitution(institutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get line items for display
         * @param {GetLineItemsForDisplayPaymentTypeEnum} paymentType The payment type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLineItemsForDisplay(paymentType, options) {
            return localVarFp.getLineItemsForDisplay(paymentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific loginIdentity
         * @param {string} loginIdentityId The login identity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginIdentityById(loginIdentityId, options) {
            return localVarFp.getLoginIdentityById(loginIdentityId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a history of events for a specific loginIdentity
         * @param {string} loginIdentityId The login identity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginIdentityHistory(loginIdentityId, options) {
            return localVarFp.getLoginIdentityHistory(loginIdentityId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Mandate details by mandate_id
         * @param {string} mandateId mandate id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMandate(mandateId, options) {
            return localVarFp.getMandate(mandateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Mandate Authorization by mandate id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMandateAuth(options) {
            return localVarFp.getMandateAuth(options).then((request) => request(axios, basePath));
        },
        /**
         * Get link to launch FV Link UI in mandate authorization mode
         * @param {GetMandateAuthLinkRequest} getMandateAuthLinkRequest request body for mandate authorization link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMandateAuthLink(getMandateAuthLinkRequest, options) {
            return localVarFp
                .getMandateAuthLink(getMandateAuthLinkRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Get Payment details by payment_id
         * @param {string} paymentId payment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment(paymentId, options) {
            return localVarFp.getPayment(paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get payment instructions by payment_instruction_id
         * @param {string} paymentInstructionId The id of a payment instruction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentInstruction(paymentInstructionId, options) {
            return localVarFp
                .getPaymentInstruction(paymentInstructionId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Get a payment user
         * @param {string} paymentUserId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentUser(paymentUserId, options) {
            return localVarFp.getPaymentUser(paymentUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of institutions
         * @param {string} [country] (Deprecated) The country the institution belongs to
         * @param {Array<string>} [countries] The countries the institution belongs to
         * @param {string} [productsSupported] The products that this institution supports
         * @param {ListInstitutionsInstitutionTypeEnum} [institutionType] The type of institution
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInstitutions(country, countries, productsSupported, institutionType, options) {
            return localVarFp
                .listInstitutions(country, countries, productsSupported, institutionType, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Get payment account by user id
         * @param {string} paymentUserId The payment user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentAccounts(paymentUserId, options) {
            return localVarFp.listPaymentAccounts(paymentUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get payment account for customer app
         * @param {ListPaymentAccountsWithEnrichedDataAccountTypeEnum} [accountType] The account_type to filter for
         * @param {Array<string>} [currencies] The currencies to filter for
         * @param {number} [offset] default is 0
         * @param {number} [limit] default is 500, max is 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentAccountsWithEnrichedData(accountType, currencies, offset, limit, options) {
            return localVarFp
                .listPaymentAccountsWithEnrichedData(accountType, currencies, offset, limit, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Refresh an access token
         * @param {RefreshRequest} refreshRequest The refresh token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(refreshRequest, options) {
            return localVarFp.refreshToken(refreshRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update InstitutionID and SenderType for Mandate
         * @param {SetMandateInstitutionRequest} updateRequest request body for updating mandate institutionId and senderType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMandateInstitution(updateRequest, options) {
            return localVarFp.setMandateInstitution(updateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit authorization checklist items
         * @param {SubmitAuthChecklistRequest} submitAuthChecklistRequest request body for submitting auth checklist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitAuthChecklist(submitAuthChecklistRequest, options) {
            return localVarFp
                .submitAuthChecklist(submitAuthChecklistRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Update payment
         * @param {string} paymentId payment id
         * @param {UpdatePaymentRequest} updatePaymentRequest request body for updating payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePayment(paymentId, updatePaymentRequest, options) {
            return localVarFp
                .updatePayment(paymentId, updatePaymentRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Update the status of a test manual payment
         * @param {string} paymentId The test payment ID
         * @param {UpdateTestPaymentStatusRequest} paymentStatus Request body for updating the test manual payment status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTestPaymentStatus(paymentId, paymentStatus, options) {
            return localVarFp
                .updateTestPaymentStatus(paymentId, paymentStatus, options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.CustomerApiFactory = CustomerApiFactory;
/**
 * CustomerApi - object-oriented interface
 * @export
 * @class CustomerApi
 * @extends {BaseAPI}
 */
class CustomerApi extends base_1.BaseAPI {
    /**
     * Allows a customer to authorize a specific mandate
     * @param {string} mandateId The mandate_id that is being authorized
     * @param {AuthorizeMandateRequest} authorizeMandateRequest request body for authorizing a mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    authorizeMandate(mandateId, authorizeMandateRequest, options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .authorizeMandate(mandateId, authorizeMandateRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * CREATE Mandate
     * @param {CreateMandateRequest} createMandateRequest request body for creating mandate
     * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    createMandate(createMandateRequest, idempotencyKey, options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .createMandate(createMandateRequest, idempotencyKey, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create new Payment
     * @param {CreatePaymentRequest} createPaymentRequest request body for creating payment
     * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    createPayment(createPaymentRequest, idempotencyKey, options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .createPayment(createPaymentRequest, idempotencyKey, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * create payment account
     * @param {CreatePaymentAccountRequest} createPaymentAccountRequest request body for creating payment account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    createPaymentAccount(createPaymentAccountRequest, options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .createPaymentAccount(createPaymentAccountRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new payment instruction to be used when linking to perform new payment
     * @param {CustomerPaymentInstruction} paymentInstruction Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    createPaymentInstruction(paymentInstruction, options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .createPaymentInstruction(paymentInstruction, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a payment user
     * @param {CreatePaymentUserRequest} createPaymentUserRequest request body for creating payment user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    createPaymentUser(createPaymentUserRequest, options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .createPaymentUser(createPaymentUserRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete payment account
     * @param {string} paymentAccountId The payment account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    deletePaymentAccount(paymentAccountId, options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .deletePaymentAccount(paymentAccountId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    generateLinkToken(linkTokenRequest, options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .generateLinkToken(linkTokenRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific institution by institutionId
     * @param {string} institutionId The institution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    getInstitution(institutionId, options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .getInstitution(institutionId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get line items for display
     * @param {GetLineItemsForDisplayPaymentTypeEnum} paymentType The payment type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    getLineItemsForDisplay(paymentType, options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .getLineItemsForDisplay(paymentType, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    getLoginIdentityById(loginIdentityId, options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .getLoginIdentityById(loginIdentityId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a history of events for a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    getLoginIdentityHistory(loginIdentityId, options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .getLoginIdentityHistory(loginIdentityId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get Mandate details by mandate_id
     * @param {string} mandateId mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    getMandate(mandateId, options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .getMandate(mandateId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get Mandate Authorization by mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    getMandateAuth(options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .getMandateAuth(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get link to launch FV Link UI in mandate authorization mode
     * @param {GetMandateAuthLinkRequest} getMandateAuthLinkRequest request body for mandate authorization link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    getMandateAuthLink(getMandateAuthLinkRequest, options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .getMandateAuthLink(getMandateAuthLinkRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get Payment details by payment_id
     * @param {string} paymentId payment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    getPayment(paymentId, options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .getPayment(paymentId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get payment instructions by payment_instruction_id
     * @param {string} paymentInstructionId The id of a payment instruction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    getPaymentInstruction(paymentInstructionId, options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .getPaymentInstruction(paymentInstructionId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a payment user
     * @param {string} paymentUserId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    getPaymentUser(paymentUserId, options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .getPaymentUser(paymentUserId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a list of institutions
     * @param {string} [country] (Deprecated) The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {ListInstitutionsInstitutionTypeEnum} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    listInstitutions(country, countries, productsSupported, institutionType, options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .listInstitutions(country, countries, productsSupported, institutionType, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get payment account by user id
     * @param {string} paymentUserId The payment user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    listPaymentAccounts(paymentUserId, options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .listPaymentAccounts(paymentUserId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get payment account for customer app
     * @param {ListPaymentAccountsWithEnrichedDataAccountTypeEnum} [accountType] The account_type to filter for
     * @param {Array<string>} [currencies] The currencies to filter for
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    listPaymentAccountsWithEnrichedData(accountType, currencies, offset, limit, options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .listPaymentAccountsWithEnrichedData(accountType, currencies, offset, limit, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Refresh an access token
     * @param {RefreshRequest} refreshRequest The refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    refreshToken(refreshRequest, options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .refreshToken(refreshRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update InstitutionID and SenderType for Mandate
     * @param {SetMandateInstitutionRequest} updateRequest request body for updating mandate institutionId and senderType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    setMandateInstitution(updateRequest, options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .setMandateInstitution(updateRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Submit authorization checklist items
     * @param {SubmitAuthChecklistRequest} submitAuthChecklistRequest request body for submitting auth checklist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    submitAuthChecklist(submitAuthChecklistRequest, options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .submitAuthChecklist(submitAuthChecklistRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update payment
     * @param {string} paymentId payment id
     * @param {UpdatePaymentRequest} updatePaymentRequest request body for updating payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    updatePayment(paymentId, updatePaymentRequest, options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .updatePayment(paymentId, updatePaymentRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update the status of a test manual payment
     * @param {string} paymentId The test payment ID
     * @param {UpdateTestPaymentStatusRequest} paymentStatus Request body for updating the test manual payment status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    updateTestPaymentStatus(paymentId, paymentStatus, options) {
        return (0, exports.CustomerApiFp)(this.configuration)
            .updateTestPaymentStatus(paymentId, paymentStatus, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.CustomerApi = CustomerApi;
/**
 * @export
 */
exports.GetLineItemsForDisplayPaymentTypeEnum = {
    Mandate: 'MANDATE',
    Manual: 'MANUAL',
};
/**
 * @export
 */
exports.ListInstitutionsInstitutionTypeEnum = {
    Bank: 'BANK',
    Wallet: 'WALLET',
    Test: 'TEST',
};
/**
 * @export
 */
exports.ListPaymentAccountsWithEnrichedDataAccountTypeEnum = {
    ExternalAccount: 'EXTERNAL_ACCOUNT',
    SettlementAccount: 'SETTLEMENT_ACCOUNT',
};
/**
 * DefaultApi - axios parameter creator
 * @export
 */
const DefaultApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Cancel a payment link
         * @param {string} paymentLinkId The payment link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPaymentLink: (paymentLinkId_1, ...args_1) => __awaiter(this, [paymentLinkId_1, ...args_1], void 0, function* (paymentLinkId, options = {}) {
            // verify required parameter 'paymentLinkId' is not null or undefined
            (0, common_1.assertParamExists)('cancelPaymentLink', 'paymentLinkId', paymentLinkId);
            const localVarPath = `/payment_links/{paymentLinkId}/cancel`.replace(`{${'paymentLinkId'}}`, encodeURIComponent(String(paymentLinkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Cancel Payout by payout_id
         * @param {string} payoutId payout id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPayout: (payoutId_1, ...args_1) => __awaiter(this, [payoutId_1, ...args_1], void 0, function* (payoutId, options = {}) {
            // verify required parameter 'payoutId' is not null or undefined
            (0, common_1.assertParamExists)('cancelPayout', 'payoutId', payoutId);
            const localVarPath = `/payouts/{payoutId}/cancel`.replace(`{${'payoutId'}}`, encodeURIComponent(String(payoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Initiate change payment method from payment link front-end
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePaymentMethodPaymentLink: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/payment_link/fvlink/payment_method/change`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Submit manual payment confirmation
         * @param {ManualPaymentConfirmationRequest} manualPaymentIdentifiers Request body containing information to identify manual payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmManualPayment: (manualPaymentIdentifiers_1, ...args_1) => __awaiter(this, [manualPaymentIdentifiers_1, ...args_1], void 0, function* (manualPaymentIdentifiers, options = {}) {
            // verify required parameter 'manualPaymentIdentifiers' is not null or undefined
            (0, common_1.assertParamExists)('confirmManualPayment', 'manualPaymentIdentifiers', manualPaymentIdentifiers);
            const localVarPath = `/payments/manual_payment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(manualPaymentIdentifiers, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Confirm a payment against a payment Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmPayment: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/payment_links/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create token for fps flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFpsToken: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/payment_links/fps/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create mandate for an existing sender account
         * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
         * @param {CreateMandateWithSenderAccountRequest} createMandateRequest request body for creating mandate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMandateForExistingSender: (idempotencyKey_1, createMandateRequest_1, ...args_1) => __awaiter(this, [idempotencyKey_1, createMandateRequest_1, ...args_1], void 0, function* (idempotencyKey, createMandateRequest, options = {}) {
            // verify required parameter 'idempotencyKey' is not null or undefined
            (0, common_1.assertParamExists)('createMandateForExistingSender', 'idempotencyKey', idempotencyKey);
            // verify required parameter 'createMandateRequest' is not null or undefined
            (0, common_1.assertParamExists)('createMandateForExistingSender', 'createMandateRequest', createMandateRequest);
            const localVarPath = `/mandates/sender_account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createMandateRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create payment link
         * @param {CreatePaymentLinkRequest} createPaymentLinkRequest Parameters required to create a payment link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentLink: (createPaymentLinkRequest_1, ...args_1) => __awaiter(this, [createPaymentLinkRequest_1, ...args_1], void 0, function* (createPaymentLinkRequest, options = {}) {
            // verify required parameter 'createPaymentLinkRequest' is not null or undefined
            (0, common_1.assertParamExists)('createPaymentLink', 'createPaymentLinkRequest', createPaymentLinkRequest);
            const localVarPath = `/payment_links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createPaymentLinkRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Initiate Card Payment for a Payment Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentLinkCardPayment: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/payment_links/card`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * CREATE Mandate for payment link
         * @param {CreatePaymentLinkMandateRequest} createPaymentLinkMandateRequest request body for creating mandate for payment-link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentLinkMandate: (createPaymentLinkMandateRequest_1, ...args_1) => __awaiter(this, [createPaymentLinkMandateRequest_1, ...args_1], void 0, function* (createPaymentLinkMandateRequest, options = {}) {
            // verify required parameter 'createPaymentLinkMandateRequest' is not null or undefined
            (0, common_1.assertParamExists)('createPaymentLinkMandate', 'createPaymentLinkMandateRequest', createPaymentLinkMandateRequest);
            const localVarPath = `/payment_links/mandates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createPaymentLinkMandateRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a Payment Method for a user
         * @param {string} paymentUserId Payment User ID
         * @param {CreatePaymentMethodRequest} createPaymentMethodRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethod: (paymentUserId_1, createPaymentMethodRequest_1, ...args_1) => __awaiter(this, [paymentUserId_1, createPaymentMethodRequest_1, ...args_1], void 0, function* (paymentUserId, createPaymentMethodRequest, options = {}) {
            // verify required parameter 'paymentUserId' is not null or undefined
            (0, common_1.assertParamExists)('createPaymentMethod', 'paymentUserId', paymentUserId);
            // verify required parameter 'createPaymentMethodRequest' is not null or undefined
            (0, common_1.assertParamExists)('createPaymentMethod', 'createPaymentMethodRequest', createPaymentMethodRequest);
            const localVarPath = `/payment_users/{paymentUserId}/payment_methods`.replace(`{${'paymentUserId'}}`, encodeURIComponent(String(paymentUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createPaymentMethodRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a scheduled payout
         * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
         * @param {CreateScheduledPayoutRequest} createScheduledPayoutRequest Request body containing information to create scheduled payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScheduledPayout: (idempotencyKey_1, createScheduledPayoutRequest_1, ...args_1) => __awaiter(this, [idempotencyKey_1, createScheduledPayoutRequest_1, ...args_1], void 0, function* (idempotencyKey, createScheduledPayoutRequest, options = {}) {
            // verify required parameter 'idempotencyKey' is not null or undefined
            (0, common_1.assertParamExists)('createScheduledPayout', 'idempotencyKey', idempotencyKey);
            // verify required parameter 'createScheduledPayoutRequest' is not null or undefined
            (0, common_1.assertParamExists)('createScheduledPayout', 'createScheduledPayoutRequest', createScheduledPayoutRequest);
            const localVarPath = `/payouts/scheduled`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createScheduledPayoutRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Demote payment attempt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demotePaymentAttempt: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/payment_link/fvlink/payment_attempt/demote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Download the balance statement for the ledger (CSV)
         * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
         * @param {string} [dateTo] ISO format (YYYY-MM-DD)
         * @param {Array<string>} [currencies] The currencies to filter for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadBalanceStatement: (dateFrom_1, dateTo_1, currencies_1, ...args_1) => __awaiter(this, [dateFrom_1, dateTo_1, currencies_1, ...args_1], void 0, function* (dateFrom, dateTo, currencies, options = {}) {
            const localVarPath = `/ledger/statement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] =
                    dateFrom instanceof Date ? dateFrom.toISOString().substring(0, 10) : dateFrom;
            }
            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] =
                    dateTo instanceof Date ? dateTo.toISOString().substring(0, 10) : dateTo;
            }
            if (currencies) {
                localVarQueryParameter['currencies'] = currencies.join(base_1.COLLECTION_FORMATS.csv);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get the FPS QR code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFpsQrCode: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/payment_links/fps/qr_code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a customer-specific list of institutions for Finverse Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstitutionsForCustomer: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/institutions/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get payment link
         * @param {string} paymentLinkId The payment link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentLink: (paymentLinkId_1, ...args_1) => __awaiter(this, [paymentLinkId_1, ...args_1], void 0, function* (paymentLinkId, options = {}) {
            // verify required parameter 'paymentLinkId' is not null or undefined
            (0, common_1.assertParamExists)('getPaymentLink', 'paymentLinkId', paymentLinkId);
            const localVarPath = `/payment_links/{paymentLinkId}`.replace(`{${'paymentLinkId'}}`, encodeURIComponent(String(paymentLinkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a payment method
         * @param {string} paymentMethodId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethod: (paymentMethodId_1, ...args_1) => __awaiter(this, [paymentMethodId_1, ...args_1], void 0, function* (paymentMethodId, options = {}) {
            // verify required parameter 'paymentMethodId' is not null or undefined
            (0, common_1.assertParamExists)('getPaymentMethod', 'paymentMethodId', paymentMethodId);
            const localVarPath = `/payment_methods/{paymentMethodId}`.replace(`{${'paymentMethodId'}}`, encodeURIComponent(String(paymentMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get payment method in payment link flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodPaymentLink: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/payment_link/fvlink/payment_method`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get payment (if exists) on the payment link for front-end
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentPaymentLink: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/payment_link/fvlink/payment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get payout by payout_id
         * @param {string} payoutId payout id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayoutById: (payoutId_1, ...args_1) => __awaiter(this, [payoutId_1, ...args_1], void 0, function* (payoutId, options = {}) {
            // verify required parameter 'payoutId' is not null or undefined
            (0, common_1.assertParamExists)('getPayoutById', 'payoutId', payoutId);
            const localVarPath = `/payouts/{payoutId}`.replace(`{${'payoutId'}}`, encodeURIComponent(String(payoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get sender payment user in payment link flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSenderPaymentUser: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/payment_link/fvlink/payment_user/sender`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List mandates details
         * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
         * @param {string} [dateTo] ISO format (YYYY-MM-DD)
         * @param {Array<ListDetokenizedMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
         * @param {ListDetokenizedMandatesSenderTypeEnum} [senderType] The sender type of the mandate
         * @param {string} [userId] The user_id the mandate was setup for
         * @param {string} [institutionId] The institution the mandate was executed against
         * @param {number} [offset] default is 0
         * @param {number} [limit] default is 500, max is 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDetokenizedMandates: (dateFrom_1, dateTo_1, statuses_1, senderType_1, userId_1, institutionId_1, offset_1, limit_1, ...args_1) => __awaiter(this, [dateFrom_1, dateTo_1, statuses_1, senderType_1, userId_1, institutionId_1, offset_1, limit_1, ...args_1], void 0, function* (dateFrom, dateTo, statuses, senderType, userId, institutionId, offset, limit, options = {}) {
            const localVarPath = `/mandates/details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] =
                    dateFrom instanceof Date ? dateFrom.toISOString().substring(0, 10) : dateFrom;
            }
            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] =
                    dateTo instanceof Date ? dateTo.toISOString().substring(0, 10) : dateTo;
            }
            if (statuses) {
                localVarQueryParameter['statuses'] = statuses.join(base_1.COLLECTION_FORMATS.csv);
            }
            if (senderType !== undefined) {
                localVarQueryParameter['sender_type'] = senderType;
            }
            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }
            if (institutionId !== undefined) {
                localVarQueryParameter['institution_id'] = institutionId;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List Disputes
         * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
         * @param {string} [dateTo] ISO format (YYYY-MM-DD)
         * @param {Array<ListDisputesStatusesEnum>} [statuses] The dispute statuses to filter for, comma separated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDisputes: (dateFrom_1, dateTo_1, statuses_1, ...args_1) => __awaiter(this, [dateFrom_1, dateTo_1, statuses_1, ...args_1], void 0, function* (dateFrom, dateTo, statuses, options = {}) {
            const localVarPath = `/disputes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] =
                    dateFrom instanceof Date ? dateFrom.toISOString().substring(0, 10) : dateFrom;
            }
            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] =
                    dateTo instanceof Date ? dateTo.toISOString().substring(0, 10) : dateTo;
            }
            if (statuses) {
                localVarQueryParameter['statuses'] = statuses.join(base_1.COLLECTION_FORMATS.csv);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List mandates
         * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
         * @param {string} [dateTo] ISO format (YYYY-MM-DD)
         * @param {Array<ListMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
         * @param {ListMandatesSenderTypeEnum} [senderType] The sender type of the mandate
         * @param {string} [userId] The user_id the mandate was setup for
         * @param {string} [institutionId] The institution the mandate was executed against
         * @param {number} [offset] default is 0
         * @param {number} [limit] default is 500, max is 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMandates: (dateFrom_1, dateTo_1, statuses_1, senderType_1, userId_1, institutionId_1, offset_1, limit_1, ...args_1) => __awaiter(this, [dateFrom_1, dateTo_1, statuses_1, senderType_1, userId_1, institutionId_1, offset_1, limit_1, ...args_1], void 0, function* (dateFrom, dateTo, statuses, senderType, userId, institutionId, offset, limit, options = {}) {
            const localVarPath = `/mandates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] =
                    dateFrom instanceof Date ? dateFrom.toISOString().substring(0, 10) : dateFrom;
            }
            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] =
                    dateTo instanceof Date ? dateTo.toISOString().substring(0, 10) : dateTo;
            }
            if (statuses) {
                localVarQueryParameter['statuses'] = statuses.join(base_1.COLLECTION_FORMATS.csv);
            }
            if (senderType !== undefined) {
                localVarQueryParameter['sender_type'] = senderType;
            }
            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }
            if (institutionId !== undefined) {
                localVarQueryParameter['institution_id'] = institutionId;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List Payment Methods for a User
         * @param {string} paymentUserId Payment User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentMethods: (paymentUserId_1, ...args_1) => __awaiter(this, [paymentUserId_1, ...args_1], void 0, function* (paymentUserId, options = {}) {
            // verify required parameter 'paymentUserId' is not null or undefined
            (0, common_1.assertParamExists)('listPaymentMethods', 'paymentUserId', paymentUserId);
            const localVarPath = `/payment_users/{paymentUserId}/payment_methods`.replace(`{${'paymentUserId'}}`, encodeURIComponent(String(paymentUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List Payments
         * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
         * @param {string} [dateTo] ISO format (YYYY-MM-DD)
         * @param {Array<ListPaymentsStatusesEnum>} [statuses] The payment statuses to filter for, comma separated
         * @param {ListPaymentsSenderTypeEnum} [senderType] The sender type of the mandate
         * @param {string} [userId] The user_id the mandate was setup for
         * @param {string} [institutionId] The institution the mandate was executed against
         * @param {ListPaymentsPaymentTypeEnum} [paymentType] Deprecated - The type of payment
         * @param {Array<ListPaymentsPaymentTypesEnum>} [paymentTypes]
         * @param {string} [mandateId] The mandate the payment belongs to
         * @param {string} [currency] Deprecated - The currency the payment is made in
         * @param {Array<string>} [currencies]
         * @param {number} [offset] default is 0
         * @param {number} [limit] default is 500, max is 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments: (dateFrom_1, dateTo_1, statuses_1, senderType_1, userId_1, institutionId_1, paymentType_1, paymentTypes_1, mandateId_1, currency_1, currencies_1, offset_1, limit_1, ...args_1) => __awaiter(this, [dateFrom_1, dateTo_1, statuses_1, senderType_1, userId_1, institutionId_1, paymentType_1, paymentTypes_1, mandateId_1, currency_1, currencies_1, offset_1, limit_1, ...args_1], void 0, function* (dateFrom, dateTo, statuses, senderType, userId, institutionId, paymentType, paymentTypes, mandateId, currency, currencies, offset, limit, options = {}) {
            const localVarPath = `/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] =
                    dateFrom instanceof Date ? dateFrom.toISOString().substring(0, 10) : dateFrom;
            }
            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] =
                    dateTo instanceof Date ? dateTo.toISOString().substring(0, 10) : dateTo;
            }
            if (statuses) {
                localVarQueryParameter['statuses'] = statuses.join(base_1.COLLECTION_FORMATS.csv);
            }
            if (senderType !== undefined) {
                localVarQueryParameter['sender_type'] = senderType;
            }
            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }
            if (institutionId !== undefined) {
                localVarQueryParameter['institution_id'] = institutionId;
            }
            if (paymentType !== undefined) {
                localVarQueryParameter['payment_type'] = paymentType;
            }
            if (paymentTypes) {
                localVarQueryParameter['payment_types'] = paymentTypes.join(base_1.COLLECTION_FORMATS.csv);
            }
            if (mandateId !== undefined) {
                localVarQueryParameter['mandate_id'] = mandateId;
            }
            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }
            if (currencies) {
                localVarQueryParameter['currencies'] = currencies.join(base_1.COLLECTION_FORMATS.csv);
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List payouts
         * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
         * @param {string} [dateTo] ISO format (YYYY-MM-DD)
         * @param {Array<ListPayoutsStatusesEnum>} [statuses] The payout statuses to filter for, comma separated
         * @param {Array<string>} [currencies]
         * @param {Array<ListPayoutsPayoutTypesEnum>} [payoutTypes]
         * @param {string} [mandateId]
         * @param {string} [senderAccountId]
         * @param {string} [recipientAccountId]
         * @param {string} [recipientUserId]
         * @param {string} [recipientExternalUserId]
         * @param {number} [offset] Default is 0
         * @param {number} [limit] default is 500, max is 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayouts: (dateFrom_1, dateTo_1, statuses_1, currencies_1, payoutTypes_1, mandateId_1, senderAccountId_1, recipientAccountId_1, recipientUserId_1, recipientExternalUserId_1, offset_1, limit_1, ...args_1) => __awaiter(this, [dateFrom_1, dateTo_1, statuses_1, currencies_1, payoutTypes_1, mandateId_1, senderAccountId_1, recipientAccountId_1, recipientUserId_1, recipientExternalUserId_1, offset_1, limit_1, ...args_1], void 0, function* (dateFrom, dateTo, statuses, currencies, payoutTypes, mandateId, senderAccountId, recipientAccountId, recipientUserId, recipientExternalUserId, offset, limit, options = {}) {
            const localVarPath = `/payouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] =
                    dateFrom instanceof Date ? dateFrom.toISOString().substring(0, 10) : dateFrom;
            }
            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] =
                    dateTo instanceof Date ? dateTo.toISOString().substring(0, 10) : dateTo;
            }
            if (statuses) {
                localVarQueryParameter['statuses'] = statuses.join(base_1.COLLECTION_FORMATS.csv);
            }
            if (currencies) {
                localVarQueryParameter['currencies'] = currencies.join(base_1.COLLECTION_FORMATS.csv);
            }
            if (payoutTypes) {
                localVarQueryParameter['payout_types'] = payoutTypes.join(base_1.COLLECTION_FORMATS.csv);
            }
            if (mandateId !== undefined) {
                localVarQueryParameter['mandate_id'] = mandateId;
            }
            if (senderAccountId !== undefined) {
                localVarQueryParameter['sender_account_id'] = senderAccountId;
            }
            if (recipientAccountId !== undefined) {
                localVarQueryParameter['recipient_account_id'] = recipientAccountId;
            }
            if (recipientUserId !== undefined) {
                localVarQueryParameter['recipient_user_id'] = recipientUserId;
            }
            if (recipientExternalUserId !== undefined) {
                localVarQueryParameter['recipient_external_user_id'] = recipientExternalUserId;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Refresh payment attempt from payment link front-end
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshPaymentAttempt: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/payment_link/fvlink/payment_attempt/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Set autopay consent for payment user
         * @param {SetAutopayConsentRequest} setAutopayConsentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAutopayConsent: (setAutopayConsentRequest_1, ...args_1) => __awaiter(this, [setAutopayConsentRequest_1, ...args_1], void 0, function* (setAutopayConsentRequest, options = {}) {
            // verify required parameter 'setAutopayConsentRequest' is not null or undefined
            (0, common_1.assertParamExists)('setAutopayConsent', 'setAutopayConsentRequest', setAutopayConsentRequest);
            const localVarPath = `/payment_link/fvlink/payment_user/autopay`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(setAutopayConsentRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a payment user
         * @param {string} paymentUserId
         * @param {UpdatePaymentUserRequest} updatePaymentUserRequest request body for updating payment user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentUser: (paymentUserId_1, updatePaymentUserRequest_1, ...args_1) => __awaiter(this, [paymentUserId_1, updatePaymentUserRequest_1, ...args_1], void 0, function* (paymentUserId, updatePaymentUserRequest, options = {}) {
            // verify required parameter 'paymentUserId' is not null or undefined
            (0, common_1.assertParamExists)('updatePaymentUser', 'paymentUserId', paymentUserId);
            // verify required parameter 'updatePaymentUserRequest' is not null or undefined
            (0, common_1.assertParamExists)('updatePaymentUser', 'updatePaymentUserRequest', updatePaymentUserRequest);
            const localVarPath = `/payment_users/{paymentUserId}`.replace(`{${'paymentUserId'}}`, encodeURIComponent(String(paymentUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updatePaymentUserRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.DefaultApiAxiosParamCreator = DefaultApiAxiosParamCreator;
/**
 * DefaultApi - functional programming interface
 * @export
 */
const DefaultApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.DefaultApiAxiosParamCreator)(configuration);
    return {
        /**
         * Cancel a payment link
         * @param {string} paymentLinkId The payment link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPaymentLink(paymentLinkId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelPaymentLink(paymentLinkId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.cancelPaymentLink']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Cancel Payout by payout_id
         * @param {string} payoutId payout id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPayout(payoutId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelPayout(payoutId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.cancelPayout']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Initiate change payment method from payment link front-end
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePaymentMethodPaymentLink(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.changePaymentMethodPaymentLink(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.changePaymentMethodPaymentLink']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Submit manual payment confirmation
         * @param {ManualPaymentConfirmationRequest} manualPaymentIdentifiers Request body containing information to identify manual payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmManualPayment(manualPaymentIdentifiers, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.confirmManualPayment(manualPaymentIdentifiers, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.confirmManualPayment']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Confirm a payment against a payment Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmPayment(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.confirmPayment(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.confirmPayment']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create token for fps flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFpsToken(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createFpsToken(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.createFpsToken']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create mandate for an existing sender account
         * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
         * @param {CreateMandateWithSenderAccountRequest} createMandateRequest request body for creating mandate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMandateForExistingSender(idempotencyKey, createMandateRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createMandateForExistingSender(idempotencyKey, createMandateRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.createMandateForExistingSender']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create payment link
         * @param {CreatePaymentLinkRequest} createPaymentLinkRequest Parameters required to create a payment link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentLink(createPaymentLinkRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createPaymentLink(createPaymentLinkRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.createPaymentLink']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Initiate Card Payment for a Payment Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentLinkCardPayment(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createPaymentLinkCardPayment(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.createPaymentLinkCardPayment']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * CREATE Mandate for payment link
         * @param {CreatePaymentLinkMandateRequest} createPaymentLinkMandateRequest request body for creating mandate for payment-link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentLinkMandate(createPaymentLinkMandateRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createPaymentLinkMandate(createPaymentLinkMandateRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.createPaymentLinkMandate']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create a Payment Method for a user
         * @param {string} paymentUserId Payment User ID
         * @param {CreatePaymentMethodRequest} createPaymentMethodRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethod(paymentUserId, createPaymentMethodRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createPaymentMethod(paymentUserId, createPaymentMethodRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.createPaymentMethod']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create a scheduled payout
         * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
         * @param {CreateScheduledPayoutRequest} createScheduledPayoutRequest Request body containing information to create scheduled payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScheduledPayout(idempotencyKey, createScheduledPayoutRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createScheduledPayout(idempotencyKey, createScheduledPayoutRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.createScheduledPayout']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Demote payment attempt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demotePaymentAttempt(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.demotePaymentAttempt(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.demotePaymentAttempt']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Download the balance statement for the ledger (CSV)
         * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
         * @param {string} [dateTo] ISO format (YYYY-MM-DD)
         * @param {Array<string>} [currencies] The currencies to filter for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadBalanceStatement(dateFrom, dateTo, currencies, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadBalanceStatement(dateFrom, dateTo, currencies, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.downloadBalanceStatement']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get the FPS QR code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFpsQrCode(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getFpsQrCode(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.getFpsQrCode']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a customer-specific list of institutions for Finverse Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstitutionsForCustomer(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInstitutionsForCustomer(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.getInstitutionsForCustomer']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get payment link
         * @param {string} paymentLinkId The payment link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentLink(paymentLinkId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPaymentLink(paymentLinkId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.getPaymentLink']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a payment method
         * @param {string} paymentMethodId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethod(paymentMethodId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPaymentMethod(paymentMethodId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.getPaymentMethod']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get payment method in payment link flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodPaymentLink(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPaymentMethodPaymentLink(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.getPaymentMethodPaymentLink']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get payment (if exists) on the payment link for front-end
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentPaymentLink(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPaymentPaymentLink(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.getPaymentPaymentLink']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get payout by payout_id
         * @param {string} payoutId payout id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayoutById(payoutId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPayoutById(payoutId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.getPayoutById']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get sender payment user in payment link flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSenderPaymentUser(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSenderPaymentUser(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.getSenderPaymentUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List mandates details
         * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
         * @param {string} [dateTo] ISO format (YYYY-MM-DD)
         * @param {Array<ListDetokenizedMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
         * @param {ListDetokenizedMandatesSenderTypeEnum} [senderType] The sender type of the mandate
         * @param {string} [userId] The user_id the mandate was setup for
         * @param {string} [institutionId] The institution the mandate was executed against
         * @param {number} [offset] default is 0
         * @param {number} [limit] default is 500, max is 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDetokenizedMandates(dateFrom, dateTo, statuses, senderType, userId, institutionId, offset, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listDetokenizedMandates(dateFrom, dateTo, statuses, senderType, userId, institutionId, offset, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.listDetokenizedMandates']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List Disputes
         * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
         * @param {string} [dateTo] ISO format (YYYY-MM-DD)
         * @param {Array<ListDisputesStatusesEnum>} [statuses] The dispute statuses to filter for, comma separated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDisputes(dateFrom, dateTo, statuses, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listDisputes(dateFrom, dateTo, statuses, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.listDisputes']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List mandates
         * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
         * @param {string} [dateTo] ISO format (YYYY-MM-DD)
         * @param {Array<ListMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
         * @param {ListMandatesSenderTypeEnum} [senderType] The sender type of the mandate
         * @param {string} [userId] The user_id the mandate was setup for
         * @param {string} [institutionId] The institution the mandate was executed against
         * @param {number} [offset] default is 0
         * @param {number} [limit] default is 500, max is 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMandates(dateFrom, dateTo, statuses, senderType, userId, institutionId, offset, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listMandates(dateFrom, dateTo, statuses, senderType, userId, institutionId, offset, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.listMandates']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List Payment Methods for a User
         * @param {string} paymentUserId Payment User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentMethods(paymentUserId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPaymentMethods(paymentUserId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.listPaymentMethods']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List Payments
         * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
         * @param {string} [dateTo] ISO format (YYYY-MM-DD)
         * @param {Array<ListPaymentsStatusesEnum>} [statuses] The payment statuses to filter for, comma separated
         * @param {ListPaymentsSenderTypeEnum} [senderType] The sender type of the mandate
         * @param {string} [userId] The user_id the mandate was setup for
         * @param {string} [institutionId] The institution the mandate was executed against
         * @param {ListPaymentsPaymentTypeEnum} [paymentType] Deprecated - The type of payment
         * @param {Array<ListPaymentsPaymentTypesEnum>} [paymentTypes]
         * @param {string} [mandateId] The mandate the payment belongs to
         * @param {string} [currency] Deprecated - The currency the payment is made in
         * @param {Array<string>} [currencies]
         * @param {number} [offset] default is 0
         * @param {number} [limit] default is 500, max is 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments(dateFrom, dateTo, statuses, senderType, userId, institutionId, paymentType, paymentTypes, mandateId, currency, currencies, offset, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPayments(dateFrom, dateTo, statuses, senderType, userId, institutionId, paymentType, paymentTypes, mandateId, currency, currencies, offset, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.listPayments']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List payouts
         * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
         * @param {string} [dateTo] ISO format (YYYY-MM-DD)
         * @param {Array<ListPayoutsStatusesEnum>} [statuses] The payout statuses to filter for, comma separated
         * @param {Array<string>} [currencies]
         * @param {Array<ListPayoutsPayoutTypesEnum>} [payoutTypes]
         * @param {string} [mandateId]
         * @param {string} [senderAccountId]
         * @param {string} [recipientAccountId]
         * @param {string} [recipientUserId]
         * @param {string} [recipientExternalUserId]
         * @param {number} [offset] Default is 0
         * @param {number} [limit] default is 500, max is 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayouts(dateFrom, dateTo, statuses, currencies, payoutTypes, mandateId, senderAccountId, recipientAccountId, recipientUserId, recipientExternalUserId, offset, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPayouts(dateFrom, dateTo, statuses, currencies, payoutTypes, mandateId, senderAccountId, recipientAccountId, recipientUserId, recipientExternalUserId, offset, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.listPayouts']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Refresh payment attempt from payment link front-end
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshPaymentAttempt(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.refreshPaymentAttempt(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.refreshPaymentAttempt']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Set autopay consent for payment user
         * @param {SetAutopayConsentRequest} setAutopayConsentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAutopayConsent(setAutopayConsentRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.setAutopayConsent(setAutopayConsentRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.setAutopayConsent']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update a payment user
         * @param {string} paymentUserId
         * @param {UpdatePaymentUserRequest} updatePaymentUserRequest request body for updating payment user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentUser(paymentUserId, updatePaymentUserRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updatePaymentUser(paymentUserId, updatePaymentUserRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.updatePaymentUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.DefaultApiFp = DefaultApiFp;
/**
 * DefaultApi - factory interface
 * @export
 */
const DefaultApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.DefaultApiFp)(configuration);
    return {
        /**
         * Cancel a payment link
         * @param {string} paymentLinkId The payment link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPaymentLink(paymentLinkId, options) {
            return localVarFp.cancelPaymentLink(paymentLinkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel Payout by payout_id
         * @param {string} payoutId payout id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPayout(payoutId, options) {
            return localVarFp.cancelPayout(payoutId, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiate change payment method from payment link front-end
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePaymentMethodPaymentLink(options) {
            return localVarFp.changePaymentMethodPaymentLink(options).then((request) => request(axios, basePath));
        },
        /**
         * Submit manual payment confirmation
         * @param {ManualPaymentConfirmationRequest} manualPaymentIdentifiers Request body containing information to identify manual payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmManualPayment(manualPaymentIdentifiers, options) {
            return localVarFp
                .confirmManualPayment(manualPaymentIdentifiers, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Confirm a payment against a payment Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmPayment(options) {
            return localVarFp.confirmPayment(options).then((request) => request(axios, basePath));
        },
        /**
         * Create token for fps flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFpsToken(options) {
            return localVarFp.createFpsToken(options).then((request) => request(axios, basePath));
        },
        /**
         * Create mandate for an existing sender account
         * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
         * @param {CreateMandateWithSenderAccountRequest} createMandateRequest request body for creating mandate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMandateForExistingSender(idempotencyKey, createMandateRequest, options) {
            return localVarFp
                .createMandateForExistingSender(idempotencyKey, createMandateRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Create payment link
         * @param {CreatePaymentLinkRequest} createPaymentLinkRequest Parameters required to create a payment link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentLink(createPaymentLinkRequest, options) {
            return localVarFp
                .createPaymentLink(createPaymentLinkRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Initiate Card Payment for a Payment Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentLinkCardPayment(options) {
            return localVarFp.createPaymentLinkCardPayment(options).then((request) => request(axios, basePath));
        },
        /**
         * CREATE Mandate for payment link
         * @param {CreatePaymentLinkMandateRequest} createPaymentLinkMandateRequest request body for creating mandate for payment-link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentLinkMandate(createPaymentLinkMandateRequest, options) {
            return localVarFp
                .createPaymentLinkMandate(createPaymentLinkMandateRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Create a Payment Method for a user
         * @param {string} paymentUserId Payment User ID
         * @param {CreatePaymentMethodRequest} createPaymentMethodRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethod(paymentUserId, createPaymentMethodRequest, options) {
            return localVarFp
                .createPaymentMethod(paymentUserId, createPaymentMethodRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Create a scheduled payout
         * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
         * @param {CreateScheduledPayoutRequest} createScheduledPayoutRequest Request body containing information to create scheduled payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScheduledPayout(idempotencyKey, createScheduledPayoutRequest, options) {
            return localVarFp
                .createScheduledPayout(idempotencyKey, createScheduledPayoutRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Demote payment attempt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demotePaymentAttempt(options) {
            return localVarFp.demotePaymentAttempt(options).then((request) => request(axios, basePath));
        },
        /**
         * Download the balance statement for the ledger (CSV)
         * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
         * @param {string} [dateTo] ISO format (YYYY-MM-DD)
         * @param {Array<string>} [currencies] The currencies to filter for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadBalanceStatement(dateFrom, dateTo, currencies, options) {
            return localVarFp
                .downloadBalanceStatement(dateFrom, dateTo, currencies, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Get the FPS QR code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFpsQrCode(options) {
            return localVarFp.getFpsQrCode(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a customer-specific list of institutions for Finverse Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstitutionsForCustomer(options) {
            return localVarFp.getInstitutionsForCustomer(options).then((request) => request(axios, basePath));
        },
        /**
         * Get payment link
         * @param {string} paymentLinkId The payment link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentLink(paymentLinkId, options) {
            return localVarFp.getPaymentLink(paymentLinkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a payment method
         * @param {string} paymentMethodId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethod(paymentMethodId, options) {
            return localVarFp.getPaymentMethod(paymentMethodId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get payment method in payment link flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodPaymentLink(options) {
            return localVarFp.getPaymentMethodPaymentLink(options).then((request) => request(axios, basePath));
        },
        /**
         * Get payment (if exists) on the payment link for front-end
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentPaymentLink(options) {
            return localVarFp.getPaymentPaymentLink(options).then((request) => request(axios, basePath));
        },
        /**
         * Get payout by payout_id
         * @param {string} payoutId payout id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayoutById(payoutId, options) {
            return localVarFp.getPayoutById(payoutId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get sender payment user in payment link flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSenderPaymentUser(options) {
            return localVarFp.getSenderPaymentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * List mandates details
         * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
         * @param {string} [dateTo] ISO format (YYYY-MM-DD)
         * @param {Array<ListDetokenizedMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
         * @param {ListDetokenizedMandatesSenderTypeEnum} [senderType] The sender type of the mandate
         * @param {string} [userId] The user_id the mandate was setup for
         * @param {string} [institutionId] The institution the mandate was executed against
         * @param {number} [offset] default is 0
         * @param {number} [limit] default is 500, max is 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDetokenizedMandates(dateFrom, dateTo, statuses, senderType, userId, institutionId, offset, limit, options) {
            return localVarFp
                .listDetokenizedMandates(dateFrom, dateTo, statuses, senderType, userId, institutionId, offset, limit, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * List Disputes
         * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
         * @param {string} [dateTo] ISO format (YYYY-MM-DD)
         * @param {Array<ListDisputesStatusesEnum>} [statuses] The dispute statuses to filter for, comma separated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDisputes(dateFrom, dateTo, statuses, options) {
            return localVarFp.listDisputes(dateFrom, dateTo, statuses, options).then((request) => request(axios, basePath));
        },
        /**
         * List mandates
         * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
         * @param {string} [dateTo] ISO format (YYYY-MM-DD)
         * @param {Array<ListMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
         * @param {ListMandatesSenderTypeEnum} [senderType] The sender type of the mandate
         * @param {string} [userId] The user_id the mandate was setup for
         * @param {string} [institutionId] The institution the mandate was executed against
         * @param {number} [offset] default is 0
         * @param {number} [limit] default is 500, max is 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMandates(dateFrom, dateTo, statuses, senderType, userId, institutionId, offset, limit, options) {
            return localVarFp
                .listMandates(dateFrom, dateTo, statuses, senderType, userId, institutionId, offset, limit, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * List Payment Methods for a User
         * @param {string} paymentUserId Payment User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentMethods(paymentUserId, options) {
            return localVarFp.listPaymentMethods(paymentUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * List Payments
         * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
         * @param {string} [dateTo] ISO format (YYYY-MM-DD)
         * @param {Array<ListPaymentsStatusesEnum>} [statuses] The payment statuses to filter for, comma separated
         * @param {ListPaymentsSenderTypeEnum} [senderType] The sender type of the mandate
         * @param {string} [userId] The user_id the mandate was setup for
         * @param {string} [institutionId] The institution the mandate was executed against
         * @param {ListPaymentsPaymentTypeEnum} [paymentType] Deprecated - The type of payment
         * @param {Array<ListPaymentsPaymentTypesEnum>} [paymentTypes]
         * @param {string} [mandateId] The mandate the payment belongs to
         * @param {string} [currency] Deprecated - The currency the payment is made in
         * @param {Array<string>} [currencies]
         * @param {number} [offset] default is 0
         * @param {number} [limit] default is 500, max is 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments(dateFrom, dateTo, statuses, senderType, userId, institutionId, paymentType, paymentTypes, mandateId, currency, currencies, offset, limit, options) {
            return localVarFp
                .listPayments(dateFrom, dateTo, statuses, senderType, userId, institutionId, paymentType, paymentTypes, mandateId, currency, currencies, offset, limit, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * List payouts
         * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
         * @param {string} [dateTo] ISO format (YYYY-MM-DD)
         * @param {Array<ListPayoutsStatusesEnum>} [statuses] The payout statuses to filter for, comma separated
         * @param {Array<string>} [currencies]
         * @param {Array<ListPayoutsPayoutTypesEnum>} [payoutTypes]
         * @param {string} [mandateId]
         * @param {string} [senderAccountId]
         * @param {string} [recipientAccountId]
         * @param {string} [recipientUserId]
         * @param {string} [recipientExternalUserId]
         * @param {number} [offset] Default is 0
         * @param {number} [limit] default is 500, max is 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayouts(dateFrom, dateTo, statuses, currencies, payoutTypes, mandateId, senderAccountId, recipientAccountId, recipientUserId, recipientExternalUserId, offset, limit, options) {
            return localVarFp
                .listPayouts(dateFrom, dateTo, statuses, currencies, payoutTypes, mandateId, senderAccountId, recipientAccountId, recipientUserId, recipientExternalUserId, offset, limit, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Refresh payment attempt from payment link front-end
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshPaymentAttempt(options) {
            return localVarFp.refreshPaymentAttempt(options).then((request) => request(axios, basePath));
        },
        /**
         * Set autopay consent for payment user
         * @param {SetAutopayConsentRequest} setAutopayConsentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAutopayConsent(setAutopayConsentRequest, options) {
            return localVarFp
                .setAutopayConsent(setAutopayConsentRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Update a payment user
         * @param {string} paymentUserId
         * @param {UpdatePaymentUserRequest} updatePaymentUserRequest request body for updating payment user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentUser(paymentUserId, updatePaymentUserRequest, options) {
            return localVarFp
                .updatePaymentUser(paymentUserId, updatePaymentUserRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.DefaultApiFactory = DefaultApiFactory;
/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
class DefaultApi extends base_1.BaseAPI {
    /**
     * Cancel a payment link
     * @param {string} paymentLinkId The payment link id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    cancelPaymentLink(paymentLinkId, options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .cancelPaymentLink(paymentLinkId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Cancel Payout by payout_id
     * @param {string} payoutId payout id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    cancelPayout(payoutId, options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .cancelPayout(payoutId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Initiate change payment method from payment link front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    changePaymentMethodPaymentLink(options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .changePaymentMethodPaymentLink(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Submit manual payment confirmation
     * @param {ManualPaymentConfirmationRequest} manualPaymentIdentifiers Request body containing information to identify manual payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    confirmManualPayment(manualPaymentIdentifiers, options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .confirmManualPayment(manualPaymentIdentifiers, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Confirm a payment against a payment Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    confirmPayment(options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .confirmPayment(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create token for fps flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createFpsToken(options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .createFpsToken(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create mandate for an existing sender account
     * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {CreateMandateWithSenderAccountRequest} createMandateRequest request body for creating mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createMandateForExistingSender(idempotencyKey, createMandateRequest, options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .createMandateForExistingSender(idempotencyKey, createMandateRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create payment link
     * @param {CreatePaymentLinkRequest} createPaymentLinkRequest Parameters required to create a payment link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createPaymentLink(createPaymentLinkRequest, options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .createPaymentLink(createPaymentLinkRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Initiate Card Payment for a Payment Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createPaymentLinkCardPayment(options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .createPaymentLinkCardPayment(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * CREATE Mandate for payment link
     * @param {CreatePaymentLinkMandateRequest} createPaymentLinkMandateRequest request body for creating mandate for payment-link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createPaymentLinkMandate(createPaymentLinkMandateRequest, options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .createPaymentLinkMandate(createPaymentLinkMandateRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a Payment Method for a user
     * @param {string} paymentUserId Payment User ID
     * @param {CreatePaymentMethodRequest} createPaymentMethodRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createPaymentMethod(paymentUserId, createPaymentMethodRequest, options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .createPaymentMethod(paymentUserId, createPaymentMethodRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a scheduled payout
     * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {CreateScheduledPayoutRequest} createScheduledPayoutRequest Request body containing information to create scheduled payout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createScheduledPayout(idempotencyKey, createScheduledPayoutRequest, options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .createScheduledPayout(idempotencyKey, createScheduledPayoutRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Demote payment attempt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    demotePaymentAttempt(options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .demotePaymentAttempt(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Download the balance statement for the ledger (CSV)
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<string>} [currencies] The currencies to filter for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadBalanceStatement(dateFrom, dateTo, currencies, options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .downloadBalanceStatement(dateFrom, dateTo, currencies, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the FPS QR code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getFpsQrCode(options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .getFpsQrCode(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a customer-specific list of institutions for Finverse Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getInstitutionsForCustomer(options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .getInstitutionsForCustomer(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get payment link
     * @param {string} paymentLinkId The payment link id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getPaymentLink(paymentLinkId, options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .getPaymentLink(paymentLinkId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a payment method
     * @param {string} paymentMethodId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getPaymentMethod(paymentMethodId, options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .getPaymentMethod(paymentMethodId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get payment method in payment link flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getPaymentMethodPaymentLink(options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .getPaymentMethodPaymentLink(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get payment (if exists) on the payment link for front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getPaymentPaymentLink(options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .getPaymentPaymentLink(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get payout by payout_id
     * @param {string} payoutId payout id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getPayoutById(payoutId, options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .getPayoutById(payoutId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get sender payment user in payment link flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getSenderPaymentUser(options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .getSenderPaymentUser(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * List mandates details
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListDetokenizedMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
     * @param {ListDetokenizedMandatesSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listDetokenizedMandates(dateFrom, dateTo, statuses, senderType, userId, institutionId, offset, limit, options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .listDetokenizedMandates(dateFrom, dateTo, statuses, senderType, userId, institutionId, offset, limit, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * List Disputes
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListDisputesStatusesEnum>} [statuses] The dispute statuses to filter for, comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listDisputes(dateFrom, dateTo, statuses, options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .listDisputes(dateFrom, dateTo, statuses, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * List mandates
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
     * @param {ListMandatesSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listMandates(dateFrom, dateTo, statuses, senderType, userId, institutionId, offset, limit, options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .listMandates(dateFrom, dateTo, statuses, senderType, userId, institutionId, offset, limit, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * List Payment Methods for a User
     * @param {string} paymentUserId Payment User Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listPaymentMethods(paymentUserId, options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .listPaymentMethods(paymentUserId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * List Payments
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListPaymentsStatusesEnum>} [statuses] The payment statuses to filter for, comma separated
     * @param {ListPaymentsSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {ListPaymentsPaymentTypeEnum} [paymentType] Deprecated - The type of payment
     * @param {Array<ListPaymentsPaymentTypesEnum>} [paymentTypes]
     * @param {string} [mandateId] The mandate the payment belongs to
     * @param {string} [currency] Deprecated - The currency the payment is made in
     * @param {Array<string>} [currencies]
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listPayments(dateFrom, dateTo, statuses, senderType, userId, institutionId, paymentType, paymentTypes, mandateId, currency, currencies, offset, limit, options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .listPayments(dateFrom, dateTo, statuses, senderType, userId, institutionId, paymentType, paymentTypes, mandateId, currency, currencies, offset, limit, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * List payouts
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListPayoutsStatusesEnum>} [statuses] The payout statuses to filter for, comma separated
     * @param {Array<string>} [currencies]
     * @param {Array<ListPayoutsPayoutTypesEnum>} [payoutTypes]
     * @param {string} [mandateId]
     * @param {string} [senderAccountId]
     * @param {string} [recipientAccountId]
     * @param {string} [recipientUserId]
     * @param {string} [recipientExternalUserId]
     * @param {number} [offset] Default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listPayouts(dateFrom, dateTo, statuses, currencies, payoutTypes, mandateId, senderAccountId, recipientAccountId, recipientUserId, recipientExternalUserId, offset, limit, options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .listPayouts(dateFrom, dateTo, statuses, currencies, payoutTypes, mandateId, senderAccountId, recipientAccountId, recipientUserId, recipientExternalUserId, offset, limit, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Refresh payment attempt from payment link front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    refreshPaymentAttempt(options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .refreshPaymentAttempt(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Set autopay consent for payment user
     * @param {SetAutopayConsentRequest} setAutopayConsentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    setAutopayConsent(setAutopayConsentRequest, options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .setAutopayConsent(setAutopayConsentRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a payment user
     * @param {string} paymentUserId
     * @param {UpdatePaymentUserRequest} updatePaymentUserRequest request body for updating payment user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    updatePaymentUser(paymentUserId, updatePaymentUserRequest, options) {
        return (0, exports.DefaultApiFp)(this.configuration)
            .updatePaymentUser(paymentUserId, updatePaymentUserRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.DefaultApi = DefaultApi;
/**
 * @export
 */
exports.ListDetokenizedMandatesStatusesEnum = {
    AuthorizationRequired: 'AUTHORIZATION_REQUIRED',
    Authorizing: 'AUTHORIZING',
    Processing: 'PROCESSING',
    Submitted: 'SUBMITTED',
    Succeeded: 'SUCCEEDED',
    Failed: 'FAILED',
    Revoked: 'REVOKED',
    ReadyToSubmit: 'READY_TO_SUBMIT',
    Closed: 'CLOSED',
    Cancelled: 'CANCELLED',
};
/**
 * @export
 */
exports.ListDetokenizedMandatesSenderTypeEnum = {
    Individual: 'INDIVIDUAL',
    Business: 'BUSINESS',
};
/**
 * @export
 */
exports.ListDisputesStatusesEnum = {
    Unknown: 'UNKNOWN',
    Undefended: 'UNDEFENDED',
    ActionRequired: 'ACTION_REQUIRED',
    Processing: 'PROCESSING',
    Accepted: 'ACCEPTED',
    Lost: 'LOST',
    Won: 'WON',
};
/**
 * @export
 */
exports.ListMandatesStatusesEnum = {
    AuthorizationRequired: 'AUTHORIZATION_REQUIRED',
    Authorizing: 'AUTHORIZING',
    Processing: 'PROCESSING',
    Submitted: 'SUBMITTED',
    Succeeded: 'SUCCEEDED',
    Failed: 'FAILED',
    Revoked: 'REVOKED',
    ReadyToSubmit: 'READY_TO_SUBMIT',
    Closed: 'CLOSED',
    Cancelled: 'CANCELLED',
};
/**
 * @export
 */
exports.ListMandatesSenderTypeEnum = {
    Individual: 'INDIVIDUAL',
    Business: 'BUSINESS',
};
/**
 * @export
 */
exports.ListPaymentsStatusesEnum = {
    AuthorizationRequired: 'AUTHORIZATION_REQUIRED',
    Authorizing: 'AUTHORIZING',
    Processing: 'PROCESSING',
    Submitted: 'SUBMITTED',
    Executed: 'EXECUTED',
    Failed: 'FAILED',
    Revoked: 'REVOKED',
    Cancelled: 'CANCELLED',
    Created: 'CREATED',
};
/**
 * @export
 */
exports.ListPaymentsSenderTypeEnum = {
    Individual: 'INDIVIDUAL',
    Business: 'BUSINESS',
};
/**
 * @export
 */
exports.ListPaymentsPaymentTypeEnum = {
    Mandate: 'MANDATE',
    Single: 'SINGLE',
    Card: 'CARD',
    Manual: 'MANUAL',
};
/**
 * @export
 */
exports.ListPaymentsPaymentTypesEnum = {
    Mandate: 'MANDATE',
    Single: 'SINGLE',
    Card: 'CARD',
    Manual: 'MANUAL',
};
/**
 * @export
 */
exports.ListPayoutsStatusesEnum = {
    Executed: 'EXECUTED',
    Created: 'CREATED',
    Processing: 'PROCESSING',
    ProcessingFunds: 'PROCESSING_FUNDS',
    Cancelled: 'CANCELLED',
    Failed: 'FAILED',
    Funded: 'FUNDED',
    Submitted: 'SUBMITTED',
};
/**
 * @export
 */
exports.ListPayoutsPayoutTypesEnum = {
    Manual: 'MANUAL',
    Scheduled: 'SCHEDULED',
};
/**
 * LinkApi - axios parameter creator
 * @export
 */
const LinkApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a new link and submit credentials
         * @param {ApiLinkRequest} apiLinkRequest Request body for creating a new link and submitting credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLink: (apiLinkRequest_1, ...args_1) => __awaiter(this, [apiLinkRequest_1, ...args_1], void 0, function* (apiLinkRequest, options = {}) {
            // verify required parameter 'apiLinkRequest' is not null or undefined
            (0, common_1.assertParamExists)('createLink', 'apiLinkRequest', apiLinkRequest);
            const localVarPath = `/link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(apiLinkRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new link
         * @param {LinkRequest} linkRequest Request body for starting a new Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLinkWoauth: (linkRequest_1, ...args_1) => __awaiter(this, [linkRequest_1, ...args_1], void 0, function* (linkRequest, options = {}) {
            // verify required parameter 'linkRequest' is not null or undefined
            (0, common_1.assertParamExists)('createLinkWoauth', 'linkRequest', linkRequest);
            const localVarPath = `/link/woauth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', ['link'], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(linkRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Post the user action value
         * @param {string} loginIdentityId The login identity id
         * @param {ActionRequest} actionRequest Request body for post link action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkAction: (loginIdentityId_1, actionRequest_1, ...args_1) => __awaiter(this, [loginIdentityId_1, actionRequest_1, ...args_1], void 0, function* (loginIdentityId, actionRequest, options = {}) {
            // verify required parameter 'loginIdentityId' is not null or undefined
            (0, common_1.assertParamExists)('linkAction', 'loginIdentityId', loginIdentityId);
            // verify required parameter 'actionRequest' is not null or undefined
            (0, common_1.assertParamExists)('linkAction', 'actionRequest', actionRequest);
            const localVarPath = `/link/action/{loginIdentityId}`.replace(`{${'loginIdentityId'}}`, encodeURIComponent(String(loginIdentityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(actionRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check the status of a given loginIdentity
         * @param {string} loginIdentityId The login identity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkStatus: (loginIdentityId_1, ...args_1) => __awaiter(this, [loginIdentityId_1, ...args_1], void 0, function* (loginIdentityId, options = {}) {
            // verify required parameter 'loginIdentityId' is not null or undefined
            (0, common_1.assertParamExists)('linkStatus', 'loginIdentityId', loginIdentityId);
            const localVarPath = `/link/status/{loginIdentityId}`.replace(`{${'loginIdentityId'}}`, encodeURIComponent(String(loginIdentityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check the status of a given login identity via FVLink
         * @param {string} loginIdentityId The login identity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkStatusNonSensitive: (loginIdentityId_1, ...args_1) => __awaiter(this, [loginIdentityId_1, ...args_1], void 0, function* (loginIdentityId, options = {}) {
            // verify required parameter 'loginIdentityId' is not null or undefined
            (0, common_1.assertParamExists)('linkStatusNonSensitive', 'loginIdentityId', loginIdentityId);
            const localVarPath = `/link/fvlink/status/{loginIdentityId}`.replace(`{${'loginIdentityId'}}`, encodeURIComponent(String(loginIdentityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update an existing link
         * @param {RelinkRequest} relinkRequest Request body for updating Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relink: (relinkRequest_1, ...args_1) => __awaiter(this, [relinkRequest_1, ...args_1], void 0, function* (relinkRequest, options = {}) {
            // verify required parameter 'relinkRequest' is not null or undefined
            (0, common_1.assertParamExists)('relink', 'relinkRequest', relinkRequest);
            const localVarPath = `/link/relink`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(relinkRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new link using an existing LIID
         * @param {string} loginIdentityId The login identity id
         * @param {ApiRelinkRequest} apiRelinkRequest Request body for relinking and submitting credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relinkV2: (loginIdentityId_1, apiRelinkRequest_1, ...args_1) => __awaiter(this, [loginIdentityId_1, apiRelinkRequest_1, ...args_1], void 0, function* (loginIdentityId, apiRelinkRequest, options = {}) {
            // verify required parameter 'loginIdentityId' is not null or undefined
            (0, common_1.assertParamExists)('relinkV2', 'loginIdentityId', loginIdentityId);
            // verify required parameter 'apiRelinkRequest' is not null or undefined
            (0, common_1.assertParamExists)('relinkV2', 'apiRelinkRequest', apiRelinkRequest);
            const localVarPath = `/link/relink/{loginIdentityId}`.replace(`{${'loginIdentityId'}}`, encodeURIComponent(String(loginIdentityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(apiRelinkRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Exchange authorization code for token
         * @param {TokenGrantTypeEnum} grantType
         * @param {string} code
         * @param {string} clientId
         * @param {string} redirectUri
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        token: (grantType_1, code_1, clientId_1, redirectUri_1, ...args_1) => __awaiter(this, [grantType_1, code_1, clientId_1, redirectUri_1, ...args_1], void 0, function* (grantType, code, clientId, redirectUri, options = {}) {
            // verify required parameter 'grantType' is not null or undefined
            (0, common_1.assertParamExists)('token', 'grantType', grantType);
            // verify required parameter 'code' is not null or undefined
            (0, common_1.assertParamExists)('token', 'code', code);
            // verify required parameter 'clientId' is not null or undefined
            (0, common_1.assertParamExists)('token', 'clientId', clientId);
            // verify required parameter 'redirectUri' is not null or undefined
            (0, common_1.assertParamExists)('token', 'redirectUri', redirectUri);
            const localVarPath = `/auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new URLSearchParams();
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            if (grantType !== undefined) {
                localVarFormParams.set('grant_type', grantType);
            }
            if (code !== undefined) {
                localVarFormParams.set('code', code);
            }
            if (clientId !== undefined) {
                localVarFormParams.set('client_id', clientId);
            }
            if (redirectUri !== undefined) {
                localVarFormParams.set('redirect_uri', redirectUri);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.LinkApiAxiosParamCreator = LinkApiAxiosParamCreator;
/**
 * LinkApi - functional programming interface
 * @export
 */
const LinkApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.LinkApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a new link and submit credentials
         * @param {ApiLinkRequest} apiLinkRequest Request body for creating a new link and submitting credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLink(apiLinkRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createLink(apiLinkRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LinkApi.createLink']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new link
         * @param {LinkRequest} linkRequest Request body for starting a new Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLinkWoauth(linkRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createLinkWoauth(linkRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LinkApi.createLinkWoauth']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Post the user action value
         * @param {string} loginIdentityId The login identity id
         * @param {ActionRequest} actionRequest Request body for post link action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkAction(loginIdentityId, actionRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.linkAction(loginIdentityId, actionRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LinkApi.linkAction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Check the status of a given loginIdentity
         * @param {string} loginIdentityId The login identity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkStatus(loginIdentityId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.linkStatus(loginIdentityId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LinkApi.linkStatus']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Check the status of a given login identity via FVLink
         * @param {string} loginIdentityId The login identity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkStatusNonSensitive(loginIdentityId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.linkStatusNonSensitive(loginIdentityId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LinkApi.linkStatusNonSensitive']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update an existing link
         * @param {RelinkRequest} relinkRequest Request body for updating Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relink(relinkRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.relink(relinkRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LinkApi.relink']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create a new link using an existing LIID
         * @param {string} loginIdentityId The login identity id
         * @param {ApiRelinkRequest} apiRelinkRequest Request body for relinking and submitting credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relinkV2(loginIdentityId, apiRelinkRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.relinkV2(loginIdentityId, apiRelinkRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LinkApi.relinkV2']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Exchange authorization code for token
         * @param {TokenGrantTypeEnum} grantType
         * @param {string} code
         * @param {string} clientId
         * @param {string} redirectUri
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        token(grantType, code, clientId, redirectUri, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.token(grantType, code, clientId, redirectUri, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LinkApi.token']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.LinkApiFp = LinkApiFp;
/**
 * LinkApi - factory interface
 * @export
 */
const LinkApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.LinkApiFp)(configuration);
    return {
        /**
         * Create a new link and submit credentials
         * @param {ApiLinkRequest} apiLinkRequest Request body for creating a new link and submitting credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLink(apiLinkRequest, options) {
            return localVarFp.createLink(apiLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new link
         * @param {LinkRequest} linkRequest Request body for starting a new Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLinkWoauth(linkRequest, options) {
            return localVarFp.createLinkWoauth(linkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Post the user action value
         * @param {string} loginIdentityId The login identity id
         * @param {ActionRequest} actionRequest Request body for post link action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkAction(loginIdentityId, actionRequest, options) {
            return localVarFp.linkAction(loginIdentityId, actionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Check the status of a given loginIdentity
         * @param {string} loginIdentityId The login identity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkStatus(loginIdentityId, options) {
            return localVarFp.linkStatus(loginIdentityId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check the status of a given login identity via FVLink
         * @param {string} loginIdentityId The login identity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkStatusNonSensitive(loginIdentityId, options) {
            return localVarFp.linkStatusNonSensitive(loginIdentityId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing link
         * @param {RelinkRequest} relinkRequest Request body for updating Link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relink(relinkRequest, options) {
            return localVarFp.relink(relinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new link using an existing LIID
         * @param {string} loginIdentityId The login identity id
         * @param {ApiRelinkRequest} apiRelinkRequest Request body for relinking and submitting credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relinkV2(loginIdentityId, apiRelinkRequest, options) {
            return localVarFp
                .relinkV2(loginIdentityId, apiRelinkRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Exchange authorization code for token
         * @param {TokenGrantTypeEnum} grantType
         * @param {string} code
         * @param {string} clientId
         * @param {string} redirectUri
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        token(grantType, code, clientId, redirectUri, options) {
            return localVarFp
                .token(grantType, code, clientId, redirectUri, options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.LinkApiFactory = LinkApiFactory;
/**
 * LinkApi - object-oriented interface
 * @export
 * @class LinkApi
 * @extends {BaseAPI}
 */
class LinkApi extends base_1.BaseAPI {
    /**
     * Create a new link and submit credentials
     * @param {ApiLinkRequest} apiLinkRequest Request body for creating a new link and submitting credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApi
     */
    createLink(apiLinkRequest, options) {
        return (0, exports.LinkApiFp)(this.configuration)
            .createLink(apiLinkRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new link
     * @param {LinkRequest} linkRequest Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApi
     */
    createLinkWoauth(linkRequest, options) {
        return (0, exports.LinkApiFp)(this.configuration)
            .createLinkWoauth(linkRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Post the user action value
     * @param {string} loginIdentityId The login identity id
     * @param {ActionRequest} actionRequest Request body for post link action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApi
     */
    linkAction(loginIdentityId, actionRequest, options) {
        return (0, exports.LinkApiFp)(this.configuration)
            .linkAction(loginIdentityId, actionRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check the status of a given loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApi
     */
    linkStatus(loginIdentityId, options) {
        return (0, exports.LinkApiFp)(this.configuration)
            .linkStatus(loginIdentityId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check the status of a given login identity via FVLink
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApi
     */
    linkStatusNonSensitive(loginIdentityId, options) {
        return (0, exports.LinkApiFp)(this.configuration)
            .linkStatusNonSensitive(loginIdentityId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update an existing link
     * @param {RelinkRequest} relinkRequest Request body for updating Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApi
     */
    relink(relinkRequest, options) {
        return (0, exports.LinkApiFp)(this.configuration)
            .relink(relinkRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new link using an existing LIID
     * @param {string} loginIdentityId The login identity id
     * @param {ApiRelinkRequest} apiRelinkRequest Request body for relinking and submitting credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApi
     */
    relinkV2(loginIdentityId, apiRelinkRequest, options) {
        return (0, exports.LinkApiFp)(this.configuration)
            .relinkV2(loginIdentityId, apiRelinkRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Exchange authorization code for token
     * @param {TokenGrantTypeEnum} grantType
     * @param {string} code
     * @param {string} clientId
     * @param {string} redirectUri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApi
     */
    token(grantType, code, clientId, redirectUri, options) {
        return (0, exports.LinkApiFp)(this.configuration)
            .token(grantType, code, clientId, redirectUri, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.LinkApi = LinkApi;
/**
 * @export
 */
exports.TokenGrantTypeEnum = {
    AuthorizationCode: 'authorization_code',
};
/**
 * LoginIdentityApi - axios parameter creator
 * @export
 */
const LoginIdentityApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete a specific loginIdentity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLoginIdentity: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/login_identity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * generate a link token that can be used to create link
         * @param {LinkTokenRequest} linkTokenRequest token request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateLinkToken: (linkTokenRequest_1, ...args_1) => __awaiter(this, [linkTokenRequest_1, ...args_1], void 0, function* (linkTokenRequest, options = {}) {
            // verify required parameter 'linkTokenRequest' is not null or undefined
            (0, common_1.assertParamExists)('generateLinkToken', 'linkTokenRequest', linkTokenRequest);
            const localVarPath = `/link/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(linkTokenRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific account\'s information
         * @param {string} accountId The account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: (accountId_1, ...args_1) => __awaiter(this, [accountId_1, ...args_1], void 0, function* (accountId, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getAccount', 'accountId', accountId);
            const localVarPath = `/accounts/{accountId}`.replace(`{${'accountId'}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', ['account'], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get the account number for a specific account
         * @param {string} accountId The account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountNumber: (accountId_1, ...args_1) => __awaiter(this, [accountId_1, ...args_1], void 0, function* (accountId, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getAccountNumber', 'accountId', accountId);
            const localVarPath = `/account_numbers/{accountId}`.replace(`{${'accountId'}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get the balance history for a specific account
         * @param {string} accountId The account id
         * @param {GetBalanceHistorySourceEnum} [source] The source will determine what type of balance history will be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceHistory: (accountId_1, source_1, ...args_1) => __awaiter(this, [accountId_1, source_1, ...args_1], void 0, function* (accountId, source, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getBalanceHistory', 'accountId', accountId);
            const localVarPath = `/balance_history/{accountId}`.replace(`{${'accountId'}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Download composite statement
         * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompositeStatement: (redirect_1, ...args_1) => __awaiter(this, [redirect_1, ...args_1], void 0, function* (redirect, options = {}) {
            const localVarPath = `/composite_statement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            if (redirect !== undefined) {
                localVarQueryParameter['redirect'] = redirect;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * \\[BETA] Get a list of identity data for a given login identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentity: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/identity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get income figures for a login identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeEstimateByLoginIdentityId: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/income`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a specific loginIdentity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginIdentity: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/login_identity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Download statement
         * @param {string} statementId The statement id
         * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatement: (statementId_1, redirect_1, ...args_1) => __awaiter(this, [statementId_1, redirect_1, ...args_1], void 0, function* (statementId, redirect, options = {}) {
            // verify required parameter 'statementId' is not null or undefined
            (0, common_1.assertParamExists)('getStatement', 'statementId', statementId);
            const localVarPath = `/statements/{statementId}`.replace(`{${'statementId'}}`, encodeURIComponent(String(statementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            if (redirect !== undefined) {
                localVarQueryParameter['redirect'] = redirect;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get list of available statements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatements: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/statements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a list of accounts for a login identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', ['account'], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a list of card details for a login identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCardDetails: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/card_details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
         * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
         * @param {number} [offset] default is 0
         * @param {number} [limit] default is 500, max is 1000
         * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsByAccountId: (accountId_1, offset_1, limit_1, enrichments_1, ...args_1) => __awaiter(this, [accountId_1, offset_1, limit_1, enrichments_1, ...args_1], void 0, function* (accountId, offset, limit, enrichments, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('listTransactionsByAccountId', 'accountId', accountId);
            const localVarPath = `/transactions/{accountId}`.replace(`{${'accountId'}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', ['transaction'], configuration);
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (enrichments !== undefined) {
                localVarQueryParameter['enrichments'] = enrichments;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
         * @param {number} [offset] default is 0
         * @param {number} [limit] default is 500, max is 1000
         * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsByLoginIdentityId: (offset_1, limit_1, enrichments_1, ...args_1) => __awaiter(this, [offset_1, limit_1, enrichments_1, ...args_1], void 0, function* (offset, limit, enrichments, options = {}) {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', ['transaction'], configuration);
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (enrichments !== undefined) {
                localVarQueryParameter['enrichments'] = enrichments;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a refresh job for a login identity
         * @param {RefreshLoginIdentityRequest} [refreshLoginIdentityReq]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshLoginIdentity: (refreshLoginIdentityReq_1, ...args_1) => __awaiter(this, [refreshLoginIdentityReq_1, ...args_1], void 0, function* (refreshLoginIdentityReq, options = {}) {
            const localVarPath = `/login_identity/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, 'Oauth2', [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(refreshLoginIdentityReq, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.LoginIdentityApiAxiosParamCreator = LoginIdentityApiAxiosParamCreator;
/**
 * LoginIdentityApi - functional programming interface
 * @export
 */
const LoginIdentityApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.LoginIdentityApiAxiosParamCreator)(configuration);
    return {
        /**
         * Delete a specific loginIdentity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLoginIdentity(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteLoginIdentity(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LoginIdentityApi.deleteLoginIdentity']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * generate a link token that can be used to create link
         * @param {LinkTokenRequest} linkTokenRequest token request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateLinkToken(linkTokenRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.generateLinkToken(linkTokenRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LoginIdentityApi.generateLinkToken']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a specific account\'s information
         * @param {string} accountId The account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(accountId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAccount(accountId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LoginIdentityApi.getAccount']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get the account number for a specific account
         * @param {string} accountId The account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountNumber(accountId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAccountNumber(accountId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LoginIdentityApi.getAccountNumber']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get the balance history for a specific account
         * @param {string} accountId The account id
         * @param {GetBalanceHistorySourceEnum} [source] The source will determine what type of balance history will be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceHistory(accountId, source, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBalanceHistory(accountId, source, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LoginIdentityApi.getBalanceHistory']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Download composite statement
         * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompositeStatement(redirect, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCompositeStatement(redirect, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LoginIdentityApi.getCompositeStatement']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * \\[BETA] Get a list of identity data for a given login identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentity(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getIdentity(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LoginIdentityApi.getIdentity']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get income figures for a login identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeEstimateByLoginIdentityId(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getIncomeEstimateByLoginIdentityId(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LoginIdentityApi.getIncomeEstimateByLoginIdentityId']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a specific loginIdentity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginIdentity(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getLoginIdentity(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LoginIdentityApi.getLoginIdentity']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Download statement
         * @param {string} statementId The statement id
         * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatement(statementId, redirect, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getStatement(statementId, redirect, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LoginIdentityApi.getStatement']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get list of available statements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatements(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getStatements(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LoginIdentityApi.getStatements']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a list of accounts for a login identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listAccounts(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LoginIdentityApi.listAccounts']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a list of card details for a login identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCardDetails(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listCardDetails(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LoginIdentityApi.listCardDetails']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
         * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
         * @param {number} [offset] default is 0
         * @param {number} [limit] default is 500, max is 1000
         * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsByAccountId(accountId, offset, limit, enrichments, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTransactionsByAccountId(accountId, offset, limit, enrichments, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LoginIdentityApi.listTransactionsByAccountId']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
         * @param {number} [offset] default is 0
         * @param {number} [limit] default is 500, max is 1000
         * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsByLoginIdentityId(offset, limit, enrichments, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTransactionsByLoginIdentityId(offset, limit, enrichments, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LoginIdentityApi.listTransactionsByLoginIdentityId']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create a refresh job for a login identity
         * @param {RefreshLoginIdentityRequest} [refreshLoginIdentityReq]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshLoginIdentity(refreshLoginIdentityReq, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.refreshLoginIdentity(refreshLoginIdentityReq, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LoginIdentityApi.refreshLoginIdentity']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.LoginIdentityApiFp = LoginIdentityApiFp;
/**
 * LoginIdentityApi - factory interface
 * @export
 */
const LoginIdentityApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.LoginIdentityApiFp)(configuration);
    return {
        /**
         * Delete a specific loginIdentity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLoginIdentity(options) {
            return localVarFp.deleteLoginIdentity(options).then((request) => request(axios, basePath));
        },
        /**
         * generate a link token that can be used to create link
         * @param {LinkTokenRequest} linkTokenRequest token request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateLinkToken(linkTokenRequest, options) {
            return localVarFp.generateLinkToken(linkTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific account\'s information
         * @param {string} accountId The account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(accountId, options) {
            return localVarFp.getAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the account number for a specific account
         * @param {string} accountId The account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountNumber(accountId, options) {
            return localVarFp.getAccountNumber(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the balance history for a specific account
         * @param {string} accountId The account id
         * @param {GetBalanceHistorySourceEnum} [source] The source will determine what type of balance history will be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceHistory(accountId, source, options) {
            return localVarFp.getBalanceHistory(accountId, source, options).then((request) => request(axios, basePath));
        },
        /**
         * Download composite statement
         * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompositeStatement(redirect, options) {
            return localVarFp.getCompositeStatement(redirect, options).then((request) => request(axios, basePath));
        },
        /**
         * \\[BETA] Get a list of identity data for a given login identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentity(options) {
            return localVarFp.getIdentity(options).then((request) => request(axios, basePath));
        },
        /**
         * Get income figures for a login identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeEstimateByLoginIdentityId(options) {
            return localVarFp.getIncomeEstimateByLoginIdentityId(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific loginIdentity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginIdentity(options) {
            return localVarFp.getLoginIdentity(options).then((request) => request(axios, basePath));
        },
        /**
         * Download statement
         * @param {string} statementId The statement id
         * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatement(statementId, redirect, options) {
            return localVarFp.getStatement(statementId, redirect, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of available statements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatements(options) {
            return localVarFp.getStatements(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of accounts for a login identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts(options) {
            return localVarFp.listAccounts(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of card details for a login identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCardDetails(options) {
            return localVarFp.listCardDetails(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
         * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
         * @param {number} [offset] default is 0
         * @param {number} [limit] default is 500, max is 1000
         * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsByAccountId(accountId, offset, limit, enrichments, options) {
            return localVarFp
                .listTransactionsByAccountId(accountId, offset, limit, enrichments, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
         * @param {number} [offset] default is 0
         * @param {number} [limit] default is 500, max is 1000
         * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsByLoginIdentityId(offset, limit, enrichments, options) {
            return localVarFp
                .listTransactionsByLoginIdentityId(offset, limit, enrichments, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Create a refresh job for a login identity
         * @param {RefreshLoginIdentityRequest} [refreshLoginIdentityReq]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshLoginIdentity(refreshLoginIdentityReq, options) {
            return localVarFp
                .refreshLoginIdentity(refreshLoginIdentityReq, options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.LoginIdentityApiFactory = LoginIdentityApiFactory;
/**
 * LoginIdentityApi - object-oriented interface
 * @export
 * @class LoginIdentityApi
 * @extends {BaseAPI}
 */
class LoginIdentityApi extends base_1.BaseAPI {
    /**
     * Delete a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    deleteLoginIdentity(options) {
        return (0, exports.LoginIdentityApiFp)(this.configuration)
            .deleteLoginIdentity(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    generateLinkToken(linkTokenRequest, options) {
        return (0, exports.LoginIdentityApiFp)(this.configuration)
            .generateLinkToken(linkTokenRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific account\'s information
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    getAccount(accountId, options) {
        return (0, exports.LoginIdentityApiFp)(this.configuration)
            .getAccount(accountId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the account number for a specific account
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    getAccountNumber(accountId, options) {
        return (0, exports.LoginIdentityApiFp)(this.configuration)
            .getAccountNumber(accountId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the balance history for a specific account
     * @param {string} accountId The account id
     * @param {GetBalanceHistorySourceEnum} [source] The source will determine what type of balance history will be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    getBalanceHistory(accountId, source, options) {
        return (0, exports.LoginIdentityApiFp)(this.configuration)
            .getBalanceHistory(accountId, source, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Download composite statement
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    getCompositeStatement(redirect, options) {
        return (0, exports.LoginIdentityApiFp)(this.configuration)
            .getCompositeStatement(redirect, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * \\[BETA] Get a list of identity data for a given login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    getIdentity(options) {
        return (0, exports.LoginIdentityApiFp)(this.configuration)
            .getIdentity(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get income figures for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    getIncomeEstimateByLoginIdentityId(options) {
        return (0, exports.LoginIdentityApiFp)(this.configuration)
            .getIncomeEstimateByLoginIdentityId(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    getLoginIdentity(options) {
        return (0, exports.LoginIdentityApiFp)(this.configuration)
            .getLoginIdentity(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Download statement
     * @param {string} statementId The statement id
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    getStatement(statementId, redirect, options) {
        return (0, exports.LoginIdentityApiFp)(this.configuration)
            .getStatement(statementId, redirect, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get list of available statements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    getStatements(options) {
        return (0, exports.LoginIdentityApiFp)(this.configuration)
            .getStatements(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a list of accounts for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    listAccounts(options) {
        return (0, exports.LoginIdentityApiFp)(this.configuration)
            .listAccounts(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a list of card details for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    listCardDetails(options) {
        return (0, exports.LoginIdentityApiFp)(this.configuration)
            .listCardDetails(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    listTransactionsByAccountId(accountId, offset, limit, enrichments, options) {
        return (0, exports.LoginIdentityApiFp)(this.configuration)
            .listTransactionsByAccountId(accountId, offset, limit, enrichments, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    listTransactionsByLoginIdentityId(offset, limit, enrichments, options) {
        return (0, exports.LoginIdentityApiFp)(this.configuration)
            .listTransactionsByLoginIdentityId(offset, limit, enrichments, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a refresh job for a login identity
     * @param {RefreshLoginIdentityRequest} [refreshLoginIdentityReq]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    refreshLoginIdentity(refreshLoginIdentityReq, options) {
        return (0, exports.LoginIdentityApiFp)(this.configuration)
            .refreshLoginIdentity(refreshLoginIdentityReq, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.LoginIdentityApi = LoginIdentityApi;
/**
 * @export
 */
exports.GetBalanceHistorySourceEnum = {
    Institution: 'INSTITUTION',
    Computed: 'COMPUTED',
};
/**
 * PublicApi - axios parameter creator
 * @export
 */
const PublicApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Callback url to get the oauth authorization token
         * @param {string} state The state of the client when oauth was initialized
         * @param {string} [code] The authorization code generated by the Oauth provider
         * @param {string} [error] error
         * @param {string} [errorDescription] error description
         * @param {string} [errorDetails] error details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCallback: (state_1, code_1, error_1, errorDescription_1, errorDetails_1, ...args_1) => __awaiter(this, [state_1, code_1, error_1, errorDescription_1, errorDetails_1, ...args_1], void 0, function* (state, code, error, errorDescription, errorDetails, options = {}) {
            // verify required parameter 'state' is not null or undefined
            (0, common_1.assertParamExists)('authCallback', 'state', state);
            const localVarPath = `/auth/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }
            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }
            if (error !== undefined) {
                localVarQueryParameter['error'] = error;
            }
            if (errorDescription !== undefined) {
                localVarQueryParameter['error_description'] = errorDescription;
            }
            if (errorDetails !== undefined) {
                localVarQueryParameter['error_details'] = errorDetails;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * generate an access_token
         * @param {TokenRequest} [tokenRequest] token request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCustomerAccessToken: (tokenRequest_1, ...args_1) => __awaiter(this, [tokenRequest_1, ...args_1], void 0, function* (tokenRequest, options = {}) {
            const localVarPath = `/auth/customer/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(tokenRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get jwks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredSubmitJwks: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/jwks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get payment jwks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsJwks: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/payments/jwks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.PublicApiAxiosParamCreator = PublicApiAxiosParamCreator;
/**
 * PublicApi - functional programming interface
 * @export
 */
const PublicApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PublicApiAxiosParamCreator)(configuration);
    return {
        /**
         * Callback url to get the oauth authorization token
         * @param {string} state The state of the client when oauth was initialized
         * @param {string} [code] The authorization code generated by the Oauth provider
         * @param {string} [error] error
         * @param {string} [errorDescription] error description
         * @param {string} [errorDetails] error details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCallback(state, code, error, errorDescription, errorDetails, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.authCallback(state, code, error, errorDescription, errorDetails, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PublicApi.authCallback']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * generate an access_token
         * @param {TokenRequest} [tokenRequest] token request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCustomerAccessToken(tokenRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.generateCustomerAccessToken(tokenRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PublicApi.generateCustomerAccessToken']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * get jwks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredSubmitJwks(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCredSubmitJwks(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PublicApi.getCredSubmitJwks']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * get payment jwks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsJwks(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPaymentsJwks(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PublicApi.getPaymentsJwks']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.PublicApiFp = PublicApiFp;
/**
 * PublicApi - factory interface
 * @export
 */
const PublicApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PublicApiFp)(configuration);
    return {
        /**
         * Callback url to get the oauth authorization token
         * @param {string} state The state of the client when oauth was initialized
         * @param {string} [code] The authorization code generated by the Oauth provider
         * @param {string} [error] error
         * @param {string} [errorDescription] error description
         * @param {string} [errorDetails] error details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCallback(state, code, error, errorDescription, errorDetails, options) {
            return localVarFp
                .authCallback(state, code, error, errorDescription, errorDetails, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * generate an access_token
         * @param {TokenRequest} [tokenRequest] token request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCustomerAccessToken(tokenRequest, options) {
            return localVarFp.generateCustomerAccessToken(tokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * get jwks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredSubmitJwks(options) {
            return localVarFp.getCredSubmitJwks(options).then((request) => request(axios, basePath));
        },
        /**
         * get payment jwks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsJwks(options) {
            return localVarFp.getPaymentsJwks(options).then((request) => request(axios, basePath));
        },
    };
};
exports.PublicApiFactory = PublicApiFactory;
/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
class PublicApi extends base_1.BaseAPI {
    /**
     * Callback url to get the oauth authorization token
     * @param {string} state The state of the client when oauth was initialized
     * @param {string} [code] The authorization code generated by the Oauth provider
     * @param {string} [error] error
     * @param {string} [errorDescription] error description
     * @param {string} [errorDetails] error details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    authCallback(state, code, error, errorDescription, errorDetails, options) {
        return (0, exports.PublicApiFp)(this.configuration)
            .authCallback(state, code, error, errorDescription, errorDetails, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * generate an access_token
     * @param {TokenRequest} [tokenRequest] token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    generateCustomerAccessToken(tokenRequest, options) {
        return (0, exports.PublicApiFp)(this.configuration)
            .generateCustomerAccessToken(tokenRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * get jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    getCredSubmitJwks(options) {
        return (0, exports.PublicApiFp)(this.configuration)
            .getCredSubmitJwks(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * get payment jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    getPaymentsJwks(options) {
        return (0, exports.PublicApiFp)(this.configuration)
            .getPaymentsJwks(options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.PublicApi = PublicApi;
