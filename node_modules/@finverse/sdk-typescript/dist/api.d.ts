/**
 * Finverse Public
 * Documentation of the early finverse services
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: info@finverse.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import type { RequestArgs } from './base';
import { BaseAPI } from './base';
/**
 *
 * @export
 * @interface AccessTokenResponse
 */
export interface AccessTokenResponse {
    /**
     *
     * @type {string}
     * @memberof AccessTokenResponse
     */
    access_token: string;
    /**
     *
     * @type {string}
     * @memberof AccessTokenResponse
     */
    login_identity_id: string;
    /**
     *
     * @type {string}
     * @memberof AccessTokenResponse
     */
    token_type: string;
    /**
     * seconds
     * @type {number}
     * @memberof AccessTokenResponse
     */
    expires_in: number;
    /**
     *
     * @type {string}
     * @memberof AccessTokenResponse
     */
    refresh_token: string;
    /**
     *
     * @type {string}
     * @memberof AccessTokenResponse
     */
    issued_at: string;
}
/**
 *
 * @export
 * @interface Account
 */
export interface Account {
    /**
     *
     * @type {string}
     * @memberof Account
     */
    account_id: string;
    /**
     * The SHA3-256 hash of the account number, salted with the loginIdentityId
     * @type {string}
     * @memberof Account
     */
    group_id: string;
    /**
     *
     * @type {string}
     * @memberof Account
     */
    account_holder_name?: string;
    /**
     *
     * @type {string}
     * @memberof Account
     */
    account_name: string;
    /**
     *
     * @type {string}
     * @memberof Account
     */
    account_nickname?: string;
    /**
     *
     * @type {string}
     * @memberof Account
     */
    account_sub_type?: string;
    /**
     *
     * @type {string}
     * @memberof Account
     */
    account_number_masked?: string;
    /**
     *
     * @type {string}
     * @memberof Account
     */
    country?: string;
    /**
     *
     * @type {string}
     * @memberof Account
     */
    created_at?: string;
    /**
     *
     * @type {string}
     * @memberof Account
     */
    updated_at?: string;
    /**
     *
     * @type {string}
     * @memberof Account
     */
    account_currency?: string;
    /**
     *
     * @type {CurrencyAmount}
     * @memberof Account
     */
    balance?: CurrencyAmount;
    /**
     *
     * @type {CurrencyAmount}
     * @memberof Account
     */
    statement_balance?: CurrencyAmount;
    /**
     *
     * @type {boolean}
     * @memberof Account
     */
    is_parent: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Account
     */
    is_closed: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Account
     */
    is_excluded: boolean;
    /**
     *
     * @type {AccountType}
     * @memberof Account
     */
    account_type?: AccountType;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof Account
     */
    metadata: {
        [key: string]: string;
    };
}
/**
 *
 * @export
 * @interface AccountNumber
 */
export interface AccountNumber {
    /**
     *
     * @type {string}
     * @memberof AccountNumber
     */
    account_id: string;
    /**
     *
     * @type {string}
     * @memberof AccountNumber
     */
    number?: string;
    /**
     *
     * @type {string}
     * @memberof AccountNumber
     */
    raw: string;
}
/**
 *
 * @export
 * @interface AccountType
 */
export interface AccountType {
    /**
     *
     * @type {string}
     * @memberof AccountType
     */
    type?: AccountTypeTypeEnum;
    /**
     *
     * @type {string}
     * @memberof AccountType
     */
    subtype?: AccountTypeSubtypeEnum;
}
export declare const AccountTypeTypeEnum: {
    readonly Deposit: "DEPOSIT";
    readonly Card: "CARD";
    readonly Investment: "INVESTMENT";
    readonly Loan: "LOAN";
    readonly Unknown: "UNKNOWN";
};
export type AccountTypeTypeEnum = (typeof AccountTypeTypeEnum)[keyof typeof AccountTypeTypeEnum];
export declare const AccountTypeSubtypeEnum: {
    readonly Current: "CURRENT";
    readonly Savings: "SAVINGS";
    readonly TimeDeposit: "TIME_DEPOSIT";
    readonly Other: "OTHER";
    readonly CreditCard: "CREDIT_CARD";
    readonly DebitCard: "DEBIT_CARD";
    readonly Securities: "SECURITIES";
    readonly Funds: "FUNDS";
    readonly Stocks: "STOCKS";
    readonly Bonds: "BONDS";
    readonly Mortgage: "MORTGAGE";
    readonly PersonalLoan: "PERSONAL_LOAN";
    readonly RevolvingLoan: "REVOLVING_LOAN";
    readonly Unknown: "UNKNOWN";
};
export type AccountTypeSubtypeEnum = (typeof AccountTypeSubtypeEnum)[keyof typeof AccountTypeSubtypeEnum];
/**
 *
 * @export
 * @interface ActionRequest
 */
export interface ActionRequest {
    /**
     *
     * @type {EncryptedPayload}
     * @memberof ActionRequest
     */
    encrypted_credentials: EncryptedPayload;
    /**
     * The action id
     * @type {string}
     * @memberof ActionRequest
     */
    action_id: string;
}
/**
 *
 * @export
 * @interface AllProductStatus
 */
export interface AllProductStatus {
    /**
     *
     * @type {ProductStatus}
     * @memberof AllProductStatus
     */
    accounts?: ProductStatus;
    /**
     *
     * @type {ProductStatus}
     * @memberof AllProductStatus
     */
    online_transactions?: ProductStatus;
    /**
     *
     * @type {ProductStatus}
     * @memberof AllProductStatus
     */
    statements?: ProductStatus;
    /**
     *
     * @type {ProductStatus}
     * @memberof AllProductStatus
     */
    historical_transactions?: ProductStatus;
    /**
     *
     * @type {ProductStatus}
     * @memberof AllProductStatus
     */
    account_numbers?: ProductStatus;
    /**
     *
     * @type {ProductStatus}
     * @memberof AllProductStatus
     */
    identity?: ProductStatus;
    /**
     *
     * @type {ProductStatus}
     * @memberof AllProductStatus
     */
    balance_history?: ProductStatus;
    /**
     *
     * @type {ProductStatus}
     * @memberof AllProductStatus
     */
    payments?: ProductStatus;
    /**
     *
     * @type {ProductStatus}
     * @memberof AllProductStatus
     */
    income_estimation?: ProductStatus;
    /**
     *
     * @type {ProductStatus}
     * @memberof AllProductStatus
     */
    card_details?: ProductStatus;
}
/**
 *
 * @export
 * @interface ApiLinkRequest
 */
export interface ApiLinkRequest {
    /**
     *
     * @type {string}
     * @memberof ApiLinkRequest
     */
    institution_id: string;
    /**
     * Identifier for end user
     * @type {string}
     * @memberof ApiLinkRequest
     */
    user_id: string;
    /**
     * this is a mandatory field
     * @type {boolean}
     * @memberof ApiLinkRequest
     */
    consent: boolean | null;
    /**
     * products that are requested
     * @type {Array<string>}
     * @memberof ApiLinkRequest
     */
    products_requested: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof ApiLinkRequest
     */
    store_credentials: boolean;
    /**
     *
     * @type {EncryptedPayload}
     * @memberof ApiLinkRequest
     */
    encrypted_credentials: EncryptedPayload;
    /**
     *
     * @type {string}
     * @memberof ApiLinkRequest
     */
    payment_instruction_id?: string;
}
/**
 *
 * @export
 * @interface ApiRelinkRequest
 */
export interface ApiRelinkRequest {
    /**
     *
     * @type {boolean}
     * @memberof ApiRelinkRequest
     */
    store_credential?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof ApiRelinkRequest
     */
    consent: boolean;
    /**
     *
     * @type {EncryptedPayload}
     * @memberof ApiRelinkRequest
     */
    encrypted_credentials: EncryptedPayload;
}
/**
 *
 * @export
 * @interface AuthChecklistFactor
 */
export interface AuthChecklistFactor {
    /**
     * Type of authorization factor
     * @type {string}
     * @memberof AuthChecklistFactor
     */
    type: AuthChecklistFactorTypeEnum;
    /**
     * Allows grouping similar checklist item types together
     * @type {string}
     * @memberof AuthChecklistFactor
     */
    group_id: string;
    /**
     * Indicates whether authorization factor is known to be required at this time.  Possible values are YES, NO, OPTIONAL
     * @type {string}
     * @memberof AuthChecklistFactor
     */
    required: AuthChecklistFactorRequiredEnum;
    /**
     * Helper text that applies to a specific checklist item
     * @type {string}
     * @memberof AuthChecklistFactor
     */
    helper_text?: string;
    /**
     * Array of the options accepted for a specific authorization factor
     * @type {Array<AuthChecklistOptions>}
     * @memberof AuthChecklistFactor
     */
    options: Array<AuthChecklistOptions>;
}
export declare const AuthChecklistFactorTypeEnum: {
    readonly AccountIdentification: "ACCOUNT_IDENTIFICATION";
    readonly UserIdentification: "USER_IDENTIFICATION";
    readonly EnduserConsent: "ENDUSER_CONSENT";
    readonly AccountholderAuthentication: "ACCOUNTHOLDER_AUTHENTICATION";
};
export type AuthChecklistFactorTypeEnum = (typeof AuthChecklistFactorTypeEnum)[keyof typeof AuthChecklistFactorTypeEnum];
export declare const AuthChecklistFactorRequiredEnum: {
    readonly Yes: "YES";
    readonly No: "NO";
    readonly Optional: "OPTIONAL";
};
export type AuthChecklistFactorRequiredEnum = (typeof AuthChecklistFactorRequiredEnum)[keyof typeof AuthChecklistFactorRequiredEnum];
/**
 *
 * @export
 * @interface AuthChecklistOptions
 */
export interface AuthChecklistOptions {
    /**
     * Name of authorization factor. Possible values are INSTITUTION_CREDENTIALS_LOGIN, INSTITUTION_OAUTH_LOGIN,
     * @type {string}
     * @memberof AuthChecklistOptions
     */
    name: AuthChecklistOptionsNameEnum;
    /**
     * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ) for when the authorization factor was submitted to Finverse
     * @type {string}
     * @memberof AuthChecklistOptions
     */
    submitted_at?: string | null;
    /**
     * Indicates who submitted the authorization factor to Finverse. Possible values are CUSTOMER_APP, FINVERSE_LINK
     * @type {string}
     * @memberof AuthChecklistOptions
     */
    submitted_by?: AuthChecklistOptionsSubmittedByEnum;
    /**
     * Redirect to bank for authentication
     * @type {string}
     * @memberof AuthChecklistOptions
     */
    redirect_url?: string;
}
export declare const AuthChecklistOptionsNameEnum: {
    readonly InstitutionCredentialsLogin: "INSTITUTION_CREDENTIALS_LOGIN";
    readonly InstitutionOauthLogin: "INSTITUTION_OAUTH_LOGIN";
};
export type AuthChecklistOptionsNameEnum = (typeof AuthChecklistOptionsNameEnum)[keyof typeof AuthChecklistOptionsNameEnum];
export declare const AuthChecklistOptionsSubmittedByEnum: {
    readonly CustomerApp: "CUSTOMER_APP";
    readonly FinverseLink: "FINVERSE_LINK";
};
export type AuthChecklistOptionsSubmittedByEnum = (typeof AuthChecklistOptionsSubmittedByEnum)[keyof typeof AuthChecklistOptionsSubmittedByEnum];
/**
 *
 * @export
 * @interface AuthorizeMandateRequest
 */
export interface AuthorizeMandateRequest {
    /**
     * Whether a consent was provided by the enduser to authorize a mandate
     * @type {boolean}
     * @memberof AuthorizeMandateRequest
     */
    enduser_consent: boolean;
}
/**
 *
 * @export
 * @interface AutopayEnrollmentConfiguration
 */
export interface AutopayEnrollmentConfiguration {
    /**
     * Indicate whether the autopay enrollment screen should be prompted to the end user
     * @type {boolean}
     * @memberof AutopayEnrollmentConfiguration
     */
    display_enrollment_screen: boolean;
    /**
     * Indicate what value should be prefilled on the autopay enrollment screen
     * @type {string}
     * @memberof AutopayEnrollmentConfiguration
     */
    enrollment_prefill_value: AutopayEnrollmentConfigurationEnrollmentPrefillValueEnum;
}
export declare const AutopayEnrollmentConfigurationEnrollmentPrefillValueEnum: {
    readonly Yes: "YES";
    readonly No: "NO";
};
export type AutopayEnrollmentConfigurationEnrollmentPrefillValueEnum = (typeof AutopayEnrollmentConfigurationEnrollmentPrefillValueEnum)[keyof typeof AutopayEnrollmentConfigurationEnrollmentPrefillValueEnum];
/**
 *
 * @export
 * @interface BadRequestModel
 */
export interface BadRequestModel {
    /**
     *
     * @type {BadRequestModelError}
     * @memberof BadRequestModel
     */
    error?: BadRequestModelError;
}
/**
 *
 * @export
 * @interface BadRequestModelError
 */
export interface BadRequestModelError {
    /**
     *
     * @type {number}
     * @memberof BadRequestModelError
     */
    code?: number;
    /**
     *
     * @type {string}
     * @memberof BadRequestModelError
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof BadRequestModelError
     */
    message?: string;
    /**
     * A link to visit for further action
     * @type {string}
     * @memberof BadRequestModelError
     */
    link?: string;
}
/**
 *
 * @export
 * @interface BadRequestModelV2
 */
export interface BadRequestModelV2 {
    /**
     *
     * @type {BadRequestModelV2Error}
     * @memberof BadRequestModelV2
     */
    error?: BadRequestModelV2Error;
}
/**
 *
 * @export
 * @interface BadRequestModelV2Error
 */
export interface BadRequestModelV2Error {
    /**
     * The error type
     * @type {string}
     * @memberof BadRequestModelV2Error
     */
    type: BadRequestModelV2ErrorTypeEnum;
    /**
     *
     * @type {string}
     * @memberof BadRequestModelV2Error
     */
    error_code: string;
    /**
     *
     * @type {number}
     * @memberof BadRequestModelV2Error
     */
    code: number;
    /**
     *
     * @type {string}
     * @memberof BadRequestModelV2Error
     */
    message: string;
    /**
     *
     * @type {string}
     * @memberof BadRequestModelV2Error
     */
    details?: string;
    /**
     * The request_id provided in the request header
     * @type {string}
     * @memberof BadRequestModelV2Error
     */
    request_id: string;
}
export declare const BadRequestModelV2ErrorTypeEnum: {
    readonly LinkError: "LINK_ERROR";
    readonly ApiError: "API_ERROR";
};
export type BadRequestModelV2ErrorTypeEnum = (typeof BadRequestModelV2ErrorTypeEnum)[keyof typeof BadRequestModelV2ErrorTypeEnum];
/**
 *
 * @export
 * @interface BalanceHistory
 */
export interface BalanceHistory {
    /**
     * The date the balance was recorded
     * @type {string}
     * @memberof BalanceHistory
     */
    date: string;
    /**
     * The end of day balance for this account on this specific date
     * @type {number}
     * @memberof BalanceHistory
     */
    amount: number;
    /**
     * The currency the balance
     * @type {string}
     * @memberof BalanceHistory
     */
    currency: string;
}
/**
 *
 * @export
 * @interface CardAccount
 */
export interface CardAccount {
    /**
     * Account this card is associated with
     * @type {string}
     * @memberof CardAccount
     */
    account_id?: string;
    /**
     *
     * @type {string}
     * @memberof CardAccount
     */
    account_name?: string;
    /**
     * Masked Account number of the card account
     * @type {string}
     * @memberof CardAccount
     */
    account_number_masked?: string;
    /**
     *
     * @type {AccountType}
     * @memberof CardAccount
     */
    account_type?: AccountType;
    /**
     * The statement payment due date
     * @type {string}
     * @memberof CardAccount
     */
    statement_payment_due_date?: string;
    /**
     * The next payment due date
     * @type {string}
     * @memberof CardAccount
     */
    next_payment_due_date?: string;
    /**
     * The statement date
     * @type {string}
     * @memberof CardAccount
     */
    statement_date?: string;
    /**
     * The date of the last payment
     * @type {string}
     * @memberof CardAccount
     */
    last_payment_date?: string;
    /**
     *
     * @type {CurrencyAmount}
     * @memberof CardAccount
     */
    last_payment_amount?: CurrencyAmount;
    /**
     *
     * @type {CurrencyAmount}
     * @memberof CardAccount
     */
    current_balance?: CurrencyAmount;
    /**
     *
     * @type {CurrencyAmount}
     * @memberof CardAccount
     */
    payment_due_amount?: CurrencyAmount;
    /**
     *
     * @type {CurrencyAmount}
     * @memberof CardAccount
     */
    statement_due_amount?: CurrencyAmount;
    /**
     *
     * @type {CurrencyAmount}
     * @memberof CardAccount
     */
    total_credit_limit?: CurrencyAmount;
    /**
     *
     * @type {CurrencyAmount}
     * @memberof CardAccount
     */
    available_credit_limit?: CurrencyAmount;
    /**
     *
     * @type {CurrencyAmount}
     * @memberof CardAccount
     */
    minimum_payment_due?: CurrencyAmount;
    /**
     *
     * @type {Array<GenericAmount>}
     * @memberof CardAccount
     */
    rewards_balances?: Array<GenericAmount>;
    /**
     *
     * @type {string}
     * @memberof CardAccount
     */
    updated_at?: string;
}
/**
 *
 * @export
 * @interface CardDetails
 */
export interface CardDetails {
    /**
     *
     * @type {Array<CardAccount>}
     * @memberof CardDetails
     */
    card_accounts?: Array<CardAccount>;
    /**
     *
     * @type {CardTotal}
     * @memberof CardDetails
     */
    card_total?: CardTotal;
}
/**
 *
 * @export
 * @interface CardFvLinkDetails
 */
export interface CardFvLinkDetails {
    /**
     * The credit card brand
     * @type {string}
     * @memberof CardFvLinkDetails
     */
    brand?: string;
    /**
     * Last 4 digits of the credit card number
     * @type {string}
     * @memberof CardFvLinkDetails
     */
    last4?: string;
    /**
     * The credit card expiry month
     * @type {number}
     * @memberof CardFvLinkDetails
     */
    expiry_month?: number;
    /**
     * The credit card expiry year
     * @type {number}
     * @memberof CardFvLinkDetails
     */
    expiry_year?: number;
    /**
     *
     * @type {string}
     * @memberof CardFvLinkDetails
     */
    collection_entity_name?: string;
}
/**
 *
 * @export
 * @interface CardFvLinkResponse
 */
export interface CardFvLinkResponse {
    /**
     *
     * @type {string}
     * @memberof CardFvLinkResponse
     */
    status?: CardFvLinkResponseStatusEnum;
    /**
     *
     * @type {CardFvLinkDetails}
     * @memberof CardFvLinkResponse
     */
    card_details?: CardFvLinkDetails;
    /**
     *
     * @type {CardRecipient}
     * @memberof CardFvLinkResponse
     */
    recipient?: CardRecipient;
    /**
     *
     * @type {FvEmbeddedErrorModel}
     * @memberof CardFvLinkResponse
     */
    error?: FvEmbeddedErrorModel;
}
export declare const CardFvLinkResponseStatusEnum: {
    readonly Unknown: "UNKNOWN";
    readonly Processing: "PROCESSING";
    readonly Succeeded: "SUCCEEDED";
    readonly Cancelled: "CANCELLED";
    readonly Failed: "FAILED";
};
export type CardFvLinkResponseStatusEnum = (typeof CardFvLinkResponseStatusEnum)[keyof typeof CardFvLinkResponseStatusEnum];
/**
 *
 * @export
 * @interface CardRecipient
 */
export interface CardRecipient {
    /**
     * Merchant account name
     * @type {string}
     * @memberof CardRecipient
     */
    name?: string;
}
/**
 *
 * @export
 * @interface CardTotal
 */
export interface CardTotal {
    /**
     *
     * @type {CurrencyAmount}
     * @memberof CardTotal
     */
    current_balance?: CurrencyAmount;
    /**
     *
     * @type {CurrencyAmount}
     * @memberof CardTotal
     */
    payment_due_amount?: CurrencyAmount;
    /**
     *
     * @type {CurrencyAmount}
     * @memberof CardTotal
     */
    statement_due_amount?: CurrencyAmount;
    /**
     *
     * @type {CurrencyAmount}
     * @memberof CardTotal
     */
    total_credit_limit?: CurrencyAmount;
    /**
     *
     * @type {CurrencyAmount}
     * @memberof CardTotal
     */
    available_credit_limit?: CurrencyAmount;
    /**
     *
     * @type {CurrencyAmount}
     * @memberof CardTotal
     */
    minimum_payment_due?: CurrencyAmount;
    /**
     *
     * @type {Array<GenericAmount>}
     * @memberof CardTotal
     */
    rewards_balances?: Array<GenericAmount>;
    /**
     *
     * @type {string}
     * @memberof CardTotal
     */
    updated_at?: string;
}
/**
 *
 * @export
 * @interface CategoryPredictions
 */
export interface CategoryPredictions {
    /**
     *
     * @type {Array<string>}
     * @memberof CategoryPredictions
     */
    categories?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CategoryPredictions
     */
    source?: string;
    /**
     *
     * @type {string}
     * @memberof CategoryPredictions
     */
    source_id?: string;
}
/**
 *
 * @export
 * @interface ChangePaymentMethodFvLinkResponse
 */
export interface ChangePaymentMethodFvLinkResponse {
    /**
     *
     * @type {string}
     * @memberof ChangePaymentMethodFvLinkResponse
     */
    redirect_url?: string;
}
/**
 *
 * @export
 * @interface CompositeStatementLink
 */
export interface CompositeStatementLink {
    /**
     * signedURL to download statement
     * @type {string}
     * @memberof CompositeStatementLink
     */
    url: string;
    /**
     * expiry of the signedURL
     * @type {string}
     * @memberof CompositeStatementLink
     */
    expiry: string;
}
/**
 *
 * @export
 * @interface ConfirmPaymentResponse
 */
export interface ConfirmPaymentResponse {
    /**
     *
     * @type {boolean}
     * @memberof ConfirmPaymentResponse
     */
    success: boolean;
}
/**
 *
 * @export
 * @interface CreateCardRequest
 */
export interface CreateCardRequest {
    /**
     *
     * @type {CreateCardRequestCardDetails}
     * @memberof CreateCardRequest
     */
    card_details: CreateCardRequestCardDetails;
    /**
     *
     * @type {MandateRecipientRequest}
     * @memberof CreateCardRequest
     */
    recipient_account: MandateRecipientRequest;
    /**
     *
     * @type {string}
     * @memberof CreateCardRequest
     */
    status: CreateCardRequestStatusEnum;
}
export declare const CreateCardRequestStatusEnum: {
    readonly Succeeded: "SUCCEEDED";
};
export type CreateCardRequestStatusEnum = (typeof CreateCardRequestStatusEnum)[keyof typeof CreateCardRequestStatusEnum];
/**
 *
 * @export
 * @interface CreateCardRequestCardDetails
 */
export interface CreateCardRequestCardDetails {
    /**
     *
     * @type {string}
     * @memberof CreateCardRequestCardDetails
     */
    brand: string;
    /**
     *
     * @type {string}
     * @memberof CreateCardRequestCardDetails
     */
    last4: string;
    /**
     *
     * @type {string}
     * @memberof CreateCardRequestCardDetails
     */
    currency: string;
    /**
     *
     * @type {number}
     * @memberof CreateCardRequestCardDetails
     */
    expiry_month?: number;
    /**
     *
     * @type {number}
     * @memberof CreateCardRequestCardDetails
     */
    expiry_year?: number;
}
/**
 *
 * @export
 * @interface CreateFpsTokenResponse
 */
export interface CreateFpsTokenResponse {
    /**
     *
     * @type {PaymentLinkTokenResponse}
     * @memberof CreateFpsTokenResponse
     */
    fps_token: PaymentLinkTokenResponse;
}
/**
 *
 * @export
 * @interface CreateMandateRequest
 */
export interface CreateMandateRequest {
    /**
     *
     * @type {MandateRecipientRequest}
     * @memberof CreateMandateRequest
     */
    recipient_account: MandateRecipientRequest;
    /**
     *
     * @type {CreateMandateSender}
     * @memberof CreateMandateRequest
     */
    sender: CreateMandateSender;
    /**
     *
     * @type {MandateDetailsRequest}
     * @memberof CreateMandateRequest
     */
    mandate_details: MandateDetailsRequest;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof CreateMandateRequest
     */
    metadata?: {
        [key: string]: string;
    };
}
/**
 *
 * @export
 * @interface CreateMandateRequestWithDdaReference
 */
export interface CreateMandateRequestWithDdaReference {
    /**
     *
     * @type {MandateRecipientRequest}
     * @memberof CreateMandateRequestWithDdaReference
     */
    recipient_account: MandateRecipientRequest;
    /**
     *
     * @type {MandateSenderAccountRequest}
     * @memberof CreateMandateRequestWithDdaReference
     */
    sender_account: MandateSenderAccountRequest;
    /**
     *
     * @type {MandateDetailsRequestWithDdaReference}
     * @memberof CreateMandateRequestWithDdaReference
     */
    mandate_details: MandateDetailsRequestWithDdaReference;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof CreateMandateRequestWithDdaReference
     */
    metadata?: {
        [key: string]: string;
    };
    /**
     * The mandate status
     * @type {string}
     * @memberof CreateMandateRequestWithDdaReference
     */
    status: CreateMandateRequestWithDdaReferenceStatusEnum;
}
export declare const CreateMandateRequestWithDdaReferenceStatusEnum: {
    readonly Succeeded: "SUCCEEDED";
};
export type CreateMandateRequestWithDdaReferenceStatusEnum = (typeof CreateMandateRequestWithDdaReferenceStatusEnum)[keyof typeof CreateMandateRequestWithDdaReferenceStatusEnum];
/**
 *
 * @export
 * @interface CreateMandateResponse
 */
export interface CreateMandateResponse {
    /**
     * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
     * @type {string}
     * @memberof CreateMandateResponse
     */
    created_at?: string;
    /**
     * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
     * @type {string}
     * @memberof CreateMandateResponse
     */
    updated_at: string;
    /**
     * Finverse Mandate ID (ULID)
     * @type {string}
     * @memberof CreateMandateResponse
     */
    mandate_id: string;
    /**
     * Finverse Payment Method ID (ULID)
     * @type {string}
     * @memberof CreateMandateResponse
     */
    payment_method_id?: string;
    /**
     * Mandate status
     * @type {string}
     * @memberof CreateMandateResponse
     */
    status: CreateMandateResponseStatusEnum;
    /**
     *
     * @type {MandateRecipient}
     * @memberof CreateMandateResponse
     */
    recipient: MandateRecipient;
    /**
     *
     * @type {MandateRecipientAccount}
     * @memberof CreateMandateResponse
     */
    recipient_account?: MandateRecipientAccount;
    /**
     *
     * @type {GetMandateSender}
     * @memberof CreateMandateResponse
     */
    sender: GetMandateSender;
    /**
     *
     * @type {MandateSenderAccount}
     * @memberof CreateMandateResponse
     */
    sender_account?: MandateSenderAccount;
    /**
     *
     * @type {MandateDetailsResponse}
     * @memberof CreateMandateResponse
     */
    mandate_details: MandateDetailsResponse;
    /**
     *
     * @type {Array<Fee>}
     * @memberof CreateMandateResponse
     */
    fees?: Array<Fee>;
    /**
     * Additional attributes of the mandate in key:value format (e.g. mandate_internal_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 1000 characters respectively.
     * @type {{ [key: string]: string; }}
     * @memberof CreateMandateResponse
     */
    metadata?: {
        [key: string]: string;
    };
    /**
     *
     * @type {FvEmbeddedErrorModel}
     * @memberof CreateMandateResponse
     */
    error?: FvEmbeddedErrorModel;
}
export declare const CreateMandateResponseStatusEnum: {
    readonly AuthorizationRequired: "AUTHORIZATION_REQUIRED";
    readonly Authorizing: "AUTHORIZING";
    readonly Processing: "PROCESSING";
    readonly Submitted: "SUBMITTED";
    readonly Succeeded: "SUCCEEDED";
    readonly Failed: "FAILED";
    readonly Revoked: "REVOKED";
    readonly ReadyToSubmit: "READY_TO_SUBMIT";
    readonly Closed: "CLOSED";
    readonly Cancelled: "CANCELLED";
};
export type CreateMandateResponseStatusEnum = (typeof CreateMandateResponseStatusEnum)[keyof typeof CreateMandateResponseStatusEnum];
/**
 *
 * @export
 * @interface CreateMandateSender
 */
export interface CreateMandateSender {
    /**
     *
     * @type {string}
     * @memberof CreateMandateSender
     */
    name?: string;
    /**
     * Customer App\'s user ID, representing the end-user making the payment.
     * @type {string}
     * @memberof CreateMandateSender
     */
    external_user_id?: string;
    /**
     * Type of account held by the Sender at the Institution. Possible values are INDIVIDUAL, BUSINESS
     * @type {string}
     * @memberof CreateMandateSender
     */
    user_type?: CreateMandateSenderUserTypeEnum;
    /**
     * Sender details which will be used for fraud checking.
     * @type {Array<SenderDetail>}
     * @memberof CreateMandateSender
     */
    user_details?: Array<SenderDetail>;
}
export declare const CreateMandateSenderUserTypeEnum: {
    readonly Individual: "INDIVIDUAL";
    readonly Business: "BUSINESS";
};
export type CreateMandateSenderUserTypeEnum = (typeof CreateMandateSenderUserTypeEnum)[keyof typeof CreateMandateSenderUserTypeEnum];
/**
 *
 * @export
 * @interface CreateMandateWithSenderAccountRequest
 */
export interface CreateMandateWithSenderAccountRequest {
    /**
     *
     * @type {MandateRecipientRequest}
     * @memberof CreateMandateWithSenderAccountRequest
     */
    recipient_account: MandateRecipientRequest;
    /**
     *
     * @type {MandateSenderAccountRequest}
     * @memberof CreateMandateWithSenderAccountRequest
     */
    sender_account: MandateSenderAccountRequest;
    /**
     *
     * @type {MandateDetailsRequest}
     * @memberof CreateMandateWithSenderAccountRequest
     */
    mandate_details: MandateDetailsRequest;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof CreateMandateWithSenderAccountRequest
     */
    metadata?: {
        [key: string]: string;
    };
}
/**
 *
 * @export
 * @interface CreatePaymentAccountRequest
 */
export interface CreatePaymentAccountRequest {
    /**
     *
     * @type {RecipientAccountNumber}
     * @memberof CreatePaymentAccountRequest
     */
    account_number: RecipientAccountNumber;
    /**
     * Type of payment account. Currently only allow creating external account.
     * @type {string}
     * @memberof CreatePaymentAccountRequest
     */
    account_type: CreatePaymentAccountRequestAccountTypeEnum;
    /**
     * Accountholder name of the payment account
     * @type {string}
     * @memberof CreatePaymentAccountRequest
     */
    accountholder_name: string;
    /**
     * List of currencies supported by the payment account
     * @type {Array<string>}
     * @memberof CreatePaymentAccountRequest
     */
    currencies?: Array<string>;
    /**
     * Finverse Institution ID for the payment institution.
     * @type {string}
     * @memberof CreatePaymentAccountRequest
     */
    institution_id: string;
    /**
     * A unique identifier generated after creating user (Finverse Payment User ID)
     * @type {string}
     * @memberof CreatePaymentAccountRequest
     */
    user_id: string;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof CreatePaymentAccountRequest
     */
    metadata?: {
        [key: string]: string;
    };
}
export declare const CreatePaymentAccountRequestAccountTypeEnum: {
    readonly ExternalAccount: "EXTERNAL_ACCOUNT";
};
export type CreatePaymentAccountRequestAccountTypeEnum = (typeof CreatePaymentAccountRequestAccountTypeEnum)[keyof typeof CreatePaymentAccountRequestAccountTypeEnum];
/**
 *
 * @export
 * @interface CreatePaymentInstructionResponse
 */
export interface CreatePaymentInstructionResponse {
    /**
     *
     * @type {string}
     * @memberof CreatePaymentInstructionResponse
     */
    payment_instruction_id?: string;
}
/**
 *
 * @export
 * @interface CreatePaymentLinkCardPaymentResponse
 */
export interface CreatePaymentLinkCardPaymentResponse {
    /**
     * URL to redirect to for making the card payment (e.g. Stripe)
     * @type {string}
     * @memberof CreatePaymentLinkCardPaymentResponse
     */
    card_processor_redirect_uri: string;
    /**
     * Finverse Payment ID
     * @type {string}
     * @memberof CreatePaymentLinkCardPaymentResponse
     */
    payment_id?: string;
}
/**
 *
 * @export
 * @interface CreatePaymentLinkMandateRequest
 */
export interface CreatePaymentLinkMandateRequest {
    /**
     *
     * @type {string}
     * @memberof CreatePaymentLinkMandateRequest
     */
    payment_attempt_id: string;
    /**
     * The sender type of the mandate
     * @type {string}
     * @memberof CreatePaymentLinkMandateRequest
     */
    sender_type: CreatePaymentLinkMandateRequestSenderTypeEnum;
}
export declare const CreatePaymentLinkMandateRequestSenderTypeEnum: {
    readonly Individual: "INDIVIDUAL";
    readonly Business: "BUSINESS";
};
export type CreatePaymentLinkMandateRequestSenderTypeEnum = (typeof CreatePaymentLinkMandateRequestSenderTypeEnum)[keyof typeof CreatePaymentLinkMandateRequestSenderTypeEnum];
/**
 *
 * @export
 * @interface CreatePaymentLinkMandateResponse
 */
export interface CreatePaymentLinkMandateResponse {
    /**
     *
     * @type {PaymentLinkTokenResponse}
     * @memberof CreatePaymentLinkMandateResponse
     */
    mandate_link_token: PaymentLinkTokenResponse;
}
/**
 *
 * @export
 * @interface CreatePaymentLinkRequest
 */
export interface CreatePaymentLinkRequest {
    /**
     * The amount of the payment. Expressed in currency\'s smallest unit or “minor unit”, as defined in ISO 4217.
     * @type {number}
     * @memberof CreatePaymentLinkRequest
     */
    amount?: number;
    /**
     *
     * @type {string}
     * @memberof CreatePaymentLinkRequest
     */
    currency: string;
    /**
     *
     * @type {PaymentLinkCustomizations}
     * @memberof CreatePaymentLinkRequest
     */
    link_customizations?: PaymentLinkCustomizations;
    /**
     * The payment link mode
     * @type {string}
     * @memberof CreatePaymentLinkRequest
     */
    mode: CreatePaymentLinkRequestModeEnum;
    /**
     *
     * @type {PaymentLinkDetails}
     * @memberof CreatePaymentLinkRequest
     */
    payment_details?: PaymentLinkDetails;
    /**
     *
     * @type {PaymentLinkSender}
     * @memberof CreatePaymentLinkRequest
     */
    sender: PaymentLinkSender;
    /**
     * Unique reference id to identifying the payment to be collected.
     * @type {string}
     * @memberof CreatePaymentLinkRequest
     */
    unique_reference_id: string;
    /**
     *
     * @type {PaymentSetupOptions}
     * @memberof CreatePaymentLinkRequest
     */
    payment_setup_options?: PaymentSetupOptions;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof CreatePaymentLinkRequest
     */
    metadata?: {
        [key: string]: string;
    };
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof CreatePaymentLinkRequest
     */
    payment_metadata?: {
        [key: string]: string;
    };
    /**
     *
     * @type {IntegrationMetadataRequest}
     * @memberof CreatePaymentLinkRequest
     */
    integration_metadata?: IntegrationMetadataRequest;
}
export declare const CreatePaymentLinkRequestModeEnum: {
    readonly Payment: "PAYMENT";
    readonly Setup: "SETUP";
};
export type CreatePaymentLinkRequestModeEnum = (typeof CreatePaymentLinkRequestModeEnum)[keyof typeof CreatePaymentLinkRequestModeEnum];
/**
 *
 * @export
 * @interface CreatePaymentMethodRequest
 */
export interface CreatePaymentMethodRequest {
    /**
     *
     * @type {CreateCardRequest}
     * @memberof CreatePaymentMethodRequest
     */
    card?: CreateCardRequest;
    /**
     *
     * @type {CreateMandateRequestWithDdaReference}
     * @memberof CreatePaymentMethodRequest
     */
    mandate?: CreateMandateRequestWithDdaReference;
    /**
     *
     * @type {PaymentMethodIntegrationMetadata}
     * @memberof CreatePaymentMethodRequest
     */
    integration_metadata?: PaymentMethodIntegrationMetadata;
    /**
     *
     * @type {string}
     * @memberof CreatePaymentMethodRequest
     */
    payment_method_type: CreatePaymentMethodRequestPaymentMethodTypeEnum;
}
export declare const CreatePaymentMethodRequestPaymentMethodTypeEnum: {
    readonly Card: "CARD";
    readonly Mandate: "MANDATE";
};
export type CreatePaymentMethodRequestPaymentMethodTypeEnum = (typeof CreatePaymentMethodRequestPaymentMethodTypeEnum)[keyof typeof CreatePaymentMethodRequestPaymentMethodTypeEnum];
/**
 *
 * @export
 * @interface CreatePaymentRequest
 */
export interface CreatePaymentRequest {
    /**
     * Amount to be paid, in currency\'s smallest unit or “minor unit”, as defined in ISO 4217. For example, HKD 100.01 is represented as amount = 10001 (minor unit = cents). For currencies without minor units (e.g. VND, JPY), the amount is represented as is, without modification. For example, VND 15101 is represented as amount = 15101.
     * @type {number}
     * @memberof CreatePaymentRequest
     */
    amount: number;
    /**
     * The currency code as defined in ISO 4217.
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    currency: string;
    /**
     * ID of the payment method this pament is referring to.
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    payment_method_id?: string;
    /**
     *
     * @type {PaymentDetails2}
     * @memberof CreatePaymentRequest
     */
    payment_details: PaymentDetails2;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof CreatePaymentRequest
     */
    metadata?: {
        [key: string]: string;
    };
}
/**
 *
 * @export
 * @interface CreatePaymentUserRequest
 */
export interface CreatePaymentUserRequest {
    /**
     *
     * @type {string}
     * @memberof CreatePaymentUserRequest
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof CreatePaymentUserRequest
     */
    external_user_id: string;
    /**
     *
     * @type {string}
     * @memberof CreatePaymentUserRequest
     */
    user_type?: CreatePaymentUserRequestUserTypeEnum;
    /**
     *
     * @type {string}
     * @memberof CreatePaymentUserRequest
     */
    email?: string;
    /**
     *
     * @type {Array<SenderDetail>}
     * @memberof CreatePaymentUserRequest
     */
    user_details?: Array<SenderDetail>;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof CreatePaymentUserRequest
     */
    metadata?: {
        [key: string]: string;
    };
    /**
     *
     * @type {boolean}
     * @memberof CreatePaymentUserRequest
     */
    autopay_consent?: boolean;
    /**
     *
     * @type {IntegrationMetadataRequest}
     * @memberof CreatePaymentUserRequest
     */
    integration_metadata?: IntegrationMetadataRequest;
}
export declare const CreatePaymentUserRequestUserTypeEnum: {
    readonly Individual: "INDIVIDUAL";
    readonly Business: "BUSINESS";
};
export type CreatePaymentUserRequestUserTypeEnum = (typeof CreatePaymentUserRequestUserTypeEnum)[keyof typeof CreatePaymentUserRequestUserTypeEnum];
/**
 *
 * @export
 * @interface CreateRecipientAccount
 */
export interface CreateRecipientAccount {
    /**
     * Accountholder name of the recipient\'s account
     * @type {string}
     * @memberof CreateRecipientAccount
     */
    accountholder_name: string;
    /**
     *
     * @type {RecipientAccountNumber}
     * @memberof CreateRecipientAccount
     */
    account_number: RecipientAccountNumber;
    /**
     * Type of recipient account.
     * @type {string}
     * @memberof CreateRecipientAccount
     */
    account_type: CreateRecipientAccountAccountTypeEnum;
    /**
     * List of currencies supported by the recipient account
     * @type {Array<string>}
     * @memberof CreateRecipientAccount
     */
    currencies: Array<string>;
    /**
     * Finverse Institution ID for the recipient’s institution.
     * @type {string}
     * @memberof CreateRecipientAccount
     */
    institution_id: string;
}
export declare const CreateRecipientAccountAccountTypeEnum: {
    readonly ExternalAccount: "EXTERNAL_ACCOUNT";
};
export type CreateRecipientAccountAccountTypeEnum = (typeof CreateRecipientAccountAccountTypeEnum)[keyof typeof CreateRecipientAccountAccountTypeEnum];
/**
 *
 * @export
 * @interface CreateScheduledPayoutRequest
 */
export interface CreateScheduledPayoutRequest {
    /**
     * Amount to be paid, in currency\'s smallest unit or “minor unit”, as defined in ISO 4217. For example, HKD 100.01 is represented as amount = 10001 (minor unit = cents). For currencies without minor units (e.g. VND, JPY), the amount is represented as is, without modification. For example, VND 15101 is represented as amount = 15101.
     * @type {number}
     * @memberof CreateScheduledPayoutRequest
     */
    amount: number;
    /**
     * The currency code as defined in ISO 4217.
     * @type {string}
     * @memberof CreateScheduledPayoutRequest
     */
    currency: string;
    /**
     *
     * @type {PayoutDetails}
     * @memberof CreateScheduledPayoutRequest
     */
    payment_details: PayoutDetails;
    /**
     *
     * @type {MandateRecipientRequest}
     * @memberof CreateScheduledPayoutRequest
     */
    recipient_account: MandateRecipientRequest;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof CreateScheduledPayoutRequest
     */
    metadata?: {
        [key: string]: string;
    };
}
/**
 *
 * @export
 * @interface CurrencyAmount
 */
export interface CurrencyAmount {
    /**
     *
     * @type {string}
     * @memberof CurrencyAmount
     */
    currency?: string;
    /**
     *
     * @type {number}
     * @memberof CurrencyAmount
     */
    value: number;
    /**
     *
     * @type {string}
     * @memberof CurrencyAmount
     */
    raw?: string;
}
/**
 *
 * @export
 * @interface CustomerPaymentInstruction
 */
export interface CustomerPaymentInstruction {
    /**
     * A id of the user of this payment, need to equal to userId when creating link
     * @type {string}
     * @memberof CustomerPaymentInstruction
     */
    user_id: string;
    /**
     * Type of payment is being created, please check Documentation on which payment type is supported in each institution
     * @type {string}
     * @memberof CustomerPaymentInstruction
     */
    type: CustomerPaymentInstructionTypeEnum;
    /**
     * The recipient name
     * @type {string}
     * @memberof CustomerPaymentInstruction
     */
    recipient_name?: string;
    /**
     * The recipient account Id
     * @type {string}
     * @memberof CustomerPaymentInstruction
     */
    recipient_account_id?: string;
    /**
     * The sender name
     * @type {string}
     * @memberof CustomerPaymentInstruction
     */
    sender_name?: string;
    /**
     * The sender account Id
     * @type {string}
     * @memberof CustomerPaymentInstruction
     */
    sender_account_id?: string;
    /**
     * When the payment should start
     * @type {string}
     * @memberof CustomerPaymentInstruction
     */
    start_date?: string | null;
    /**
     * When the payment should stop
     * @type {string}
     * @memberof CustomerPaymentInstruction
     */
    end_date?: string | null;
    /**
     * The currency for the payment
     * @type {string}
     * @memberof CustomerPaymentInstruction
     */
    currency?: string;
    /**
     * The payment amount
     * @type {number}
     * @memberof CustomerPaymentInstruction
     */
    amount?: number;
    /**
     * How often the payment should be executed
     * @type {string}
     * @memberof CustomerPaymentInstruction
     */
    frequency?: string;
    /**
     * Related remarks about this instruction
     * @type {string}
     * @memberof CustomerPaymentInstruction
     */
    remarks?: string;
}
export declare const CustomerPaymentInstructionTypeEnum: {
    readonly DebitAuthorization: "DEBIT_AUTHORIZATION";
};
export type CustomerPaymentInstructionTypeEnum = (typeof CustomerPaymentInstructionTypeEnum)[keyof typeof CustomerPaymentInstructionTypeEnum];
/**
 *
 * @export
 * @interface DeleteLoginIdentityResponse
 */
export interface DeleteLoginIdentityResponse {
    /**
     *
     * @type {boolean}
     * @memberof DeleteLoginIdentityResponse
     */
    success?: boolean;
}
/**
 *
 * @export
 * @interface DisputeResponse
 */
export interface DisputeResponse {
    /**
     * The dispute id
     * @type {string}
     * @memberof DisputeResponse
     */
    dispute_id?: string;
    /**
     * Amount to be disputed, in currency\'s smallest unit or “minor unit”, as defined in ISO 4217. For example, HKD 100.01 is represented as amount = 10001 (minor unit = cents). For currencies without minor units (e.g. VND, JPY), the amount is represented as is, without modification. For example, VND 15101 is represented as amount = 15101.
     * @type {number}
     * @memberof DisputeResponse
     */
    amount?: number;
    /**
     * The currency of the balance
     * @type {string}
     * @memberof DisputeResponse
     */
    currency?: string;
    /**
     * The name of the last event for this dispute
     * @type {string}
     * @memberof DisputeResponse
     */
    last_event_name?: string;
    /**
     * The payment id
     * @type {string}
     * @memberof DisputeResponse
     */
    payment_id?: string;
    /**
     * The payment processor handling the dispute
     * @type {string}
     * @memberof DisputeResponse
     */
    payment_processor?: string;
    /**
     * The account ID at the payment processor
     * @type {string}
     * @memberof DisputeResponse
     */
    payment_processor_account_id?: string;
    /**
     * The payment reference for the disputed transaction
     * @type {string}
     * @memberof DisputeResponse
     */
    payment_reference?: string;
    /**
     * The payment processor\'s payment reference
     * @type {string}
     * @memberof DisputeResponse
     */
    payment_processor_payment_reference?: string;
    /**
     *
     * @type {DisputeResponseCardDetails}
     * @memberof DisputeResponse
     */
    card_details?: DisputeResponseCardDetails;
    /**
     * The payment processor\'s dispute reference
     * @type {string}
     * @memberof DisputeResponse
     */
    payment_processor_dispute_reference?: string;
    /**
     * The reason for the dispute as provided by the payment processor
     * @type {string}
     * @memberof DisputeResponse
     */
    payment_processor_dispute_reason?: string;
    /**
     * Acquirer Reference Number
     * @type {string}
     * @memberof DisputeResponse
     */
    arn?: string;
    /**
     * The dispute code from the payment processor
     * @type {string}
     * @memberof DisputeResponse
     */
    payment_processor_dispute_code?: string;
    /**
     * Whether the dispute is defendable
     * @type {boolean}
     * @memberof DisputeResponse
     */
    is_defendable?: boolean;
    /**
     * The status of the dispute
     * @type {string}
     * @memberof DisputeResponse
     */
    dispute_status?: DisputeResponseDisputeStatusEnum;
    /**
     * The status of the dispute at the payment processor
     * @type {string}
     * @memberof DisputeResponse
     */
    payment_processor_dispute_status?: string;
    /**
     * Whether the dispute was automatically defended
     * @type {boolean}
     * @memberof DisputeResponse
     */
    is_auto_defended?: boolean;
    /**
     * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
     * @type {string}
     * @memberof DisputeResponse
     */
    defense_period_deadline?: string;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof DisputeResponse
     */
    issuer_comments?: {
        [key: string]: string;
    };
    /**
     * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
     * @type {string}
     * @memberof DisputeResponse
     */
    created_at?: string;
    /**
     * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
     * @type {string}
     * @memberof DisputeResponse
     */
    updated_at?: string;
}
export declare const DisputeResponseDisputeStatusEnum: {
    readonly Unknown: "UNKNOWN";
    readonly Undefended: "UNDEFENDED";
    readonly ActionRequired: "ACTION_REQUIRED";
    readonly Processing: "PROCESSING";
    readonly Accepted: "ACCEPTED";
    readonly Lost: "LOST";
    readonly Won: "WON";
};
export type DisputeResponseDisputeStatusEnum = (typeof DisputeResponseDisputeStatusEnum)[keyof typeof DisputeResponseDisputeStatusEnum];
/**
 *
 * @export
 * @interface DisputeResponseCardDetails
 */
export interface DisputeResponseCardDetails {
    /**
     *
     * @type {string}
     * @memberof DisputeResponseCardDetails
     */
    brand?: string;
}
/**
 *
 * @export
 * @interface DownloadBalanceStatementResponse
 */
export interface DownloadBalanceStatementResponse {
    /**
     * Signed URL to download the CSV from
     * @type {string}
     * @memberof DownloadBalanceStatementResponse
     */
    download_url: string;
}
/**
 *
 * @export
 * @interface EncryptedPayload
 */
export interface EncryptedPayload {
    /**
     * The credential payload encrypted with AES (base64)
     * @type {string}
     * @memberof EncryptedPayload
     */
    ciphertext: string;
    /**
     * The 16 byte IV used w/ AES (base64)
     * @type {string}
     * @memberof EncryptedPayload
     */
    initializationVector: string;
    /**
     * The MAC to verify AES decryption validity
     * @type {string}
     * @memberof EncryptedPayload
     */
    messageAuthenticationCode: string;
    /**
     * The AES key encrypted with an RSA pubkey (base64)
     * @type {string}
     * @memberof EncryptedPayload
     */
    envelopeEncryptionKey: string;
    /**
     * The identifier of the public key used to encrypt the AES key
     * @type {string}
     * @memberof EncryptedPayload
     */
    keyId: string;
}
/**
 *
 * @export
 * @interface ErrBodyModel
 */
export interface ErrBodyModel {
    /**
     *
     * @type {FvErrorModel}
     * @memberof ErrBodyModel
     */
    error?: FvErrorModel;
}
/**
 *
 * @export
 * @interface ErrBodyModelV2
 */
export interface ErrBodyModelV2 {
    /**
     *
     * @type {FvErrorModelV2}
     * @memberof ErrBodyModelV2
     */
    error?: FvErrorModelV2;
}
/**
 *
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     *
     * @type {string}
     * @memberof ErrorResponse
     */
    err?: string;
    /**
     *
     * @type {number}
     * @memberof ErrorResponse
     */
    http_status_code?: number;
    /**
     *
     * @type {string}
     * @memberof ErrorResponse
     */
    status_text?: string;
    /**
     *
     * @type {number}
     * @memberof ErrorResponse
     */
    app_code?: number;
    /**
     *
     * @type {string}
     * @memberof ErrorResponse
     */
    error_category?: string;
    /**
     *
     * @type {string}
     * @memberof ErrorResponse
     */
    error_text?: string;
    /**
     *
     * @type {string}
     * @memberof ErrorResponse
     */
    request_id?: string;
}
/**
 *
 * @export
 * @interface FVCard
 */
export interface FVCard {
    /**
     * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
     * @type {string}
     * @memberof FVCard
     */
    created_at?: string;
    /**
     * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
     * @type {string}
     * @memberof FVCard
     */
    updated_at?: string;
    /**
     * Card Status
     * @type {string}
     * @memberof FVCard
     */
    status?: FVCardStatusEnum;
    /**
     *
     * @type {FvEmbeddedErrorModel}
     * @memberof FVCard
     */
    error?: FvEmbeddedErrorModel;
    /**
     *
     * @type {FVCardDetails}
     * @memberof FVCard
     */
    card_details?: FVCardDetails;
    /**
     *
     * @type {MandateRecipientAccount}
     * @memberof FVCard
     */
    recipient_account?: MandateRecipientAccount;
}
export declare const FVCardStatusEnum: {
    readonly Unknown: "UNKNOWN";
    readonly Processing: "PROCESSING";
    readonly Succeeded: "SUCCEEDED";
    readonly Cancelled: "CANCELLED";
    readonly Failed: "FAILED";
};
export type FVCardStatusEnum = (typeof FVCardStatusEnum)[keyof typeof FVCardStatusEnum];
/**
 *
 * @export
 * @interface FVCardDetails
 */
export interface FVCardDetails {
    /**
     * The credit card brand
     * @type {string}
     * @memberof FVCardDetails
     */
    brand?: string;
    /**
     * Last 4 digits of the credit card number
     * @type {string}
     * @memberof FVCardDetails
     */
    last4?: string;
    /**
     * The credit card expiry month
     * @type {number}
     * @memberof FVCardDetails
     */
    expiry_month?: number;
    /**
     * The credit card expiry year
     * @type {number}
     * @memberof FVCardDetails
     */
    expiry_year?: number;
    /**
     *
     * @type {string}
     * @memberof FVCardDetails
     */
    processor_entity_name?: string;
    /**
     *
     * @type {string}
     * @memberof FVCardDetails
     */
    collection_entity_name?: string;
    /**
     *
     * @type {string}
     * @memberof FVCardDetails
     */
    country?: string;
    /**
     *
     * @type {string}
     * @memberof FVCardDetails
     */
    fingerprint?: string;
    /**
     *
     * @type {string}
     * @memberof FVCardDetails
     */
    funding?: FVCardDetailsFundingEnum;
    /**
     *
     * @type {string}
     * @memberof FVCardDetails
     */
    finverse_authorization_reference?: string;
    /**
     *
     * @type {FVCardProcessorDetails}
     * @memberof FVCardDetails
     */
    processor_details?: FVCardProcessorDetails;
    /**
     * The recurring payment mode
     * @type {string}
     * @memberof FVCardDetails
     */
    recurring_payment_mode?: string;
}
export declare const FVCardDetailsFundingEnum: {
    readonly Unknown: "UNKNOWN";
    readonly Credit: "CREDIT";
    readonly Debit: "DEBIT";
    readonly Prepaid: "PREPAID";
};
export type FVCardDetailsFundingEnum = (typeof FVCardDetailsFundingEnum)[keyof typeof FVCardDetailsFundingEnum];
/**
 *
 * @export
 * @interface FVCardProcessorDetails
 */
export interface FVCardProcessorDetails {
    /**
     *
     * @type {string}
     * @memberof FVCardProcessorDetails
     */
    auth_code?: string;
    /**
     *
     * @type {string}
     * @memberof FVCardProcessorDetails
     */
    processor_id?: string;
    /**
     *
     * @type {string}
     * @memberof FVCardProcessorDetails
     */
    processor_reference?: string;
    /**
     *
     * @type {string}
     * @memberof FVCardProcessorDetails
     */
    token_id?: string;
}
/**
 *
 * @export
 * @interface Fee
 */
export interface Fee {
    /**
     * The amount of fee for a single transaction. Expressed in currency\'s smallest unit or “minor unit”, as defined in ISO 4217.
     * @type {number}
     * @memberof Fee
     */
    amount: number;
    /**
     *
     * @type {string}
     * @memberof Fee
     */
    currency?: string;
    /**
     *
     * @type {string}
     * @memberof Fee
     */
    paid_by?: FeePaidByEnum;
    /**
     * The payment account Id
     * @type {string}
     * @memberof Fee
     */
    paid_by_account_id?: string;
}
export declare const FeePaidByEnum: {
    readonly Recipient: "RECIPIENT";
    readonly Sender: "SENDER";
};
export type FeePaidByEnum = (typeof FeePaidByEnum)[keyof typeof FeePaidByEnum];
/**
 *
 * @export
 * @interface FpsQrCodeResponse
 */
export interface FpsQrCodeResponse {
    /**
     * The FPS QR code in base64
     * @type {string}
     * @memberof FpsQrCodeResponse
     */
    qr_code: string;
}
/**
 *
 * @export
 * @interface FvEmbeddedErrorModel
 */
export interface FvEmbeddedErrorModel {
    /**
     * The error type
     * @type {string}
     * @memberof FvEmbeddedErrorModel
     */
    type: FvEmbeddedErrorModelTypeEnum;
    /**
     *
     * @type {string}
     * @memberof FvEmbeddedErrorModel
     */
    error_code: string;
    /**
     *
     * @type {string}
     * @memberof FvEmbeddedErrorModel
     */
    message: string;
    /**
     *
     * @type {string}
     * @memberof FvEmbeddedErrorModel
     */
    details: string;
}
export declare const FvEmbeddedErrorModelTypeEnum: {
    readonly LinkError: "LINK_ERROR";
    readonly ApiError: "API_ERROR";
};
export type FvEmbeddedErrorModelTypeEnum = (typeof FvEmbeddedErrorModelTypeEnum)[keyof typeof FvEmbeddedErrorModelTypeEnum];
/**
 *
 * @export
 * @interface FvErrorModel
 */
export interface FvErrorModel {
    /**
     * The error type
     * @type {string}
     * @memberof FvErrorModel
     */
    type: FvErrorModelTypeEnum;
    /**
     *
     * @type {string}
     * @memberof FvErrorModel
     */
    error_code: string;
    /**
     *
     * @type {string}
     * @memberof FvErrorModel
     */
    code: string;
    /**
     *
     * @type {string}
     * @memberof FvErrorModel
     */
    message: string;
    /**
     *
     * @type {string}
     * @memberof FvErrorModel
     */
    details: string;
    /**
     * The request_id provided in the request header
     * @type {string}
     * @memberof FvErrorModel
     */
    request_id: string;
}
export declare const FvErrorModelTypeEnum: {
    readonly LinkError: "LINK_ERROR";
    readonly ApiError: "API_ERROR";
};
export type FvErrorModelTypeEnum = (typeof FvErrorModelTypeEnum)[keyof typeof FvErrorModelTypeEnum];
/**
 *
 * @export
 * @interface FvErrorModelV2
 */
export interface FvErrorModelV2 {
    /**
     * The error type
     * @type {string}
     * @memberof FvErrorModelV2
     */
    type: FvErrorModelV2TypeEnum;
    /**
     *
     * @type {string}
     * @memberof FvErrorModelV2
     */
    error_code: string;
    /**
     *
     * @type {string}
     * @memberof FvErrorModelV2
     */
    message: string;
    /**
     *
     * @type {string}
     * @memberof FvErrorModelV2
     */
    details: string;
    /**
     * The request_id provided in the request header
     * @type {string}
     * @memberof FvErrorModelV2
     */
    request_id: string;
}
export declare const FvErrorModelV2TypeEnum: {
    readonly LinkError: "LINK_ERROR";
    readonly ApiError: "API_ERROR";
};
export type FvErrorModelV2TypeEnum = (typeof FvErrorModelV2TypeEnum)[keyof typeof FvErrorModelV2TypeEnum];
/**
 *
 * @export
 * @interface GenericAmount
 */
export interface GenericAmount {
    /**
     *
     * @type {string}
     * @memberof GenericAmount
     */
    unit?: string;
    /**
     *
     * @type {number}
     * @memberof GenericAmount
     */
    value: number;
    /**
     *
     * @type {string}
     * @memberof GenericAmount
     */
    raw?: string;
}
/**
 *
 * @export
 * @interface GetAccountNumberResponse
 */
export interface GetAccountNumberResponse {
    /**
     *
     * @type {AccountNumber}
     * @memberof GetAccountNumberResponse
     */
    account_number?: AccountNumber;
    /**
     *
     * @type {Account}
     * @memberof GetAccountNumberResponse
     */
    account?: Account;
    /**
     *
     * @type {LoginIdentityShort}
     * @memberof GetAccountNumberResponse
     */
    login_identity?: LoginIdentityShort;
    /**
     *
     * @type {InstitutionShort}
     * @memberof GetAccountNumberResponse
     */
    institution?: InstitutionShort;
    /**
     *
     * @type {Array<PaymentDetails>}
     * @memberof GetAccountNumberResponse
     */
    payment_details?: Array<PaymentDetails>;
}
/**
 *
 * @export
 * @interface GetAccountResponse
 */
export interface GetAccountResponse {
    /**
     *
     * @type {Account}
     * @memberof GetAccountResponse
     */
    account?: Account;
    /**
     *
     * @type {LoginIdentityShort}
     * @memberof GetAccountResponse
     */
    login_identity?: LoginIdentityShort;
    /**
     *
     * @type {InstitutionShort}
     * @memberof GetAccountResponse
     */
    institution?: InstitutionShort;
}
/**
 *
 * @export
 * @interface GetBalanceHistoryResponse
 */
export interface GetBalanceHistoryResponse {
    /**
     *
     * @type {Account}
     * @memberof GetBalanceHistoryResponse
     */
    account?: Account;
    /**
     *
     * @type {LoginIdentityShort}
     * @memberof GetBalanceHistoryResponse
     */
    login_identity?: LoginIdentityShort;
    /**
     *
     * @type {InstitutionShort}
     * @memberof GetBalanceHistoryResponse
     */
    institution?: InstitutionShort;
    /**
     *
     * @type {Array<BalanceHistory>}
     * @memberof GetBalanceHistoryResponse
     */
    balance_history?: Array<BalanceHistory>;
    /**
     *
     * @type {string}
     * @memberof GetBalanceHistoryResponse
     */
    source?: GetBalanceHistoryResponseSourceEnum;
}
export declare const GetBalanceHistoryResponseSourceEnum: {
    readonly Institution: "INSTITUTION";
    readonly Computed: "COMPUTED";
};
export type GetBalanceHistoryResponseSourceEnum = (typeof GetBalanceHistoryResponseSourceEnum)[keyof typeof GetBalanceHistoryResponseSourceEnum];
/**
 *
 * @export
 * @interface GetIdentityResponse
 */
export interface GetIdentityResponse {
    /**
     *
     * @type {Identity}
     * @memberof GetIdentityResponse
     */
    identity?: Identity;
    /**
     *
     * @type {LoginIdentityShort}
     * @memberof GetIdentityResponse
     */
    login_identity?: LoginIdentityShort;
    /**
     *
     * @type {InstitutionShort}
     * @memberof GetIdentityResponse
     */
    institution?: InstitutionShort;
}
/**
 *
 * @export
 * @interface GetJWKSResponse
 */
export interface GetJWKSResponse {
    /**
     *
     * @type {Array<JWKSKey>}
     * @memberof GetJWKSResponse
     */
    keys?: Array<JWKSKey>;
}
/**
 *
 * @export
 * @interface GetLineItemsForDisplayResponse
 */
export interface GetLineItemsForDisplayResponse {
    /**
     *
     * @type {Array<LineItem>}
     * @memberof GetLineItemsForDisplayResponse
     */
    line_items?: Array<LineItem>;
}
/**
 *
 * @export
 * @interface GetLoginIdentityByIdResponse
 */
export interface GetLoginIdentityByIdResponse {
    /**
     *
     * @type {LoginIdentity}
     * @memberof GetLoginIdentityByIdResponse
     */
    login_identity?: LoginIdentity;
    /**
     *
     * @type {InstitutionShort}
     * @memberof GetLoginIdentityByIdResponse
     */
    institution?: InstitutionShort;
}
/**
 *
 * @export
 * @interface GetLoginIdentityHistoryResponse
 */
export interface GetLoginIdentityHistoryResponse {
    /**
     *
     * @type {LoginIdentity}
     * @memberof GetLoginIdentityHistoryResponse
     */
    login_identity?: LoginIdentity;
    /**
     *
     * @type {Array<LoginIdentityStatusDetails>}
     * @memberof GetLoginIdentityHistoryResponse
     */
    status_history?: Array<LoginIdentityStatusDetails>;
}
/**
 *
 * @export
 * @interface GetMandateAuthLinkRequest
 */
export interface GetMandateAuthLinkRequest {
    /**
     * Mandate ID
     * @type {string}
     * @memberof GetMandateAuthLinkRequest
     */
    mandate_id: string;
    /**
     *
     * @type {MandateAuthLinkCustomizations}
     * @memberof GetMandateAuthLinkRequest
     */
    link_customizations: MandateAuthLinkCustomizations;
}
/**
 *
 * @export
 * @interface GetMandateAuthLinkResponse
 */
export interface GetMandateAuthLinkResponse {
    /**
     * Short-lived access-token to interact with Finverse Link
     * @type {string}
     * @memberof GetMandateAuthLinkResponse
     */
    access_token: string;
    /**
     * Access token validity duration (in seconds)
     * @type {number}
     * @memberof GetMandateAuthLinkResponse
     */
    expires_in: number;
    /**
     * URL to launch Finverse Link to authorize the mandate
     * @type {string}
     * @memberof GetMandateAuthLinkResponse
     */
    link_url: string;
    /**
     *
     * @type {string}
     * @memberof GetMandateAuthLinkResponse
     */
    token_type: GetMandateAuthLinkResponseTokenTypeEnum;
}
export declare const GetMandateAuthLinkResponseTokenTypeEnum: {
    readonly Bearer: "Bearer";
};
export type GetMandateAuthLinkResponseTokenTypeEnum = (typeof GetMandateAuthLinkResponseTokenTypeEnum)[keyof typeof GetMandateAuthLinkResponseTokenTypeEnum];
/**
 *
 * @export
 * @interface GetMandateAuthResponse
 */
export interface GetMandateAuthResponse {
    /**
     * Finverse Mandate ID
     * @type {string}
     * @memberof GetMandateAuthResponse
     */
    mandate_id: string;
    /**
     * Mandate status
     * @type {string}
     * @memberof GetMandateAuthResponse
     */
    mandate_status: GetMandateAuthResponseMandateStatusEnum;
    /**
     * Merchant account ID assigned by Finverse
     * @type {string}
     * @memberof GetMandateAuthResponse
     */
    recipient_account_id: string;
    /**
     * Finverse Institution ID. Only returned if institution_id was included in the request.
     * @type {string}
     * @memberof GetMandateAuthResponse
     */
    institution_id: string;
    /**
     * Type of account held by the Sender at the Institution. Possible values are INDIVIDUAL, BUSINESS
     * @type {string}
     * @memberof GetMandateAuthResponse
     */
    sender_type?: GetMandateAuthResponseSenderTypeEnum;
    /**
     * Checklist of the authorization factors needed to complete Mandate authorization
     * @type {Array<AuthChecklistFactor>}
     * @memberof GetMandateAuthResponse
     */
    auth_checklist: Array<AuthChecklistFactor>;
    /**
     *
     * @type {MandateAuthEncryptionInfo}
     * @memberof GetMandateAuthResponse
     */
    encryption_info: MandateAuthEncryptionInfo;
    /**
     * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
     * @type {string}
     * @memberof GetMandateAuthResponse
     */
    last_update: string;
    /**
     *
     * @type {FvEmbeddedErrorModel}
     * @memberof GetMandateAuthResponse
     */
    error?: FvEmbeddedErrorModel;
    /**
     *
     * @type {MandateDetailsResponse}
     * @memberof GetMandateAuthResponse
     */
    mandate_details?: MandateDetailsResponse;
    /**
     *
     * @type {MandateRecipient}
     * @memberof GetMandateAuthResponse
     */
    recipient?: MandateRecipient;
}
export declare const GetMandateAuthResponseMandateStatusEnum: {
    readonly Created: "CREATED";
    readonly Processing: "PROCESSING";
    readonly Submitted: "SUBMITTED";
    readonly Error: "ERROR";
};
export type GetMandateAuthResponseMandateStatusEnum = (typeof GetMandateAuthResponseMandateStatusEnum)[keyof typeof GetMandateAuthResponseMandateStatusEnum];
export declare const GetMandateAuthResponseSenderTypeEnum: {
    readonly Individual: "INDIVIDUAL";
    readonly Business: "BUSINESS";
};
export type GetMandateAuthResponseSenderTypeEnum = (typeof GetMandateAuthResponseSenderTypeEnum)[keyof typeof GetMandateAuthResponseSenderTypeEnum];
/**
 *
 * @export
 * @interface GetMandateResponse
 */
export interface GetMandateResponse {
    /**
     * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
     * @type {string}
     * @memberof GetMandateResponse
     */
    created_at?: string;
    /**
     * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
     * @type {string}
     * @memberof GetMandateResponse
     */
    updated_at: string;
    /**
     * Finverse Mandate ID (ULID)
     * @type {string}
     * @memberof GetMandateResponse
     */
    mandate_id: string;
    /**
     * Finverse Payment Method ID (ULID)
     * @type {string}
     * @memberof GetMandateResponse
     */
    payment_method_id?: string;
    /**
     * Mandate Status
     * @type {string}
     * @memberof GetMandateResponse
     */
    status: GetMandateResponseStatusEnum;
    /**
     *
     * @type {MandateRecipient}
     * @memberof GetMandateResponse
     */
    recipient: MandateRecipient;
    /**
     *
     * @type {MandateRecipientAccount}
     * @memberof GetMandateResponse
     */
    recipient_account?: MandateRecipientAccount;
    /**
     *
     * @type {GetMandateSender}
     * @memberof GetMandateResponse
     */
    sender: GetMandateSender;
    /**
     *
     * @type {MandateSenderAccount}
     * @memberof GetMandateResponse
     */
    sender_account?: MandateSenderAccount;
    /**
     *
     * @type {MandateDetailsResponse}
     * @memberof GetMandateResponse
     */
    mandate_details: MandateDetailsResponse;
    /**
     *
     * @type {Array<Fee>}
     * @memberof GetMandateResponse
     */
    fees?: Array<Fee>;
    /**
     *
     * @type {FvEmbeddedErrorModel}
     * @memberof GetMandateResponse
     */
    error?: FvEmbeddedErrorModel;
    /**
     * Additional attributes of the mandate in key:value format (e.g. mandate_internal_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 1000 characters respectively.
     * @type {{ [key: string]: string; }}
     * @memberof GetMandateResponse
     */
    metadata?: {
        [key: string]: string;
    };
}
export declare const GetMandateResponseStatusEnum: {
    readonly AuthorizationRequired: "AUTHORIZATION_REQUIRED";
    readonly Authorizing: "AUTHORIZING";
    readonly Processing: "PROCESSING";
    readonly Submitted: "SUBMITTED";
    readonly Succeeded: "SUCCEEDED";
    readonly Failed: "FAILED";
    readonly Revoked: "REVOKED";
};
export type GetMandateResponseStatusEnum = (typeof GetMandateResponseStatusEnum)[keyof typeof GetMandateResponseStatusEnum];
/**
 *
 * @export
 * @interface GetMandateSender
 */
export interface GetMandateSender {
    /**
     * A unique identifier generated after creating sender
     * @type {string}
     * @memberof GetMandateSender
     */
    user_id: string;
    /**
     *
     * @type {string}
     * @memberof GetMandateSender
     */
    name?: string;
    /**
     * Customer App\'s user ID, representing the end-user making the payment.
     * @type {string}
     * @memberof GetMandateSender
     */
    external_user_id: string;
    /**
     * Type of account held by the Sender at the Institution. Possible values are INDIVIDUAL, BUSINESS
     * @type {string}
     * @memberof GetMandateSender
     */
    user_type: GetMandateSenderUserTypeEnum;
    /**
     * Sender details which will be used for fraud checking.
     * @type {Array<SenderDetail>}
     * @memberof GetMandateSender
     */
    user_details?: Array<SenderDetail>;
}
export declare const GetMandateSenderUserTypeEnum: {
    readonly Individual: "INDIVIDUAL";
    readonly Business: "BUSINESS";
};
export type GetMandateSenderUserTypeEnum = (typeof GetMandateSenderUserTypeEnum)[keyof typeof GetMandateSenderUserTypeEnum];
/**
 *
 * @export
 * @interface GetPaymentInstructionsResponse
 */
export interface GetPaymentInstructionsResponse {
    /**
     *
     * @type {PaymentInstruction}
     * @memberof GetPaymentInstructionsResponse
     */
    payment_instruction?: PaymentInstruction;
}
/**
 *
 * @export
 * @interface GetPaymentUserResponse
 */
export interface GetPaymentUserResponse {
    /**
     *
     * @type {string}
     * @memberof GetPaymentUserResponse
     */
    payment_user_id: string;
    /**
     *
     * @type {string}
     * @memberof GetPaymentUserResponse
     */
    customer_app_id: string;
    /**
     * The user\'s current autopay value
     * @type {boolean}
     * @memberof GetPaymentUserResponse
     */
    autopay_consent: boolean;
    /**
     * This indicates the value that the user\'s pre-set selection should be. If this is a new user, the value will be set to true by default, else it will be the user\'s current autopay value.
     * @type {boolean}
     * @memberof GetPaymentUserResponse
     */
    autopay_prefill: boolean;
}
/**
 *
 * @export
 * @interface GetStatementLinkResponse
 */
export interface GetStatementLinkResponse {
    /**
     *
     * @type {Array<StatementLink>}
     * @memberof GetStatementLinkResponse
     */
    statement_links?: Array<StatementLink>;
}
/**
 *
 * @export
 * @interface GetStatementsResponse
 */
export interface GetStatementsResponse {
    /**
     *
     * @type {Array<Statement>}
     * @memberof GetStatementsResponse
     */
    statements?: Array<Statement>;
    /**
     *
     * @type {LoginIdentityShort}
     * @memberof GetStatementsResponse
     */
    login_identity?: LoginIdentityShort;
    /**
     *
     * @type {InstitutionShort}
     * @memberof GetStatementsResponse
     */
    institution?: InstitutionShort;
}
/**
 *
 * @export
 * @interface Identity
 */
export interface Identity {
    /**
     *
     * @type {Array<IdentityName>}
     * @memberof Identity
     */
    names?: Array<IdentityName>;
    /**
     *
     * @type {Array<IdentityAddress>}
     * @memberof Identity
     */
    addresses?: Array<IdentityAddress>;
    /**
     *
     * @type {Array<IdentityEmail>}
     * @memberof Identity
     */
    emails?: Array<IdentityEmail>;
    /**
     *
     * @type {Array<IdentityPhoneNumber>}
     * @memberof Identity
     */
    phone_numbers?: Array<IdentityPhoneNumber>;
    /**
     *
     * @type {Array<IdentityDateOfBirth>}
     * @memberof Identity
     */
    date_of_births?: Array<IdentityDateOfBirth>;
}
/**
 *
 * @export
 * @interface IdentityAddress
 */
export interface IdentityAddress {
    /**
     *
     * @type {string}
     * @memberof IdentityAddress
     */
    raw?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityAddress
     */
    full_address?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityAddress
     */
    unit_number?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityAddress
     */
    floor_number?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityAddress
     */
    building_name?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityAddress
     */
    street_number?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityAddress
     */
    street_name?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityAddress
     */
    city?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityAddress
     */
    district?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityAddress
     */
    ward?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityAddress
     */
    street_address?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityAddress
     */
    province?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityAddress
     */
    country?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityAddress
     */
    postal_code?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityAddress
     */
    source?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof IdentityAddress
     */
    source_ids?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof IdentityAddress
     */
    account_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface IdentityDateOfBirth
 */
export interface IdentityDateOfBirth {
    /**
     *
     * @type {string}
     * @memberof IdentityDateOfBirth
     */
    raw?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityDateOfBirth
     */
    date_of_birth?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityDateOfBirth
     */
    masked_date_of_birth?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityDateOfBirth
     */
    source?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof IdentityDateOfBirth
     */
    source_ids?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof IdentityDateOfBirth
     */
    account_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface IdentityEmail
 */
export interface IdentityEmail {
    /**
     *
     * @type {string}
     * @memberof IdentityEmail
     */
    raw?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityEmail
     */
    email?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityEmail
     */
    masked_email?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityEmail
     */
    source?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof IdentityEmail
     */
    source_ids?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof IdentityEmail
     */
    account_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface IdentityName
 */
export interface IdentityName {
    /**
     *
     * @type {string}
     * @memberof IdentityName
     */
    raw?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityName
     */
    full_name?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityName
     */
    first_name?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityName
     */
    last_name?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityName
     */
    other_name?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityName
     */
    source?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof IdentityName
     */
    source_ids?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof IdentityName
     */
    account_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface IdentityPhoneNumber
 */
export interface IdentityPhoneNumber {
    /**
     *
     * @type {string}
     * @memberof IdentityPhoneNumber
     */
    raw?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityPhoneNumber
     */
    mobile_phone?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityPhoneNumber
     */
    other_phone?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityPhoneNumber
     */
    masked_phone?: string;
    /**
     *
     * @type {string}
     * @memberof IdentityPhoneNumber
     */
    source?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof IdentityPhoneNumber
     */
    source_ids?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof IdentityPhoneNumber
     */
    account_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface IncomeEstimate
 */
export interface IncomeEstimate {
    /**
     * Income amount
     * @type {number}
     * @memberof IncomeEstimate
     */
    amount: number;
    /**
     * Currency
     * @type {string}
     * @memberof IncomeEstimate
     */
    currency: string;
}
/**
 *
 * @export
 * @interface IncomeResponse
 */
export interface IncomeResponse {
    /**
     *
     * @type {Array<SingleSourceIncome>}
     * @memberof IncomeResponse
     */
    income: Array<SingleSourceIncome>;
    /**
     *
     * @type {LoginIdentityShort}
     * @memberof IncomeResponse
     */
    login_identity: LoginIdentityShort;
    /**
     *
     * @type {InstitutionShort}
     * @memberof IncomeResponse
     */
    institution: InstitutionShort;
}
/**
 *
 * @export
 * @interface IncomeStream
 */
export interface IncomeStream {
    /**
     * Account this income estimate is associated with
     * @type {string}
     * @memberof IncomeStream
     */
    account_id: string;
    /**
     *
     * @type {IncomeEstimate}
     * @memberof IncomeStream
     */
    estimated_monthly_income?: IncomeEstimate;
    /**
     * Number of transactions counted towards income
     * @type {number}
     * @memberof IncomeStream
     */
    transaction_count: number;
    /**
     *
     * @type {Array<MonthlyIncomeEstimate>}
     * @memberof IncomeStream
     */
    monthly_history: Array<MonthlyIncomeEstimate>;
}
/**
 *
 * @export
 * @interface IncomeTotal
 */
export interface IncomeTotal {
    /**
     *
     * @type {IncomeEstimate}
     * @memberof IncomeTotal
     */
    estimated_monthly_income?: IncomeEstimate;
    /**
     * Number of transactions counted towards income
     * @type {number}
     * @memberof IncomeTotal
     */
    transaction_count: number;
    /**
     *
     * @type {Array<MonthlyIncomeEstimate>}
     * @memberof IncomeTotal
     */
    monthly_history: Array<MonthlyIncomeEstimate>;
}
/**
 *
 * @export
 * @interface Institution
 */
export interface Institution {
    /**
     *
     * @type {string}
     * @memberof Institution
     */
    institution_id: string;
    /**
     *
     * @type {Array<string>}
     * @memberof Institution
     */
    countries: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof Institution
     */
    tags?: Array<InstitutionTagsEnum>;
    /**
     *
     * @type {string}
     * @memberof Institution
     */
    institution_type: InstitutionInstitutionTypeEnum;
    /**
     *
     * @type {Array<string>}
     * @memberof Institution
     */
    products_supported: Array<InstitutionProductsSupportedEnum>;
    /**
     *
     * @type {string}
     * @memberof Institution
     */
    parent_institution_name?: string;
    /**
     *
     * @type {string}
     * @memberof Institution
     */
    institution_name: string;
    /**
     *
     * @type {string}
     * @memberof Institution
     */
    portal_name?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof Institution
     */
    user_type: Array<InstitutionUserTypeEnum>;
    /**
     *
     * @type {string}
     * @memberof Institution
     */
    status: InstitutionStatusEnum;
    /**
     *
     * @type {object}
     * @memberof Institution
     */
    status_details?: object;
    /**
     *
     * @type {string}
     * @memberof Institution
     */
    login_url?: string;
    /**
     *
     * @type {object}
     * @memberof Institution
     */
    login_details: object;
    /**
     *
     * @type {Array<LoginMethod>}
     * @memberof Institution
     */
    login_methods?: Array<LoginMethod>;
    /**
     *
     * @type {PaymentInfo}
     * @memberof Institution
     */
    payment_info?: PaymentInfo;
    /**
     *
     * @type {string}
     * @memberof Institution
     */
    color?: string;
    /**
     *
     * @type {string}
     * @memberof Institution
     */
    updated_at?: string;
    /**
     *
     * @type {Array<LoginAction>}
     * @memberof Institution
     */
    login_actions?: Array<LoginAction>;
}
export declare const InstitutionTagsEnum: {
    readonly Real: "real";
    readonly Test: "test";
};
export type InstitutionTagsEnum = (typeof InstitutionTagsEnum)[keyof typeof InstitutionTagsEnum];
export declare const InstitutionInstitutionTypeEnum: {
    readonly Bank: "BANK";
    readonly Wallet: "WALLET";
    readonly Test: "TEST";
};
export type InstitutionInstitutionTypeEnum = (typeof InstitutionInstitutionTypeEnum)[keyof typeof InstitutionInstitutionTypeEnum];
export declare const InstitutionProductsSupportedEnum: {
    readonly Accounts: "ACCOUNTS";
    readonly Transactions: "TRANSACTIONS";
    readonly Statements: "STATEMENTS";
    readonly AccountNumbers: "ACCOUNT_NUMBERS";
    readonly Identity: "IDENTITY";
    readonly AutoDebitSetup: "AUTO_DEBIT_SETUP";
};
export type InstitutionProductsSupportedEnum = (typeof InstitutionProductsSupportedEnum)[keyof typeof InstitutionProductsSupportedEnum];
export declare const InstitutionUserTypeEnum: {
    readonly Personal: "PERSONAL";
    readonly Individual: "INDIVIDUAL";
    readonly Business: "BUSINESS";
};
export type InstitutionUserTypeEnum = (typeof InstitutionUserTypeEnum)[keyof typeof InstitutionUserTypeEnum];
export declare const InstitutionStatusEnum: {
    readonly Supported: "SUPPORTED";
    readonly Alpha: "ALPHA";
    readonly Beta: "BETA";
};
export type InstitutionStatusEnum = (typeof InstitutionStatusEnum)[keyof typeof InstitutionStatusEnum];
/**
 *
 * @export
 * @interface InstitutionShort
 */
export interface InstitutionShort {
    /**
     *
     * @type {string}
     * @memberof InstitutionShort
     */
    institution_id?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof InstitutionShort
     */
    countries?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof InstitutionShort
     */
    institution_name?: string;
    /**
     *
     * @type {string}
     * @memberof InstitutionShort
     */
    portal_name?: string;
}
/**
 *
 * @export
 * @interface IntegrationMetadataRequest
 */
export interface IntegrationMetadataRequest {
    /**
     *
     * @type {string}
     * @memberof IntegrationMetadataRequest
     */
    integration_id: IntegrationMetadataRequestIntegrationIdEnum;
    /**
     *
     * @type {RapidstorMetadataRequest}
     * @memberof IntegrationMetadataRequest
     */
    rapidstor_metadata?: RapidstorMetadataRequest;
}
export declare const IntegrationMetadataRequestIntegrationIdEnum: {
    readonly Rapidstor: "RAPIDSTOR";
};
export type IntegrationMetadataRequestIntegrationIdEnum = (typeof IntegrationMetadataRequestIntegrationIdEnum)[keyof typeof IntegrationMetadataRequestIntegrationIdEnum];
/**
 *
 * @export
 * @interface IntegrationMetadataResponse
 */
export interface IntegrationMetadataResponse {
    /**
     *
     * @type {string}
     * @memberof IntegrationMetadataResponse
     */
    integration_id?: IntegrationMetadataResponseIntegrationIdEnum;
    /**
     *
     * @type {RapidstorMetadataResponse}
     * @memberof IntegrationMetadataResponse
     */
    rapidstor_metadata?: RapidstorMetadataResponse;
}
export declare const IntegrationMetadataResponseIntegrationIdEnum: {
    readonly Rapidstor: "RAPIDSTOR";
};
export type IntegrationMetadataResponseIntegrationIdEnum = (typeof IntegrationMetadataResponseIntegrationIdEnum)[keyof typeof IntegrationMetadataResponseIntegrationIdEnum];
/**
 *
 * @export
 * @interface JWKSKey
 */
export interface JWKSKey {
    /**
     * The \"kty\" (key type) parameter identifies the cryptographic algorithm family used with the key, such as \"RSA\" or \"EC\".
     * @type {string}
     * @memberof JWKSKey
     */
    kty?: string;
    /**
     * The \"kid\" (key ID) parameter is used to match a specific key
     * @type {string}
     * @memberof JWKSKey
     */
    kid?: string;
    /**
     * The \"use\" (public key use) parameter identifies the intended use of the public key
     * @type {string}
     * @memberof JWKSKey
     */
    use?: string;
    /**
     * RSA key value \"e\"
     * @type {string}
     * @memberof JWKSKey
     */
    e?: string;
    /**
     * RSA key value \"n\"
     * @type {string}
     * @memberof JWKSKey
     */
    n?: string;
    /**
     * The \"x5c\" (X.509 certificate chain) parameter contains a chain of one or more PKIX certificates
     * @type {Array<string>}
     * @memberof JWKSKey
     */
    x5c?: Array<string>;
}
/**
 *
 * @export
 * @interface LineItem
 */
export interface LineItem {
    /**
     *
     * @type {string}
     * @memberof LineItem
     */
    currency?: string;
    /**
     * The amount in decimal
     * @type {string}
     * @memberof LineItem
     */
    amount?: string;
    /**
     *
     * @type {string}
     * @memberof LineItem
     */
    item_type?: LineItemItemTypeEnum;
}
export declare const LineItemItemTypeEnum: {
    readonly AmountDue: "AMOUNT_DUE";
    readonly Surcharge: "SURCHARGE";
    readonly Total: "TOTAL";
};
export type LineItemItemTypeEnum = (typeof LineItemItemTypeEnum)[keyof typeof LineItemItemTypeEnum];
/**
 *
 * @export
 * @interface LinkRequest
 */
export interface LinkRequest {
    /**
     *
     * @type {string}
     * @memberof LinkRequest
     */
    institution_id: string;
    /**
     *
     * @type {boolean}
     * @memberof LinkRequest
     */
    store_credential: boolean;
    /**
     * this is a mandatory field
     * @type {boolean}
     * @memberof LinkRequest
     */
    consent?: boolean | null;
    /**
     * products that is requested
     * @type {Array<string>}
     * @memberof LinkRequest
     */
    products_requested?: Array<string>;
    /**
     * The identifier returned after creating payment instruction
     * @type {string}
     * @memberof LinkRequest
     */
    payment_instruction_id?: string;
}
/**
 *
 * @export
 * @interface LinkResponse
 */
export interface LinkResponse {
    /**
     *
     * @type {string}
     * @memberof LinkResponse
     */
    auth_url?: string;
}
/**
 *
 * @export
 * @interface LinkStatusActionModel
 */
export interface LinkStatusActionModel {
    /**
     * Unique identifier
     * @type {string}
     * @memberof LinkStatusActionModel
     */
    action_id: string;
    /**
     * The type of user screen the UI is to render
     * @type {string}
     * @memberof LinkStatusActionModel
     */
    type: string;
    /**
     * The name of the user screen the UI is to render
     * @type {string}
     * @memberof LinkStatusActionModel
     */
    name: string;
    /**
     *
     * @type {Array<UserMessage>}
     * @memberof LinkStatusActionModel
     */
    messages: Array<UserMessage>;
    /**
     *
     * @type {Array<UserField>}
     * @memberof LinkStatusActionModel
     */
    fields: Array<UserField>;
    /**
     *
     * @type {Array<UserButton>}
     * @memberof LinkStatusActionModel
     */
    buttons?: Array<UserButton>;
}
/**
 *
 * @export
 * @interface LinkStatusPendingModel
 */
export interface LinkStatusPendingModel {
    /**
     *
     * @type {string}
     * @memberof LinkStatusPendingModel
     */
    code?: string;
    /**
     *
     * @type {string}
     * @memberof LinkStatusPendingModel
     */
    message?: string;
    /**
     *
     * @type {string}
     * @memberof LinkStatusPendingModel
     */
    details?: string;
}
/**
 *
 * @export
 * @interface LinkStatusResponse
 */
export interface LinkStatusResponse {
    /**
     *
     * @type {AccessTokenResponse}
     * @memberof LinkStatusResponse
     */
    success?: AccessTokenResponse;
    /**
     *
     * @type {LinkStatusPendingModel}
     * @memberof LinkStatusResponse
     */
    pending?: LinkStatusPendingModel;
    /**
     *
     * @type {LinkStatusActionModel}
     * @memberof LinkStatusResponse
     */
    action?: LinkStatusActionModel;
}
/**
 *
 * @export
 * @interface LinkTokenRequest
 */
export interface LinkTokenRequest {
    /**
     * support only client_credentials
     * @type {string}
     * @memberof LinkTokenRequest
     */
    grant_type: string;
    /**
     *
     * @type {string}
     * @memberof LinkTokenRequest
     */
    response_type: string;
    /**
     *
     * @type {string}
     * @memberof LinkTokenRequest
     */
    response_mode: string;
    /**
     * required when creating new Link, ignored when updating existing Link
     * @type {string}
     * @memberof LinkTokenRequest
     */
    user_id?: string;
    /**
     *
     * @type {string}
     * @memberof LinkTokenRequest
     */
    client_id: string;
    /**
     *
     * @type {string}
     * @memberof LinkTokenRequest
     */
    redirect_uri: string;
    /**
     *
     * @type {string}
     * @memberof LinkTokenRequest
     */
    state?: string;
    /**
     *
     * @type {string}
     * @memberof LinkTokenRequest
     */
    scope?: string;
    /**
     * Space separated list of the tags of the institutions to view.
     * @type {string}
     * @memberof LinkTokenRequest
     */
    link_mode?: string;
    /**
     * The UI mode link is intended to be used in - \"iframe\", \"auto_redirect\", \"redirect\" or \"standalone\"
     * @type {string}
     * @memberof LinkTokenRequest
     */
    ui_mode?: LinkTokenRequestUiModeEnum;
    /**
     * ISO639-1 language code. Language to display when user open the link, default to English (en) if not specified
     * @type {string}
     * @memberof LinkTokenRequest
     */
    language?: LinkTokenRequestLanguageEnum;
    /**
     *
     * @type {string}
     * @memberof LinkTokenRequest
     */
    code_challenge?: string;
    /**
     *
     * @type {string}
     * @memberof LinkTokenRequest
     */
    code_challenge_method?: string;
    /**
     * use this to update a specific login identity
     * @type {string}
     * @memberof LinkTokenRequest
     */
    login_identity_id?: string;
    /**
     * The customization id if the customer wishes to embed it into link token for spawning link with their choice of stuffs
     * @type {string}
     * @memberof LinkTokenRequest
     */
    customization_id?: string;
    /**
     * Institution to preselect
     * @type {string}
     * @memberof LinkTokenRequest
     */
    institution_id?: string;
    /**
     * institution\'s country filter
     * @type {Array<string>}
     * @memberof LinkTokenRequest
     */
    countries?: Array<string>;
    /**
     * institution\'s supported user_type filter
     * @type {Array<string>}
     * @memberof LinkTokenRequest
     */
    user_type?: Array<string>;
    /**
     * institution\'s supported product filter
     * @type {Array<string>}
     * @memberof LinkTokenRequest
     */
    products_supported?: Array<string>;
    /**
     * products that is requested
     * @type {Array<string>}
     * @memberof LinkTokenRequest
     */
    products_requested?: Array<string>;
    /**
     * The identifier returned after creating payment instruction
     * @type {string}
     * @memberof LinkTokenRequest
     */
    payment_instruction_id?: string;
    /**
     * Controls the behavior of the automatic data refresh checkbox
     * @type {string}
     * @memberof LinkTokenRequest
     */
    automatic_data_refresh?: LinkTokenRequestAutomaticDataRefreshEnum;
    /**
     * institution\'s status filter
     * @type {string}
     * @memberof LinkTokenRequest
     */
    institution_status?: string;
    /**
     *
     * @type {LinkTokenUserConfigs}
     * @memberof LinkTokenRequest
     */
    user_configs?: LinkTokenUserConfigs;
}
export declare const LinkTokenRequestUiModeEnum: {
    readonly Iframe: "iframe";
    readonly Redirect: "redirect";
    readonly AutoRedirect: "auto_redirect";
    readonly Standalone: "standalone";
};
export type LinkTokenRequestUiModeEnum = (typeof LinkTokenRequestUiModeEnum)[keyof typeof LinkTokenRequestUiModeEnum];
export declare const LinkTokenRequestLanguageEnum: {
    readonly En: "en";
    readonly Vi: "vi";
    readonly Zh: "zh";
};
export type LinkTokenRequestLanguageEnum = (typeof LinkTokenRequestLanguageEnum)[keyof typeof LinkTokenRequestLanguageEnum];
export declare const LinkTokenRequestAutomaticDataRefreshEnum: {
    readonly On: "ON";
    readonly Off: "OFF";
    readonly ForcedOn: "FORCED_ON";
};
export type LinkTokenRequestAutomaticDataRefreshEnum = (typeof LinkTokenRequestAutomaticDataRefreshEnum)[keyof typeof LinkTokenRequestAutomaticDataRefreshEnum];
/**
 *
 * @export
 * @interface LinkTokenResponse
 */
export interface LinkTokenResponse {
    /**
     *
     * @type {string}
     * @memberof LinkTokenResponse
     */
    access_token: string;
    /**
     *
     * @type {string}
     * @memberof LinkTokenResponse
     */
    token_type: string;
    /**
     * seconds
     * @type {number}
     * @memberof LinkTokenResponse
     */
    expires_in: number;
    /**
     *
     * @type {string}
     * @memberof LinkTokenResponse
     */
    issued_at: string;
    /**
     *
     * @type {string}
     * @memberof LinkTokenResponse
     */
    link_url: string;
}
/**
 *
 * @export
 * @interface LinkTokenUserConfigs
 */
export interface LinkTokenUserConfigs {
    /**
     * Account Number to use for ADA setup
     * @type {string}
     * @memberof LinkTokenUserConfigs
     */
    ada_account_number?: string;
}
/**
 *
 * @export
 * @interface ListAccountsResponse
 */
export interface ListAccountsResponse {
    /**
     *
     * @type {Array<Account>}
     * @memberof ListAccountsResponse
     */
    accounts?: Array<Account>;
    /**
     *
     * @type {LoginIdentityShort}
     * @memberof ListAccountsResponse
     */
    login_identity?: LoginIdentityShort;
    /**
     *
     * @type {InstitutionShort}
     * @memberof ListAccountsResponse
     */
    institution?: InstitutionShort;
}
/**
 *
 * @export
 * @interface ListCardsDetailsResponse
 */
export interface ListCardsDetailsResponse {
    /**
     *
     * @type {LoginIdentityShort}
     * @memberof ListCardsDetailsResponse
     */
    login_identity?: LoginIdentityShort;
    /**
     *
     * @type {InstitutionShort}
     * @memberof ListCardsDetailsResponse
     */
    institution?: InstitutionShort;
    /**
     *
     * @type {CardDetails}
     * @memberof ListCardsDetailsResponse
     */
    card_details?: CardDetails;
}
/**
 *
 * @export
 * @interface ListDisputesResponse
 */
export interface ListDisputesResponse {
    /**
     *
     * @type {Array<DisputeResponse>}
     * @memberof ListDisputesResponse
     */
    disputes: Array<DisputeResponse>;
    /**
     *
     * @type {number}
     * @memberof ListDisputesResponse
     */
    total_disputes: number;
}
/**
 *
 * @export
 * @interface ListMandatesResponse
 */
export interface ListMandatesResponse {
    /**
     *
     * @type {Array<GetMandateResponse>}
     * @memberof ListMandatesResponse
     */
    mandates?: Array<GetMandateResponse>;
    /**
     *
     * @type {number}
     * @memberof ListMandatesResponse
     */
    total_mandates: number;
}
/**
 *
 * @export
 * @interface ListPaymentAccountsResponse
 */
export interface ListPaymentAccountsResponse {
    /**
     *
     * @type {Array<PaymentAccountDetails>}
     * @memberof ListPaymentAccountsResponse
     */
    payment_accounts?: Array<PaymentAccountDetails>;
}
/**
 *
 * @export
 * @interface ListPaymentAccountsWithEnrichedDataResponse
 */
export interface ListPaymentAccountsWithEnrichedDataResponse {
    /**
     *
     * @type {Array<PaymentAccountDetailsWithEnrichedData>}
     * @memberof ListPaymentAccountsWithEnrichedDataResponse
     */
    payment_accounts?: Array<PaymentAccountDetailsWithEnrichedData>;
    /**
     * Total number of matching payment accounts
     * @type {number}
     * @memberof ListPaymentAccountsWithEnrichedDataResponse
     */
    total?: number;
}
/**
 *
 * @export
 * @interface ListPaymentMethodsResponse
 */
export interface ListPaymentMethodsResponse {
    /**
     *
     * @type {Array<PaymentMethodResponse>}
     * @memberof ListPaymentMethodsResponse
     */
    payment_methods?: Array<PaymentMethodResponse>;
    /**
     *
     * @type {PaymentUserWithoutEmail}
     * @memberof ListPaymentMethodsResponse
     */
    sender?: PaymentUserWithoutEmail;
}
/**
 *
 * @export
 * @interface ListPaymentsResponse
 */
export interface ListPaymentsResponse {
    /**
     *
     * @type {Array<PaymentResponse>}
     * @memberof ListPaymentsResponse
     */
    payments?: Array<PaymentResponse>;
    /**
     *
     * @type {number}
     * @memberof ListPaymentsResponse
     */
    total_payments: number;
}
/**
 *
 * @export
 * @interface ListPayoutsResponse
 */
export interface ListPayoutsResponse {
    /**
     *
     * @type {Array<PayoutSnapshotResponse>}
     * @memberof ListPayoutsResponse
     */
    payouts: Array<PayoutSnapshotResponse>;
    /**
     *
     * @type {number}
     * @memberof ListPayoutsResponse
     */
    total_payouts: number;
}
/**
 *
 * @export
 * @interface ListTransactionsResponse
 */
export interface ListTransactionsResponse {
    /**
     *
     * @type {Array<Account>}
     * @memberof ListTransactionsResponse
     */
    accounts?: Array<Account>;
    /**
     *
     * @type {Array<Transaction>}
     * @memberof ListTransactionsResponse
     */
    transactions?: Array<Transaction>;
    /**
     *
     * @type {LoginIdentityShort}
     * @memberof ListTransactionsResponse
     */
    login_identity?: LoginIdentityShort;
    /**
     *
     * @type {InstitutionShort}
     * @memberof ListTransactionsResponse
     */
    institution?: InstitutionShort;
    /**
     *
     * @type {number}
     * @memberof ListTransactionsResponse
     */
    total_transactions: number;
}
/**
 *
 * @export
 * @interface LoginAction
 */
export interface LoginAction {
    /**
     *
     * @type {string}
     * @memberof LoginAction
     */
    type?: string;
    /**
     *
     * @type {string}
     * @memberof LoginAction
     */
    name?: string;
    /**
     *
     * @type {Array<UserMessage>}
     * @memberof LoginAction
     */
    messages?: Array<UserMessage>;
    /**
     *
     * @type {Array<UserField>}
     * @memberof LoginAction
     */
    fields?: Array<UserField>;
    /**
     *
     * @type {Array<UserButton>}
     * @memberof LoginAction
     */
    buttons?: Array<UserButton>;
}
/**
 *
 * @export
 * @interface LoginField
 */
export interface LoginField {
    /**
     *
     * @type {string}
     * @memberof LoginField
     */
    key?: string;
    /**
     *
     * @type {string}
     * @memberof LoginField
     */
    name?: string;
    /**
     * could be password, text, number
     * @type {string}
     * @memberof LoginField
     */
    type?: string;
}
/**
 *
 * @export
 * @interface LoginIdentity
 */
export interface LoginIdentity {
    /**
     *
     * @type {string}
     * @memberof LoginIdentity
     */
    login_identity_id?: string;
    /**
     *
     * @type {string}
     * @memberof LoginIdentity
     */
    customer_app_id: string;
    /**
     *
     * @type {string}
     * @memberof LoginIdentity
     */
    user_id: string;
    /**
     *
     * @type {LoginIdentityLoginMethodsAvailable}
     * @memberof LoginIdentity
     */
    login_methods_available?: LoginIdentityLoginMethodsAvailable;
    /**
     *
     * @type {string}
     * @memberof LoginIdentity
     */
    permissions_grant_date?: string;
    /**
     *
     * @type {string}
     * @memberof LoginIdentity
     */
    permissions_expiry_date?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof LoginIdentity
     */
    permissions?: Array<string>;
    /**
     *
     * @type {LoginIdentityBillingDetails}
     * @memberof LoginIdentity
     */
    billing_details?: LoginIdentityBillingDetails;
    /**
     *
     * @type {string}
     * @memberof LoginIdentity
     */
    status?: string;
    /**
     *
     * @type {LoginIdentityStatusDetails}
     * @memberof LoginIdentity
     */
    status_details?: LoginIdentityStatusDetails;
    /**
     *
     * @type {AllProductStatus}
     * @memberof LoginIdentity
     */
    product_status?: AllProductStatus;
    /**
     *
     * @type {ProductStatus}
     * @memberof LoginIdentity
     */
    authentication_status?: ProductStatus;
    /**
     *
     * @type {LoginIdentityError}
     * @memberof LoginIdentity
     */
    error?: LoginIdentityError;
    /**
     *
     * @type {string}
     * @memberof LoginIdentity
     */
    last_success?: string;
    /**
     *
     * @type {string}
     * @memberof LoginIdentity
     */
    first_success?: string;
    /**
     *
     * @type {string}
     * @memberof LoginIdentity
     */
    webhook?: string;
    /**
     *
     * @type {string}
     * @memberof LoginIdentity
     */
    session_status?: string;
    /**
     *
     * @type {string}
     * @memberof LoginIdentity
     */
    institution_id: string;
    /**
     *
     * @type {string}
     * @memberof LoginIdentity
     */
    created_at?: string;
    /**
     *
     * @type {string}
     * @memberof LoginIdentity
     */
    updated_at?: string;
    /**
     * a login attempt id which is unique per login_identity
     * @type {string}
     * @memberof LoginIdentity
     */
    linking_attempt_id?: string;
    /**
     * a successful login attempt id which is unique per login_identity
     * @type {string}
     * @memberof LoginIdentity
     */
    authentication_id?: string;
    /**
     *
     * @type {string}
     * @memberof LoginIdentity
     */
    last_session_id?: string;
    /**
     *
     * @type {RefreshData}
     * @memberof LoginIdentity
     */
    refresh?: RefreshData;
}
/**
 *
 * @export
 * @interface LoginIdentityBillingDetails
 */
export interface LoginIdentityBillingDetails {
    /**
     *
     * @type {Array<string>}
     * @memberof LoginIdentityBillingDetails
     */
    billed_products?: Array<string>;
}
/**
 *
 * @export
 * @interface LoginIdentityError
 */
export interface LoginIdentityError {
    /**
     *
     * @type {number}
     * @memberof LoginIdentityError
     */
    code?: number;
    /**
     *
     * @type {string}
     * @memberof LoginIdentityError
     */
    type?: string;
    /**
     *
     * @type {string}
     * @memberof LoginIdentityError
     */
    message?: string;
    /**
     *
     * @type {string}
     * @memberof LoginIdentityError
     */
    details?: string;
}
/**
 *
 * @export
 * @interface LoginIdentityLoginMethodsAvailable
 */
export interface LoginIdentityLoginMethodsAvailable {
    /**
     *
     * @type {boolean}
     * @memberof LoginIdentityLoginMethodsAvailable
     */
    havePassword?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof LoginIdentityLoginMethodsAvailable
     */
    haveSecret?: boolean;
}
/**
 *
 * @export
 * @interface LoginIdentityShort
 */
export interface LoginIdentityShort {
    /**
     *
     * @type {string}
     * @memberof LoginIdentityShort
     */
    login_identity_id?: string;
    /**
     *
     * @type {string}
     * @memberof LoginIdentityShort
     */
    status?: string;
    /**
     *
     * @type {string}
     * @memberof LoginIdentityShort
     */
    last_session_id?: string;
}
/**
 *
 * @export
 * @interface LoginIdentityStatusDetails
 */
export interface LoginIdentityStatusDetails {
    /**
     *
     * @type {string}
     * @memberof LoginIdentityStatusDetails
     */
    event_date?: string;
    /**
     *
     * @type {string}
     * @memberof LoginIdentityStatusDetails
     */
    event_name?: string;
}
/**
 *
 * @export
 * @interface LoginMethod
 */
export interface LoginMethod {
    /**
     *
     * @type {string}
     * @memberof LoginMethod
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof LoginMethod
     */
    name?: string;
    /**
     *
     * @type {boolean}
     * @memberof LoginMethod
     */
    is_default_method?: boolean | null;
    /**
     *
     * @type {string}
     * @memberof LoginMethod
     */
    status?: LoginMethodStatusEnum;
    /**
     *
     * @type {Array<LoginField>}
     * @memberof LoginMethod
     */
    login_fields?: Array<LoginField>;
}
export declare const LoginMethodStatusEnum: {
    readonly Supported: "SUPPORTED";
    readonly Alpha: "ALPHA";
    readonly Beta: "BETA";
};
export type LoginMethodStatusEnum = (typeof LoginMethodStatusEnum)[keyof typeof LoginMethodStatusEnum];
/**
 *
 * @export
 * @interface MandateAuthEncryptionInfo
 */
export interface MandateAuthEncryptionInfo {
    /**
     *
     * @type {string}
     * @memberof MandateAuthEncryptionInfo
     */
    jwks_url: string;
    /**
     *
     * @type {string}
     * @memberof MandateAuthEncryptionInfo
     */
    key_id: string;
}
/**
 *
 * @export
 * @interface MandateAuthLinkCustomizations
 */
export interface MandateAuthLinkCustomizations {
    /**
     * institution\'s country filter
     * @type {Array<string>}
     * @memberof MandateAuthLinkCustomizations
     */
    countries?: Array<string>;
    /**
     * Institution to preselect
     * @type {string}
     * @memberof MandateAuthLinkCustomizations
     */
    institution_id?: string;
    /**
     * institution\'s status filter
     * @type {string}
     * @memberof MandateAuthLinkCustomizations
     */
    institution_status?: string;
    /**
     * ISO639-1 language code. Language to display when user open the link, default to English (en) if not specified
     * @type {string}
     * @memberof MandateAuthLinkCustomizations
     */
    language?: MandateAuthLinkCustomizationsLanguageEnum;
    /**
     * Space separated list of the tags of the institutions to view.
     * @type {string}
     * @memberof MandateAuthLinkCustomizations
     */
    link_mode?: string;
    /**
     * institution\'s supported product filter. For mandate authorization, this field should contain [\"MANDATE\"]
     * @type {Array<string>}
     * @memberof MandateAuthLinkCustomizations
     */
    products_supported?: Array<string>;
    /**
     * The UI mode link is intended to be used in - \"iframe\", \"auto_redirect\", \"redirect\" or \"standalone\"
     * @type {string}
     * @memberof MandateAuthLinkCustomizations
     */
    ui_mode?: MandateAuthLinkCustomizationsUiModeEnum;
    /**
     * The URI to redirect to. Required if ui_mode is \"redirect\" or \"auto_redirect\"
     * @type {string}
     * @memberof MandateAuthLinkCustomizations
     */
    redirect_uri?: string;
    /**
     * institution\'s supported user_type filter
     * @type {Array<string>}
     * @memberof MandateAuthLinkCustomizations
     */
    user_type?: Array<string>;
}
export declare const MandateAuthLinkCustomizationsLanguageEnum: {
    readonly En: "en";
    readonly Vi: "vi";
    readonly Zh: "zh";
};
export type MandateAuthLinkCustomizationsLanguageEnum = (typeof MandateAuthLinkCustomizationsLanguageEnum)[keyof typeof MandateAuthLinkCustomizationsLanguageEnum];
export declare const MandateAuthLinkCustomizationsUiModeEnum: {
    readonly Iframe: "iframe";
    readonly Redirect: "redirect";
    readonly AutoRedirect: "auto_redirect";
    readonly Standalone: "standalone";
};
export type MandateAuthLinkCustomizationsUiModeEnum = (typeof MandateAuthLinkCustomizationsUiModeEnum)[keyof typeof MandateAuthLinkCustomizationsUiModeEnum];
/**
 *
 * @export
 * @interface MandateDetailsForPaymentLink
 */
export interface MandateDetailsForPaymentLink {
    /**
     * YYYY-MM-DD, must be later than or the same as the date of creation. If unspecified, default to the date of creation.
     * @type {string}
     * @memberof MandateDetailsForPaymentLink
     */
    start_date?: string | null;
    /**
     * YYYY-MM-DD, must be later than the date of creation.
     * @type {string}
     * @memberof MandateDetailsForPaymentLink
     */
    end_date?: string | null;
    /**
     *
     * @type {TransactionLimits}
     * @memberof MandateDetailsForPaymentLink
     */
    transaction_limits?: TransactionLimits;
    /**
     * End-user facing description of the mandate (used in notifications, and in payments if no description is provided)
     * @type {string}
     * @memberof MandateDetailsForPaymentLink
     */
    description?: string;
}
/**
 *
 * @export
 * @interface MandateDetailsRequest
 */
export interface MandateDetailsRequest {
    /**
     * ISO currency code
     * @type {string}
     * @memberof MandateDetailsRequest
     */
    currency: string;
    /**
     * YYYY-MM-DD, must be later than or the same as the date of creation. If unspecified, default to the date of creation.
     * @type {string}
     * @memberof MandateDetailsRequest
     */
    start_date?: string | null;
    /**
     * YYYY-MM-DD, must be later than the date of creation.
     * @type {string}
     * @memberof MandateDetailsRequest
     */
    end_date?: string | null;
    /**
     *
     * @type {PaymentSchedule}
     * @memberof MandateDetailsRequest
     */
    payment_schedule?: PaymentSchedule;
    /**
     *
     * @type {TransactionLimits}
     * @memberof MandateDetailsRequest
     */
    transaction_limits?: TransactionLimits;
    /**
     * End-user facing description of the mandate (used in notifications, and in payments if no description is provided)
     * @type {string}
     * @memberof MandateDetailsRequest
     */
    description?: string;
    /**
     * A bank specific reference, what the end user may see
     * @type {string}
     * @memberof MandateDetailsRequest
     */
    mandate_bank_reference?: string;
}
/**
 *
 * @export
 * @interface MandateDetailsRequestWithDdaReference
 */
export interface MandateDetailsRequestWithDdaReference {
    /**
     * The direct debit authorization reference
     * @type {string}
     * @memberof MandateDetailsRequestWithDdaReference
     */
    dda_reference?: string;
    /**
     * ISO currency code
     * @type {string}
     * @memberof MandateDetailsRequestWithDdaReference
     */
    currency: string;
    /**
     * YYYY-MM-DD, must be later than or the same as the date of creation. If unspecified, default to the date of creation.
     * @type {string}
     * @memberof MandateDetailsRequestWithDdaReference
     */
    start_date?: string | null;
    /**
     * YYYY-MM-DD, must be later than the date of creation.
     * @type {string}
     * @memberof MandateDetailsRequestWithDdaReference
     */
    end_date?: string | null;
    /**
     *
     * @type {TransactionLimits}
     * @memberof MandateDetailsRequestWithDdaReference
     */
    transaction_limits?: TransactionLimits;
    /**
     * End-user facing description of the mandate (used in notifications, and in payments if no description is provided)
     * @type {string}
     * @memberof MandateDetailsRequestWithDdaReference
     */
    description: string;
}
/**
 *
 * @export
 * @interface MandateDetailsResponse
 */
export interface MandateDetailsResponse {
    /**
     * The direct debit authorization reference, if empty this will be omitted from response
     * @type {string}
     * @memberof MandateDetailsResponse
     */
    dda_reference?: string;
    /**
     * ISO currency code
     * @type {string}
     * @memberof MandateDetailsResponse
     */
    currency: string;
    /**
     * YYYY-MM-DD, must be later than or the same as the date of creation. If unspecified, default to the date of creation.
     * @type {string}
     * @memberof MandateDetailsResponse
     */
    start_date?: string | null;
    /**
     * YYYY-MM-DD, must be later than the date of creation.
     * @type {string}
     * @memberof MandateDetailsResponse
     */
    end_date?: string | null;
    /**
     *
     * @type {PaymentSchedule}
     * @memberof MandateDetailsResponse
     */
    payment_schedule?: PaymentSchedule;
    /**
     *
     * @type {TransactionLimits}
     * @memberof MandateDetailsResponse
     */
    transaction_limits?: TransactionLimits;
    /**
     * End-user facing description of the mandate (used in notifications, and in payments if no description is provided)
     * @type {string}
     * @memberof MandateDetailsResponse
     */
    description?: string;
    /**
     * A bank specific reference, what the end user may see
     * @type {string}
     * @memberof MandateDetailsResponse
     */
    mandate_bank_reference?: string;
    /**
     *
     * @type {string}
     * @memberof MandateDetailsResponse
     */
    processor_entity_name?: string;
    /**
     *
     * @type {string}
     * @memberof MandateDetailsResponse
     */
    collection_entity_name?: string;
}
/**
 *
 * @export
 * @interface MandateFvLinkDetails
 */
export interface MandateFvLinkDetails {
    /**
     *
     * @type {string}
     * @memberof MandateFvLinkDetails
     */
    collection_entity_name?: string;
}
/**
 *
 * @export
 * @interface MandateFvLinkResponse
 */
export interface MandateFvLinkResponse {
    /**
     *
     * @type {string}
     * @memberof MandateFvLinkResponse
     */
    mandate_id?: string;
    /**
     *
     * @type {string}
     * @memberof MandateFvLinkResponse
     */
    institution_id?: string;
    /**
     *
     * @type {string}
     * @memberof MandateFvLinkResponse
     */
    mandate_status?: string;
    /**
     *
     * @type {MandateRecipient}
     * @memberof MandateFvLinkResponse
     */
    recipient?: MandateRecipient;
    /**
     *
     * @type {SenderAccountFvLinkResponse}
     * @memberof MandateFvLinkResponse
     */
    sender_account?: SenderAccountFvLinkResponse;
    /**
     *
     * @type {FvEmbeddedErrorModel}
     * @memberof MandateFvLinkResponse
     */
    error?: FvEmbeddedErrorModel;
    /**
     *
     * @type {MandateFvLinkDetails}
     * @memberof MandateFvLinkResponse
     */
    mandate_details?: MandateFvLinkDetails;
}
/**
 *
 * @export
 * @interface MandateRecipient
 */
export interface MandateRecipient {
    /**
     * Merchant account name
     * @type {string}
     * @memberof MandateRecipient
     */
    name: string;
}
/**
 *
 * @export
 * @interface MandateRecipientAccount
 */
export interface MandateRecipientAccount {
    /**
     * Merchant account ID assigned by Finverse
     * @type {string}
     * @memberof MandateRecipientAccount
     */
    account_id: string;
    /**
     * Type of recipient account.
     * @type {string}
     * @memberof MandateRecipientAccount
     */
    account_type: MandateRecipientAccountAccountTypeEnum;
}
export declare const MandateRecipientAccountAccountTypeEnum: {
    readonly ExternalAccount: "EXTERNAL_ACCOUNT";
    readonly SettlementAccount: "SETTLEMENT_ACCOUNT";
};
export type MandateRecipientAccountAccountTypeEnum = (typeof MandateRecipientAccountAccountTypeEnum)[keyof typeof MandateRecipientAccountAccountTypeEnum];
/**
 *
 * @export
 * @interface MandateRecipientRequest
 */
export interface MandateRecipientRequest {
    /**
     * Merchant account ID assigned by Finverse
     * @type {string}
     * @memberof MandateRecipientRequest
     */
    account_id: string;
}
/**
 *
 * @export
 * @interface MandateSenderAccount
 */
export interface MandateSenderAccount {
    /**
     * A unique identifier generated after creating sender account
     * @type {string}
     * @memberof MandateSenderAccount
     */
    account_id?: string;
    /**
     * Tokenized accountholder name of the sender\'s account
     * @type {string}
     * @memberof MandateSenderAccount
     */
    accountholder_name?: string;
    /**
     * Accountholder name of the sender\'s account in plain text
     * @type {string}
     * @memberof MandateSenderAccount
     */
    accountholder_name_plaintext?: string | null;
    /**
     *
     * @type {RecipientAccountNumber}
     * @memberof MandateSenderAccount
     */
    account_number?: RecipientAccountNumber;
    /**
     * Masked Account number of the sender’s account
     * @type {string}
     * @memberof MandateSenderAccount
     */
    account_number_masked?: string;
    /**
     * Type of sender account.
     * @type {string}
     * @memberof MandateSenderAccount
     */
    account_type?: MandateSenderAccountAccountTypeEnum;
    /**
     * Finverse Institution ID for the sender’s institution.
     * @type {string}
     * @memberof MandateSenderAccount
     */
    institution_id?: string;
    /**
     * Institution Name for the sender’s institution.
     * @type {string}
     * @memberof MandateSenderAccount
     */
    institution_name?: string;
    /**
     * A unique identifier generated after creating sender (Finverse Payment User ID)
     * @type {string}
     * @memberof MandateSenderAccount
     */
    user_id?: string;
    /**
     *
     * @type {string}
     * @memberof MandateSenderAccount
     */
    bank_code?: string;
    /**
     * Additional attributes of the sender account in key:value format (e.g. sender_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 1000 characters respectively.
     * @type {{ [key: string]: string; }}
     * @memberof MandateSenderAccount
     */
    metadata?: {
        [key: string]: string;
    };
}
export declare const MandateSenderAccountAccountTypeEnum: {
    readonly ExternalAccount: "EXTERNAL_ACCOUNT";
};
export type MandateSenderAccountAccountTypeEnum = (typeof MandateSenderAccountAccountTypeEnum)[keyof typeof MandateSenderAccountAccountTypeEnum];
/**
 *
 * @export
 * @interface MandateSenderAccountRequest
 */
export interface MandateSenderAccountRequest {
    /**
     * account ID assigned by Finverse
     * @type {string}
     * @memberof MandateSenderAccountRequest
     */
    account_id: string;
}
/**
 *
 * @export
 * @interface ManualPaymentConfirmationRequest
 */
export interface ManualPaymentConfirmationRequest {
    /**
     * Required if manual payment provider is HK_FPS. Not required for SG_PAYNOW
     * @type {string}
     * @memberof ManualPaymentConfirmationRequest
     */
    accountholder_name?: string;
}
/**
 *
 * @export
 * @interface ManualPaymentConfirmationResponse
 */
export interface ManualPaymentConfirmationResponse {
    /**
     *
     * @type {string}
     * @memberof ManualPaymentConfirmationResponse
     */
    payment_id?: string;
    /**
     *
     * @type {string}
     * @memberof ManualPaymentConfirmationResponse
     */
    status?: ManualPaymentConfirmationResponseStatusEnum;
}
export declare const ManualPaymentConfirmationResponseStatusEnum: {
    readonly AuthorizationRequired: "AUTHORIZATION_REQUIRED";
    readonly Authorizing: "AUTHORIZING";
    readonly Processing: "PROCESSING";
    readonly Submitted: "SUBMITTED";
    readonly Executed: "EXECUTED";
    readonly Failed: "FAILED";
    readonly Revoked: "REVOKED";
    readonly Cancelled: "CANCELLED";
    readonly Created: "CREATED";
};
export type ManualPaymentConfirmationResponseStatusEnum = (typeof ManualPaymentConfirmationResponseStatusEnum)[keyof typeof ManualPaymentConfirmationResponseStatusEnum];
/**
 *
 * @export
 * @interface MonthlyIncomeEstimate
 */
export interface MonthlyIncomeEstimate {
    /**
     *
     * @type {IncomeEstimate}
     * @memberof MonthlyIncomeEstimate
     */
    estimated_income: IncomeEstimate;
    /**
     * The numeric month
     * @type {number}
     * @memberof MonthlyIncomeEstimate
     */
    month: number;
    /**
     * The year
     * @type {number}
     * @memberof MonthlyIncomeEstimate
     */
    year: number;
}
/**
 *
 * @export
 * @interface NonSensitiveLinkStatusResponse
 */
export interface NonSensitiveLinkStatusResponse {
    /**
     *
     * @type {LinkStatusActionModel}
     * @memberof NonSensitiveLinkStatusResponse
     */
    action?: LinkStatusActionModel;
    /**
     *
     * @type {string}
     * @memberof NonSensitiveLinkStatusResponse
     */
    redirect_uri?: string;
    /**
     *
     * @type {NonSensitiveLinkStatusSuccessModel}
     * @memberof NonSensitiveLinkStatusResponse
     */
    success?: NonSensitiveLinkStatusSuccessModel;
    /**
     *
     * @type {FvErrorModelV2}
     * @memberof NonSensitiveLinkStatusResponse
     */
    error?: FvErrorModelV2;
}
/**
 *
 * @export
 * @interface NonSensitiveLinkStatusSuccessModel
 */
export interface NonSensitiveLinkStatusSuccessModel {
    /**
     *
     * @type {string}
     * @memberof NonSensitiveLinkStatusSuccessModel
     */
    code?: string;
    /**
     *
     * @type {string}
     * @memberof NonSensitiveLinkStatusSuccessModel
     */
    state?: string;
    /**
     *
     * @type {string}
     * @memberof NonSensitiveLinkStatusSuccessModel
     */
    login_identity_id?: string;
}
/**
 *
 * @export
 * @interface OtherInfo
 */
export interface OtherInfo {
    /**
     *
     * @type {string}
     * @memberof OtherInfo
     */
    bank_code?: string;
}
/**
 *
 * @export
 * @interface PaymentAccount
 */
export interface PaymentAccount {
    /**
     * The raw value for the account the user selected when making payment request
     * @type {string}
     * @memberof PaymentAccount
     */
    raw?: string;
    /**
     * Finverse Institution ID. Only returned if institution_id was included in the request.
     * @type {string}
     * @memberof PaymentAccount
     */
    institution_id?: string;
}
/**
 *
 * @export
 * @interface PaymentAccountDetails
 */
export interface PaymentAccountDetails {
    /**
     * Payment account id
     * @type {string}
     * @memberof PaymentAccountDetails
     */
    account_id?: string;
    /**
     *
     * @type {RecipientAccountNumber}
     * @memberof PaymentAccountDetails
     */
    account_number?: RecipientAccountNumber;
    /**
     * Masked Account number of the payment account
     * @type {string}
     * @memberof PaymentAccountDetails
     */
    account_number_masked?: string;
    /**
     * Type of payment account.
     * @type {string}
     * @memberof PaymentAccountDetails
     */
    account_type?: PaymentAccountDetailsAccountTypeEnum;
    /**
     * Accountholder name of the payment account
     * @type {string}
     * @memberof PaymentAccountDetails
     */
    accountholder_name?: string;
    /**
     * The customer app ID
     * @type {string}
     * @memberof PaymentAccountDetails
     */
    customer_app_id?: string;
    /**
     * Finverse Institution ID for the payment institution.
     * @type {string}
     * @memberof PaymentAccountDetails
     */
    institution_id?: string;
    /**
     * Institution Name for the sender’s institution.
     * @type {string}
     * @memberof PaymentAccountDetails
     */
    institution_name?: string;
    /**
     * A unique identifier generated after creating user (Finverse Payment User ID)
     * @type {string}
     * @memberof PaymentAccountDetails
     */
    user_id?: string;
    /**
     * 3-digit code associated with bank
     * @type {string}
     * @memberof PaymentAccountDetails
     */
    bank_code?: string;
    /**
     * 3-digit code used to identify specific bank branch
     * @type {string}
     * @memberof PaymentAccountDetails
     */
    branch_code?: string;
    /**
     * List of currencies supported by the payment account
     * @type {Array<string>}
     * @memberof PaymentAccountDetails
     */
    currencies?: Array<string>;
    /**
     * The business units the payment account belongs to
     * @type {Array<string>}
     * @memberof PaymentAccountDetails
     */
    business_units?: Array<string>;
    /**
     * This field is only applicable to settlement account
     * @type {string}
     * @memberof PaymentAccountDetails
     */
    legal_entity_name?: string;
    /**
     * Additional attributes of the sender account in key:value format (e.g. sender_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 1000 characters respectively.
     * @type {{ [key: string]: string; }}
     * @memberof PaymentAccountDetails
     */
    metadata?: {
        [key: string]: string;
    };
    /**
     * Timestamp of when the payment link was created in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
     * @type {string}
     * @memberof PaymentAccountDetails
     */
    created_at?: string;
    /**
     * Timestamp of when the payment link was last updated in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
     * @type {string}
     * @memberof PaymentAccountDetails
     */
    updated_at?: string;
}
export declare const PaymentAccountDetailsAccountTypeEnum: {
    readonly ExternalAccount: "EXTERNAL_ACCOUNT";
    readonly SettlementAccount: "SETTLEMENT_ACCOUNT";
};
export type PaymentAccountDetailsAccountTypeEnum = (typeof PaymentAccountDetailsAccountTypeEnum)[keyof typeof PaymentAccountDetailsAccountTypeEnum];
/**
 *
 * @export
 * @interface PaymentAccountDetailsWithEnrichedData
 */
export interface PaymentAccountDetailsWithEnrichedData {
    /**
     * Payment account id
     * @type {string}
     * @memberof PaymentAccountDetailsWithEnrichedData
     */
    account_id?: string;
    /**
     *
     * @type {RecipientAccountNumber}
     * @memberof PaymentAccountDetailsWithEnrichedData
     */
    account_number?: RecipientAccountNumber;
    /**
     * Masked Account number of the payment account
     * @type {string}
     * @memberof PaymentAccountDetailsWithEnrichedData
     */
    account_number_masked?: string;
    /**
     * Type of payment account.
     * @type {string}
     * @memberof PaymentAccountDetailsWithEnrichedData
     */
    account_type?: PaymentAccountDetailsWithEnrichedDataAccountTypeEnum;
    /**
     * Accountholder name of the payment account
     * @type {string}
     * @memberof PaymentAccountDetailsWithEnrichedData
     */
    accountholder_name?: string;
    /**
     * The customer app ID
     * @type {string}
     * @memberof PaymentAccountDetailsWithEnrichedData
     */
    customer_app_id?: string;
    /**
     * Finverse Institution ID for the payment institution.
     * @type {string}
     * @memberof PaymentAccountDetailsWithEnrichedData
     */
    institution_id?: string;
    /**
     * Institution Name for the sender’s institution.
     * @type {string}
     * @memberof PaymentAccountDetailsWithEnrichedData
     */
    institution_name?: string;
    /**
     * A unique identifier generated after creating user (Finverse Payment User ID)
     * @type {string}
     * @memberof PaymentAccountDetailsWithEnrichedData
     */
    user_id?: string;
    /**
     * 3-digit code associated with bank
     * @type {string}
     * @memberof PaymentAccountDetailsWithEnrichedData
     */
    bank_code?: string;
    /**
     * 3-digit code used to identify specific bank branch
     * @type {string}
     * @memberof PaymentAccountDetailsWithEnrichedData
     */
    branch_code?: string;
    /**
     * List of currencies supported by the payment account
     * @type {Array<string>}
     * @memberof PaymentAccountDetailsWithEnrichedData
     */
    currencies?: Array<string>;
    /**
     * The business units the payment account belongs to
     * @type {Array<string>}
     * @memberof PaymentAccountDetailsWithEnrichedData
     */
    business_units?: Array<string>;
    /**
     * This field is only applicable to settlement account
     * @type {string}
     * @memberof PaymentAccountDetailsWithEnrichedData
     */
    legal_entity_name?: string;
    /**
     * Additional attributes of the sender account in key:value format (e.g. sender_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 1000 characters respectively.
     * @type {{ [key: string]: string; }}
     * @memberof PaymentAccountDetailsWithEnrichedData
     */
    metadata?: {
        [key: string]: string;
    };
    /**
     * Timestamp of when the payment link was created in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
     * @type {string}
     * @memberof PaymentAccountDetailsWithEnrichedData
     */
    created_at?: string;
    /**
     * Timestamp of when the payment link was last updated in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
     * @type {string}
     * @memberof PaymentAccountDetailsWithEnrichedData
     */
    updated_at?: string;
    /**
     *
     * @type {PaymentMethodOverview}
     * @memberof PaymentAccountDetailsWithEnrichedData
     */
    payment_method_overview?: PaymentMethodOverview;
}
export declare const PaymentAccountDetailsWithEnrichedDataAccountTypeEnum: {
    readonly ExternalAccount: "EXTERNAL_ACCOUNT";
    readonly SettlementAccount: "SETTLEMENT_ACCOUNT";
};
export type PaymentAccountDetailsWithEnrichedDataAccountTypeEnum = (typeof PaymentAccountDetailsWithEnrichedDataAccountTypeEnum)[keyof typeof PaymentAccountDetailsWithEnrichedDataAccountTypeEnum];
/**
 *
 * @export
 * @interface PaymentDetails
 */
export interface PaymentDetails {
    /**
     *
     * @type {string}
     * @memberof PaymentDetails
     */
    format?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentDetails
     */
    bic?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentDetails
     */
    bank_fullname?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentDetails
     */
    bank_shortname?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentDetails
     */
    bank_address?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentDetails
     */
    bank_country?: string;
    /**
     *
     * @type {OtherInfo}
     * @memberof PaymentDetails
     */
    other_info?: OtherInfo;
}
/**
 *
 * @export
 * @interface PaymentDetails2
 */
export interface PaymentDetails2 {
    /**
     * The transaction description provided to banks, which banks will show to their customers.
     * @type {string}
     * @memberof PaymentDetails2
     */
    description?: string;
    /**
     * ID of the mandate this pament is referring to.
     * @type {string}
     * @memberof PaymentDetails2
     */
    mandate_id?: string;
    /**
     * Deprecated: Customer\'s ID for this transaction
     * @type {string}
     * @memberof PaymentDetails2
     */
    transaction_reference_id?: string;
    /**
     * Customer reference for this transaction
     * @type {string}
     * @memberof PaymentDetails2
     */
    external_transaction_reference?: string;
    /**
     *
     * @type {PaymentDetailsReferences}
     * @memberof PaymentDetails2
     */
    references?: PaymentDetailsReferences;
    /**
     *
     * @type {string}
     * @memberof PaymentDetails2
     */
    processor_entity_name?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentDetails2
     */
    collection_entity_name?: string;
    /**
     *
     * @type {PaymentProcessorDetails}
     * @memberof PaymentDetails2
     */
    processor_details?: PaymentProcessorDetails;
    /**
     * The recurring payment mode
     * @type {string}
     * @memberof PaymentDetails2
     */
    recurring_payment_mode?: string;
}
/**
 *
 * @export
 * @interface PaymentDetailsReferences
 */
export interface PaymentDetailsReferences {
    /**
     *
     * @type {string}
     * @memberof PaymentDetailsReferences
     */
    finverse_transaction_reference?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentDetailsReferences
     */
    dda_reference?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentDetailsReferences
     */
    bank_transaction_reference?: string;
}
/**
 *
 * @export
 * @interface PaymentFvLinkDetails
 */
export interface PaymentFvLinkDetails {
    /**
     *
     * @type {string}
     * @memberof PaymentFvLinkDetails
     */
    collection_entity_name?: string;
}
/**
 *
 * @export
 * @interface PaymentFvLinkResponse
 */
export interface PaymentFvLinkResponse {
    /**
     *
     * @type {string}
     * @memberof PaymentFvLinkResponse
     */
    payment_id?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentFvLinkResponse
     */
    status?: PaymentFvLinkResponseStatusEnum;
    /**
     *
     * @type {PaymentFvLinkDetails}
     * @memberof PaymentFvLinkResponse
     */
    payment_details?: PaymentFvLinkDetails;
    /**
     *
     * @type {FvEmbeddedErrorModel}
     * @memberof PaymentFvLinkResponse
     */
    error?: FvEmbeddedErrorModel;
}
export declare const PaymentFvLinkResponseStatusEnum: {
    readonly AuthorizationRequired: "AUTHORIZATION_REQUIRED";
    readonly Authorizing: "AUTHORIZING";
    readonly Processing: "PROCESSING";
    readonly Submitted: "SUBMITTED";
    readonly Executed: "EXECUTED";
    readonly Failed: "FAILED";
    readonly Revoked: "REVOKED";
    readonly Cancelled: "CANCELLED";
    readonly Created: "CREATED";
};
export type PaymentFvLinkResponseStatusEnum = (typeof PaymentFvLinkResponseStatusEnum)[keyof typeof PaymentFvLinkResponseStatusEnum];
/**
 *
 * @export
 * @interface PaymentInfo
 */
export interface PaymentInfo {
    /**
     *
     * @type {Array<string>}
     * @memberof PaymentInfo
     */
    currencies_supported?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof PaymentInfo
     */
    payments_supported: Array<PaymentInfoPaymentsSupportedEnum>;
    /**
     *
     * @type {OtherInfo}
     * @memberof PaymentInfo
     */
    other_info?: OtherInfo;
}
export declare const PaymentInfoPaymentsSupportedEnum: {
    readonly Mandate: "MANDATE";
    readonly DebitAuthorization: "DEBIT_AUTHORIZATION";
};
export type PaymentInfoPaymentsSupportedEnum = (typeof PaymentInfoPaymentsSupportedEnum)[keyof typeof PaymentInfoPaymentsSupportedEnum];
/**
 *
 * @export
 * @interface PaymentInstruction
 */
export interface PaymentInstruction {
    /**
     * An id of the this payment
     * @type {string}
     * @memberof PaymentInstruction
     */
    payment_instruction_id?: string;
    /**
     * An id of the user of this payment, need to equal to userId when creating link
     * @type {string}
     * @memberof PaymentInstruction
     */
    user_id?: string;
    /**
     * An id that links this payment to a specific Login Identity
     * @type {string}
     * @memberof PaymentInstruction
     */
    login_identity_id?: string;
    /**
     * Type of payment that was created, please check Documentation on which payment type is supported in each institution
     * @type {string}
     * @memberof PaymentInstruction
     */
    type?: PaymentInstructionTypeEnum;
    /**
     * The recipient name
     * @type {string}
     * @memberof PaymentInstruction
     */
    recipient_name?: string;
    /**
     * The recipient account Id
     * @type {string}
     * @memberof PaymentInstruction
     */
    recipient_account_id?: string;
    /**
     * The sender name
     * @type {string}
     * @memberof PaymentInstruction
     */
    sender_name?: string;
    /**
     *
     * @type {PaymentAccount}
     * @memberof PaymentInstruction
     */
    sender_account?: PaymentAccount;
    /**
     * The sender account Id
     * @type {string}
     * @memberof PaymentInstruction
     */
    sender_account_id?: string;
    /**
     * When the payment should start
     * @type {string}
     * @memberof PaymentInstruction
     */
    start_date?: string | null;
    /**
     * When the payment should stop
     * @type {string}
     * @memberof PaymentInstruction
     */
    end_date?: string | null;
    /**
     * The currency for the payment
     * @type {string}
     * @memberof PaymentInstruction
     */
    currency?: string;
    /**
     * The payment amount
     * @type {number}
     * @memberof PaymentInstruction
     */
    amount?: number;
    /**
     * How often the payment should be executed
     * @type {string}
     * @memberof PaymentInstruction
     */
    frequency?: string;
    /**
     * Related remarks about this instruction
     * @type {string}
     * @memberof PaymentInstruction
     */
    remarks?: string;
    /**
     * Status of the payment
     * @type {string}
     * @memberof PaymentInstruction
     */
    status?: string;
    /**
     * Reference identification returned by institution
     * @type {string}
     * @memberof PaymentInstruction
     */
    reference_id?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentInstruction
     */
    last_update?: string;
    /**
     * Extra information collected for this payment instruction
     * @type {object}
     * @memberof PaymentInstruction
     */
    info?: object;
}
export declare const PaymentInstructionTypeEnum: {
    readonly DebitAuthorization: "DEBIT_AUTHORIZATION";
};
export type PaymentInstructionTypeEnum = (typeof PaymentInstructionTypeEnum)[keyof typeof PaymentInstructionTypeEnum];
/**
 *
 * @export
 * @interface PaymentLinkCustomizations
 */
export interface PaymentLinkCustomizations {
    /**
     * ISO639-1 language code. Language to display when user open the link, default to English (en) if not specified
     * @type {string}
     * @memberof PaymentLinkCustomizations
     */
    language?: PaymentLinkCustomizationsLanguageEnum;
    /**
     * The UI mode link is intended to be used in - \"iframe\", \"auto_redirect\", \"redirect\" or \"standalone\"
     * @type {string}
     * @memberof PaymentLinkCustomizations
     */
    ui_mode?: PaymentLinkCustomizationsUiModeEnum;
    /**
     * URI to redirect to. Only needed if ui_mode = redirect
     * @type {string}
     * @memberof PaymentLinkCustomizations
     */
    redirect_uri?: string;
}
export declare const PaymentLinkCustomizationsLanguageEnum: {
    readonly En: "en";
    readonly Vi: "vi";
    readonly Zh: "zh";
};
export type PaymentLinkCustomizationsLanguageEnum = (typeof PaymentLinkCustomizationsLanguageEnum)[keyof typeof PaymentLinkCustomizationsLanguageEnum];
export declare const PaymentLinkCustomizationsUiModeEnum: {
    readonly Iframe: "iframe";
    readonly Redirect: "redirect";
    readonly AutoRedirect: "auto_redirect";
    readonly Standalone: "standalone";
};
export type PaymentLinkCustomizationsUiModeEnum = (typeof PaymentLinkCustomizationsUiModeEnum)[keyof typeof PaymentLinkCustomizationsUiModeEnum];
/**
 *
 * @export
 * @interface PaymentLinkDetails
 */
export interface PaymentLinkDetails {
    /**
     *
     * @type {string}
     * @memberof PaymentLinkDetails
     */
    description: string;
    /**
     * For external invoice/transaction reference
     * @type {string}
     * @memberof PaymentLinkDetails
     */
    external_transaction_reference: string;
}
/**
 *
 * @export
 * @interface PaymentLinkResponse
 */
export interface PaymentLinkResponse {
    /**
     * Finverse Payment Link ID
     * @type {string}
     * @memberof PaymentLinkResponse
     */
    payment_link_id?: string;
    /**
     * The amount of the payment. Expressed in currency\'s smallest unit or “minor unit”, as defined in ISO 4217.
     * @type {number}
     * @memberof PaymentLinkResponse
     */
    amount?: number;
    /**
     *
     * @type {string}
     * @memberof PaymentLinkResponse
     */
    currency?: string;
    /**
     *
     * @type {PaymentLinkCustomizations}
     * @memberof PaymentLinkResponse
     */
    link_customizations?: PaymentLinkCustomizations;
    /**
     * The payment link mode
     * @type {string}
     * @memberof PaymentLinkResponse
     */
    mode?: PaymentLinkResponseModeEnum;
    /**
     *
     * @type {PaymentLinkDetails}
     * @memberof PaymentLinkResponse
     */
    payment_details?: PaymentLinkDetails;
    /**
     * Unique reference id to identifying the payment to be collected.
     * @type {string}
     * @memberof PaymentLinkResponse
     */
    unique_reference_id?: string;
    /**
     *
     * @type {PaymentSetupOptions}
     * @memberof PaymentLinkResponse
     */
    payment_setup_options?: PaymentSetupOptions;
    /**
     * Additional attributes of the payment link in key:value format (e.g. payment_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 1000 characters respectively.
     * @type {{ [key: string]: string; }}
     * @memberof PaymentLinkResponse
     */
    metadata?: {
        [key: string]: string;
    };
    /**
     * Key-Value metadata to store on payments created on this Payment Link
     * @type {{ [key: string]: string; }}
     * @memberof PaymentLinkResponse
     */
    payment_metadata?: {
        [key: string]: string;
    };
    /**
     * The URL for payment link
     * @type {string}
     * @memberof PaymentLinkResponse
     */
    url?: string;
    /**
     * The status of payment link
     * @type {string}
     * @memberof PaymentLinkResponse
     */
    status?: PaymentLinkResponseStatusEnum;
    /**
     * The session status of payment link
     * @type {string}
     * @memberof PaymentLinkResponse
     */
    session_status?: PaymentLinkResponseSessionStatusEnum;
    /**
     * Timestamp of when the payment link was or will expired in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
     * @type {string}
     * @memberof PaymentLinkResponse
     */
    expires_at?: string;
    /**
     * Timestamp of when the payment link was created in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
     * @type {string}
     * @memberof PaymentLinkResponse
     */
    created_at?: string;
    /**
     * Timestamp of when the payment link was last updated in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
     * @type {string}
     * @memberof PaymentLinkResponse
     */
    updated_at?: string;
    /**
     *
     * @type {PaymentResponse}
     * @memberof PaymentLinkResponse
     */
    payment?: PaymentResponse;
    /**
     *
     * @type {PaymentLinkSenderResponse}
     * @memberof PaymentLinkResponse
     */
    sender?: PaymentLinkSenderResponse;
    /**
     *
     * @type {PaymentMethodResponse}
     * @memberof PaymentLinkResponse
     */
    payment_method?: PaymentMethodResponse;
    /**
     *
     * @type {IntegrationMetadataResponse}
     * @memberof PaymentLinkResponse
     */
    integration_metadata?: IntegrationMetadataResponse;
}
export declare const PaymentLinkResponseModeEnum: {
    readonly Payment: "PAYMENT";
};
export type PaymentLinkResponseModeEnum = (typeof PaymentLinkResponseModeEnum)[keyof typeof PaymentLinkResponseModeEnum];
export declare const PaymentLinkResponseStatusEnum: {
    readonly Created: "CREATED";
    readonly Paid: "PAID";
    readonly Expired: "EXPIRED";
};
export type PaymentLinkResponseStatusEnum = (typeof PaymentLinkResponseStatusEnum)[keyof typeof PaymentLinkResponseStatusEnum];
export declare const PaymentLinkResponseSessionStatusEnum: {
    readonly Open: "OPEN";
    readonly Processing: "PROCESSING";
    readonly Complete: "COMPLETE";
    readonly Failed: "FAILED";
};
export type PaymentLinkResponseSessionStatusEnum = (typeof PaymentLinkResponseSessionStatusEnum)[keyof typeof PaymentLinkResponseSessionStatusEnum];
/**
 *
 * @export
 * @interface PaymentLinkSender
 */
export interface PaymentLinkSender {
    /**
     *
     * @type {string}
     * @memberof PaymentLinkSender
     */
    email?: string;
    /**
     * Customer App\'s user ID, representing the end-user making the payment.
     * @type {string}
     * @memberof PaymentLinkSender
     */
    external_user_id: string;
    /**
     * Accountholder name of the sender\'s account
     * @type {string}
     * @memberof PaymentLinkSender
     */
    name: string;
}
/**
 *
 * @export
 * @interface PaymentLinkSenderResponse
 */
export interface PaymentLinkSenderResponse {
    /**
     *
     * @type {string}
     * @memberof PaymentLinkSenderResponse
     */
    email?: string;
    /**
     * Customer App\'s user ID, representing the end-user making the payment.
     * @type {string}
     * @memberof PaymentLinkSenderResponse
     */
    external_user_id?: string;
    /**
     * Accountholder name of the sender\'s account
     * @type {string}
     * @memberof PaymentLinkSenderResponse
     */
    name?: string;
    /**
     * A unique identifier generated after creating sender
     * @type {string}
     * @memberof PaymentLinkSenderResponse
     */
    user_id?: string;
}
/**
 *
 * @export
 * @interface PaymentLinkTokenResponse
 */
export interface PaymentLinkTokenResponse {
    /**
     * Short-lived access-token to interact with Finverse Link
     * @type {string}
     * @memberof PaymentLinkTokenResponse
     */
    access_token: string;
    /**
     * Access token validity duration (in seconds)
     * @type {number}
     * @memberof PaymentLinkTokenResponse
     */
    expires_in: number;
    /**
     * URL to launch Finverse Link to authorize the mandate
     * @type {string}
     * @memberof PaymentLinkTokenResponse
     */
    link_url: string;
    /**
     *
     * @type {string}
     * @memberof PaymentLinkTokenResponse
     */
    token_type: PaymentLinkTokenResponseTokenTypeEnum;
}
export declare const PaymentLinkTokenResponseTokenTypeEnum: {
    readonly Bearer: "Bearer";
};
export type PaymentLinkTokenResponseTokenTypeEnum = (typeof PaymentLinkTokenResponseTokenTypeEnum)[keyof typeof PaymentLinkTokenResponseTokenTypeEnum];
/**
 *
 * @export
 * @interface PaymentMethodFvLinkResponse
 */
export interface PaymentMethodFvLinkResponse {
    /**
     *
     * @type {string}
     * @memberof PaymentMethodFvLinkResponse
     */
    payment_method_id?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodFvLinkResponse
     */
    payment_method_type?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodFvLinkResponse
     */
    recipient_entity_name?: string;
    /**
     *
     * @type {MandateFvLinkResponse}
     * @memberof PaymentMethodFvLinkResponse
     */
    mandate?: MandateFvLinkResponse;
    /**
     *
     * @type {CardFvLinkResponse}
     * @memberof PaymentMethodFvLinkResponse
     */
    card?: CardFvLinkResponse;
}
/**
 *
 * @export
 * @interface PaymentMethodIntegrationMetadata
 */
export interface PaymentMethodIntegrationMetadata {
    /**
     *
     * @type {string}
     * @memberof PaymentMethodIntegrationMetadata
     */
    integration_id: PaymentMethodIntegrationMetadataIntegrationIdEnum;
    /**
     *
     * @type {PaymentMethodIntegrationMetadataStripeMetadata}
     * @memberof PaymentMethodIntegrationMetadata
     */
    stripe_metadata?: PaymentMethodIntegrationMetadataStripeMetadata;
    /**
     *
     * @type {PaymentMethodIntegrationMetadataCybersourceMetadata}
     * @memberof PaymentMethodIntegrationMetadata
     */
    cybersource_metadata?: PaymentMethodIntegrationMetadataCybersourceMetadata;
}
export declare const PaymentMethodIntegrationMetadataIntegrationIdEnum: {
    readonly Stripe: "STRIPE";
    readonly Cybersource: "CYBERSOURCE";
};
export type PaymentMethodIntegrationMetadataIntegrationIdEnum = (typeof PaymentMethodIntegrationMetadataIntegrationIdEnum)[keyof typeof PaymentMethodIntegrationMetadataIntegrationIdEnum];
/**
 *
 * @export
 * @interface PaymentMethodIntegrationMetadataCybersourceMetadata
 */
export interface PaymentMethodIntegrationMetadataCybersourceMetadata {
    /**
     *
     * @type {string}
     * @memberof PaymentMethodIntegrationMetadataCybersourceMetadata
     */
    payment_token: string;
}
/**
 *
 * @export
 * @interface PaymentMethodIntegrationMetadataStripeMetadata
 */
export interface PaymentMethodIntegrationMetadataStripeMetadata {
    /**
     *
     * @type {PaymentMethodIntegrationMetadataStripeMetadataCustomer}
     * @memberof PaymentMethodIntegrationMetadataStripeMetadata
     */
    customer: PaymentMethodIntegrationMetadataStripeMetadataCustomer;
    /**
     *
     * @type {PaymentMethodIntegrationMetadataStripeMetadataCustomer}
     * @memberof PaymentMethodIntegrationMetadataStripeMetadata
     */
    payment_method: PaymentMethodIntegrationMetadataStripeMetadataCustomer;
}
/**
 *
 * @export
 * @interface PaymentMethodIntegrationMetadataStripeMetadataCustomer
 */
export interface PaymentMethodIntegrationMetadataStripeMetadataCustomer {
    /**
     *
     * @type {string}
     * @memberof PaymentMethodIntegrationMetadataStripeMetadataCustomer
     */
    id: string;
}
/**
 *
 * @export
 * @interface PaymentMethodOverview
 */
export interface PaymentMethodOverview {
    /**
     * STRIPE, CYBERSOURCE, UOB, DBS (only shown when payment flows funds via a 3rd party gateway direct to the customer)
     * @type {string}
     * @memberof PaymentMethodOverview
     */
    external_gateway?: string;
    /**
     * It can be either REALTIME or DELAYED
     * @type {string}
     * @memberof PaymentMethodOverview
     */
    payment_confirmation_speed?: string;
    /**
     * The payment method type, possible values CARD, MANDATE and MANUAL
     * @type {string}
     * @memberof PaymentMethodOverview
     */
    payment_method_type?: string;
    /**
     * The payment method subtype
     * @type {string}
     * @memberof PaymentMethodOverview
     */
    payment_method_subtype?: string;
    /**
     * Only shown if funds flow via Finverse, possible values FINVERSE
     * @type {string}
     * @memberof PaymentMethodOverview
     */
    payment_processor?: string;
    /**
     * Whether the payment method can move real money or not
     * @type {boolean}
     * @memberof PaymentMethodOverview
     */
    live_mode: boolean;
    /**
     * Shows which currencies are supported
     * @type {Array<string>}
     * @memberof PaymentMethodOverview
     */
    supported_currencies?: Array<string>;
}
/**
 *
 * @export
 * @interface PaymentMethodResponse
 */
export interface PaymentMethodResponse {
    /**
     *
     * @type {string}
     * @memberof PaymentMethodResponse
     */
    payment_method_id?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodResponse
     */
    payment_method_type?: string;
    /**
     *
     * @type {GetMandateResponse}
     * @memberof PaymentMethodResponse
     */
    mandate?: GetMandateResponse;
    /**
     *
     * @type {FVCard}
     * @memberof PaymentMethodResponse
     */
    card?: FVCard;
    /**
     *
     * @type {PaymentMethodIntegrationMetadata}
     * @memberof PaymentMethodResponse
     */
    integration_metadata?: PaymentMethodIntegrationMetadata;
}
/**
 *
 * @export
 * @interface PaymentProcessorDetails
 */
export interface PaymentProcessorDetails {
    /**
     *
     * @type {string}
     * @memberof PaymentProcessorDetails
     */
    auth_code?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentProcessorDetails
     */
    processor_id?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentProcessorDetails
     */
    processor_reference?: string;
    /**
     *
     * @type {PaymentProcessorResult}
     * @memberof PaymentProcessorDetails
     */
    result?: PaymentProcessorResult;
}
/**
 *
 * @export
 * @interface PaymentProcessorResult
 */
export interface PaymentProcessorResult {
    /**
     * Payment processor\'s decline code (e.g. \"2\")
     * @type {string}
     * @memberof PaymentProcessorResult
     */
    decline_code?: string;
    /**
     * Payment processor\'s decline explanation (e.g. \"Blocked card\")
     * @type {string}
     * @memberof PaymentProcessorResult
     */
    decline_reason?: string;
    /**
     * Payment processor\'s result code (e.g. \"Authorized\", \"Refused\").
     * @type {string}
     * @memberof PaymentProcessorResult
     */
    result_code?: string;
}
/**
 *
 * @export
 * @interface PaymentResponse
 */
export interface PaymentResponse {
    /**
     * Finverse Payment ID
     * @type {string}
     * @memberof PaymentResponse
     */
    payment_id?: string;
    /**
     * Amount to be paid, in currency\'s smallest unit or “minor unit”, as defined in ISO 4217. For example, HKD 100.01 is represented as amount = 10001 (minor unit = cents). For currencies without minor units (e.g. VND, JPY), the amount is represented as is, without modification. For example, VND 15101 is represented as amount = 15101.
     * @type {number}
     * @memberof PaymentResponse
     */
    amount: number;
    /**
     * Surcharge amount in minor
     * @type {number}
     * @memberof PaymentResponse
     */
    surcharge_amount: number;
    /**
     * Amount with all fees and surcharges applied in minor
     * @type {number}
     * @memberof PaymentResponse
     */
    amount_total_with_surcharge: number;
    /**
     * The currency code as defined in ISO 4217.
     * @type {string}
     * @memberof PaymentResponse
     */
    currency?: string;
    /**
     * Indicates whether this is a mandate-based payment or one-off direct payment to an account. Possible values - MANDATE, SINGLE
     * @type {string}
     * @memberof PaymentResponse
     */
    type?: PaymentResponseTypeEnum;
    /**
     * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
     * @type {string}
     * @memberof PaymentResponse
     */
    updated_at?: string;
    /**
     * Possible values - CREATED, AUTHORIZED, SUBMITTED, EXECUTED, FAILED, REJECTED, CANCELLED.
     * @type {string}
     * @memberof PaymentResponse
     */
    status?: PaymentResponseStatusEnum;
    /**
     * ID of the payment method this pament is referring to.
     * @type {string}
     * @memberof PaymentResponse
     */
    payment_method_id?: string;
    /**
     *
     * @type {PaymentDetails2}
     * @memberof PaymentResponse
     */
    payment_details?: PaymentDetails2;
    /**
     *
     * @type {MandateRecipient}
     * @memberof PaymentResponse
     */
    recipient?: MandateRecipient;
    /**
     *
     * @type {MandateRecipientAccount}
     * @memberof PaymentResponse
     */
    recipient_account?: MandateRecipientAccount;
    /**
     *
     * @type {GetMandateSender}
     * @memberof PaymentResponse
     */
    sender?: GetMandateSender;
    /**
     *
     * @type {MandateSenderAccount}
     * @memberof PaymentResponse
     */
    sender_account?: MandateSenderAccount;
    /**
     *
     * @type {Array<Fee>}
     * @memberof PaymentResponse
     */
    fees?: Array<Fee>;
    /**
     * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
     * @type {string}
     * @memberof PaymentResponse
     */
    created_at?: string;
    /**
     * Additional attributes of the payment in key:value format (e.g. payment_internal_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 1000 characters respectively.
     * @type {{ [key: string]: string; }}
     * @memberof PaymentResponse
     */
    metadata?: {
        [key: string]: string;
    };
    /**
     *
     * @type {FvEmbeddedErrorModel}
     * @memberof PaymentResponse
     */
    error?: FvEmbeddedErrorModel;
    /**
     *
     * @type {PaymentSnapshotPaymentMethod}
     * @memberof PaymentResponse
     */
    payment_method?: PaymentSnapshotPaymentMethod;
}
export declare const PaymentResponseTypeEnum: {
    readonly Mandate: "MANDATE";
    readonly Single: "SINGLE";
    readonly Card: "CARD";
    readonly Manual: "MANUAL";
};
export type PaymentResponseTypeEnum = (typeof PaymentResponseTypeEnum)[keyof typeof PaymentResponseTypeEnum];
export declare const PaymentResponseStatusEnum: {
    readonly AuthorizationRequired: "AUTHORIZATION_REQUIRED";
    readonly Authorizing: "AUTHORIZING";
    readonly Processing: "PROCESSING";
    readonly Submitted: "SUBMITTED";
    readonly Executed: "EXECUTED";
    readonly Failed: "FAILED";
    readonly Revoked: "REVOKED";
    readonly Cancelled: "CANCELLED";
    readonly Created: "CREATED";
};
export type PaymentResponseStatusEnum = (typeof PaymentResponseStatusEnum)[keyof typeof PaymentResponseStatusEnum];
/**
 *
 * @export
 * @interface PaymentSchedule
 */
export interface PaymentSchedule {
    /**
     * Amount to be paid, in currency’s smallest unit or “minor unit”, as defined in ISO 4217. For example, HKD 100.01 is represented as amount = 10001 (minor unit = cents). For currencies without minor units (e.g. VND, JPY), the amount is represented as is, without modification. For example, VND 15101 is represented as amount = 15101.
     * @type {number}
     * @memberof PaymentSchedule
     */
    amount: number;
    /**
     * Frequency of the payment. Possible values (DAILY, WEEKLY, MONTHLY, QUARTERLY, YEARLY)
     * @type {string}
     * @memberof PaymentSchedule
     */
    frequency: PaymentScheduleFrequencyEnum;
}
export declare const PaymentScheduleFrequencyEnum: {
    readonly Daily: "DAILY";
    readonly Weekly: "WEEKLY";
    readonly Monthly: "MONTHLY";
    readonly Quarterly: "QUARTERLY";
    readonly Yearly: "YEARLY";
};
export type PaymentScheduleFrequencyEnum = (typeof PaymentScheduleFrequencyEnum)[keyof typeof PaymentScheduleFrequencyEnum];
/**
 *
 * @export
 * @interface PaymentSetupOptions
 */
export interface PaymentSetupOptions {
    /**
     * The type of future_payments that customer want to use. Possible values: AUTOPAY or CLICK_TO_PAY
     * @type {string}
     * @memberof PaymentSetupOptions
     */
    future_payments?: PaymentSetupOptionsFuturePaymentsEnum;
    /**
     *
     * @type {MandateDetailsForPaymentLink}
     * @memberof PaymentSetupOptions
     */
    mandate_details?: MandateDetailsForPaymentLink;
    /**
     *
     * @type {Array<string>}
     * @memberof PaymentSetupOptions
     */
    payment_method_types?: Array<PaymentSetupOptionsPaymentMethodTypesEnum>;
    /**
     *
     * @type {RecipientAccountFilters}
     * @memberof PaymentSetupOptions
     */
    recipient_account_filters?: RecipientAccountFilters;
    /**
     *
     * @type {AutopayEnrollmentConfiguration}
     * @memberof PaymentSetupOptions
     */
    autopay_enrollment_configuration?: AutopayEnrollmentConfiguration;
}
export declare const PaymentSetupOptionsFuturePaymentsEnum: {
    readonly Autopay: "AUTOPAY";
    readonly ClickToPay: "CLICK_TO_PAY";
};
export type PaymentSetupOptionsFuturePaymentsEnum = (typeof PaymentSetupOptionsFuturePaymentsEnum)[keyof typeof PaymentSetupOptionsFuturePaymentsEnum];
export declare const PaymentSetupOptionsPaymentMethodTypesEnum: {
    readonly Mandate: "MANDATE";
    readonly Single: "SINGLE";
    readonly Card: "CARD";
    readonly Manual: "MANUAL";
};
export type PaymentSetupOptionsPaymentMethodTypesEnum = (typeof PaymentSetupOptionsPaymentMethodTypesEnum)[keyof typeof PaymentSetupOptionsPaymentMethodTypesEnum];
/**
 *
 * @export
 * @interface PaymentSnapshotPaymentMethod
 */
export interface PaymentSnapshotPaymentMethod {
    /**
     *
     * @type {PaymentSnapshotPaymentMethodCard}
     * @memberof PaymentSnapshotPaymentMethod
     */
    card?: PaymentSnapshotPaymentMethodCard;
}
/**
 *
 * @export
 * @interface PaymentSnapshotPaymentMethodCard
 */
export interface PaymentSnapshotPaymentMethodCard {
    /**
     *
     * @type {FVCardDetails}
     * @memberof PaymentSnapshotPaymentMethodCard
     */
    card_details?: FVCardDetails;
}
/**
 *
 * @export
 * @interface PaymentUser
 */
export interface PaymentUser {
    /**
     *
     * @type {string}
     * @memberof PaymentUser
     */
    created_at?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentUser
     */
    email?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentUser
     */
    external_user_id?: string;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof PaymentUser
     */
    metadata?: {
        [key: string]: string;
    };
    /**
     *
     * @type {string}
     * @memberof PaymentUser
     */
    name?: string;
    /**
     *
     * @type {Array<SenderDetail>}
     * @memberof PaymentUser
     */
    user_details?: Array<SenderDetail>;
    /**
     *
     * @type {string}
     * @memberof PaymentUser
     */
    updated_at?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentUser
     */
    next_bill_update?: string | null;
    /**
     *
     * @type {string}
     * @memberof PaymentUser
     */
    user_id?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentUser
     */
    user_type?: PaymentUserUserTypeEnum;
    /**
     * Whether the user has given consent for autopay
     * @type {boolean}
     * @memberof PaymentUser
     */
    autopay_consent: boolean;
    /**
     *
     * @type {IntegrationMetadataResponse}
     * @memberof PaymentUser
     */
    integration_metadata?: IntegrationMetadataResponse;
}
export declare const PaymentUserUserTypeEnum: {
    readonly Individual: "INDIVIDUAL";
    readonly Business: "BUSINESS";
};
export type PaymentUserUserTypeEnum = (typeof PaymentUserUserTypeEnum)[keyof typeof PaymentUserUserTypeEnum];
/**
 *
 * @export
 * @interface PaymentUserWithoutEmail
 */
export interface PaymentUserWithoutEmail {
    /**
     *
     * @type {string}
     * @memberof PaymentUserWithoutEmail
     */
    created_at?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentUserWithoutEmail
     */
    email?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentUserWithoutEmail
     */
    external_user_id?: string;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof PaymentUserWithoutEmail
     */
    metadata?: {
        [key: string]: string;
    };
    /**
     *
     * @type {string}
     * @memberof PaymentUserWithoutEmail
     */
    name?: string;
    /**
     *
     * @type {Array<SenderDetail>}
     * @memberof PaymentUserWithoutEmail
     */
    user_details?: Array<SenderDetail>;
    /**
     *
     * @type {string}
     * @memberof PaymentUserWithoutEmail
     */
    updated_at?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentUserWithoutEmail
     */
    next_bill_update?: string | null;
    /**
     *
     * @type {string}
     * @memberof PaymentUserWithoutEmail
     */
    user_id?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentUserWithoutEmail
     */
    user_type?: PaymentUserWithoutEmailUserTypeEnum;
    /**
     * Whether the user has given consent for autopay
     * @type {boolean}
     * @memberof PaymentUserWithoutEmail
     */
    autopay_consent: boolean;
    /**
     *
     * @type {IntegrationMetadataResponse}
     * @memberof PaymentUserWithoutEmail
     */
    integration_metadata?: IntegrationMetadataResponse;
}
export declare const PaymentUserWithoutEmailUserTypeEnum: {
    readonly Individual: "INDIVIDUAL";
    readonly Business: "BUSINESS";
};
export type PaymentUserWithoutEmailUserTypeEnum = (typeof PaymentUserWithoutEmailUserTypeEnum)[keyof typeof PaymentUserWithoutEmailUserTypeEnum];
/**
 *
 * @export
 * @interface PayoutDetails
 */
export interface PayoutDetails {
    /**
     * The mandate used to execute payments for this payout instruction. Currency for the mandate must be supported by the recipient account
     * @type {string}
     * @memberof PayoutDetails
     */
    mandate_id: string;
    /**
     * A description for the payment (that will appear as the transaction description on bank statements)
     * @type {string}
     * @memberof PayoutDetails
     */
    description?: string;
    /**
     * YYYY-MM-DD, date (in UTC) to execute the payment, must be 1 day later than current date
     * @type {string}
     * @memberof PayoutDetails
     */
    scheduled_date: string;
}
/**
 *
 * @export
 * @interface PayoutSnapshotDetails
 */
export interface PayoutSnapshotDetails {
    /**
     *
     * @type {string}
     * @memberof PayoutSnapshotDetails
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof PayoutSnapshotDetails
     */
    transaction_reference_id?: string;
    /**
     *
     * @type {string}
     * @memberof PayoutSnapshotDetails
     */
    mandate_id?: string;
    /**
     *
     * @type {string}
     * @memberof PayoutSnapshotDetails
     */
    scheduled_date?: string;
}
/**
 *
 * @export
 * @interface PayoutSnapshotResponse
 */
export interface PayoutSnapshotResponse {
    /**
     *
     * @type {string}
     * @memberof PayoutSnapshotResponse
     */
    payout_id?: string;
    /**
     *
     * @type {string}
     * @memberof PayoutSnapshotResponse
     */
    status?: PayoutSnapshotResponseStatusEnum;
    /**
     *
     * @type {string}
     * @memberof PayoutSnapshotResponse
     */
    type?: PayoutSnapshotResponseTypeEnum;
    /**
     *
     * @type {string}
     * @memberof PayoutSnapshotResponse
     */
    created_at?: string;
    /**
     *
     * @type {string}
     * @memberof PayoutSnapshotResponse
     */
    updated_at?: string;
    /**
     *
     * @type {string}
     * @memberof PayoutSnapshotResponse
     */
    transaction_date?: string;
    /**
     *
     * @type {PayoutSnapshotDetails}
     * @memberof PayoutSnapshotResponse
     */
    payment_details?: PayoutSnapshotDetails;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof PayoutSnapshotResponse
     */
    metadata?: {
        [key: string]: string;
    };
    /**
     *
     * @type {number}
     * @memberof PayoutSnapshotResponse
     */
    amount?: number;
    /**
     *
     * @type {string}
     * @memberof PayoutSnapshotResponse
     */
    currency?: string;
    /**
     *
     * @type {MandateRecipient}
     * @memberof PayoutSnapshotResponse
     */
    sender?: MandateRecipient;
    /**
     *
     * @type {MandateRecipientAccount}
     * @memberof PayoutSnapshotResponse
     */
    sender_account?: MandateRecipientAccount;
    /**
     *
     * @type {GetMandateSender}
     * @memberof PayoutSnapshotResponse
     */
    recipient?: GetMandateSender;
    /**
     *
     * @type {MandateSenderAccount}
     * @memberof PayoutSnapshotResponse
     */
    recipient_account?: MandateSenderAccount;
    /**
     *
     * @type {Array<Fee>}
     * @memberof PayoutSnapshotResponse
     */
    fees?: Array<Fee>;
    /**
     * Whether this payout is live or not
     * @type {boolean}
     * @memberof PayoutSnapshotResponse
     */
    live: boolean;
    /**
     *
     * @type {FvEmbeddedErrorModel}
     * @memberof PayoutSnapshotResponse
     */
    error?: FvEmbeddedErrorModel;
}
export declare const PayoutSnapshotResponseStatusEnum: {
    readonly Executed: "EXECUTED";
    readonly Created: "CREATED";
    readonly Processing: "PROCESSING";
    readonly ProcessingFunds: "PROCESSING_FUNDS";
    readonly Cancelled: "CANCELLED";
    readonly Failed: "FAILED";
    readonly Funded: "FUNDED";
    readonly Submitted: "SUBMITTED";
};
export type PayoutSnapshotResponseStatusEnum = (typeof PayoutSnapshotResponseStatusEnum)[keyof typeof PayoutSnapshotResponseStatusEnum];
export declare const PayoutSnapshotResponseTypeEnum: {
    readonly Manual: "MANUAL";
    readonly Scheduled: "SCHEDULED";
};
export type PayoutSnapshotResponseTypeEnum = (typeof PayoutSnapshotResponseTypeEnum)[keyof typeof PayoutSnapshotResponseTypeEnum];
/**
 *
 * @export
 * @interface Principal
 */
export interface Principal {
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    subject: string;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    token?: string;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    client_id: string;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    customer_app_id: string;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    login_identity_id: string;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    customization_id?: string;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    mandate_id?: string;
    /**
     *
     * @type {number}
     * @memberof Principal
     */
    expires_in?: number;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    payment_attempt_id?: string;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    product_flow?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof Principal
     */
    scopes?: Array<string>;
    /**
     *
     * @type {LinkTokenRequest}
     * @memberof Principal
     */
    link_token_request?: LinkTokenRequest;
    /**
     *
     * @type {GetMandateAuthLinkRequest}
     * @memberof Principal
     */
    get_mandate_auth_link_request?: GetMandateAuthLinkRequest;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    currency?: string;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    redirect_uri?: string;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    payment_link_id?: string;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    unique_reference_id?: string;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    payment_method_id?: string;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    tpp_name?: string;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    retry_url?: string;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    onboarding_flow?: string;
    /**
     * The qrCode text to be used to generate the image
     * @type {string}
     * @memberof Principal
     */
    qr_code_text?: string;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    manual_payment_provider?: string;
}
/**
 *
 * @export
 * @interface ProductStatus
 */
export interface ProductStatus {
    /**
     * The current health of this product
     * @type {string}
     * @memberof ProductStatus
     */
    status?: string;
    /**
     * The detailed event name
     * @type {string}
     * @memberof ProductStatus
     */
    status_details?: string;
    /**
     *
     * @type {string}
     * @memberof ProductStatus
     */
    last_update?: string | null;
    /**
     *
     * @type {string}
     * @memberof ProductStatus
     */
    last_successful_update?: string | null;
}
/**
 *
 * @export
 * @interface RapidstorMetadataRequest
 */
export interface RapidstorMetadataRequest {
    /**
     *
     * @type {string}
     * @memberof RapidstorMetadataRequest
     */
    corp_code: string;
    /**
     *
     * @type {string}
     * @memberof RapidstorMetadataRequest
     */
    s_location_code: string;
    /**
     *
     * @type {string}
     * @memberof RapidstorMetadataRequest
     */
    tenant_id: string;
    /**
     *
     * @type {number}
     * @memberof RapidstorMetadataRequest
     */
    i_anniv_days?: number;
    /**
     *
     * @type {string}
     * @memberof RapidstorMetadataRequest
     */
    account_token: string;
}
/**
 *
 * @export
 * @interface RapidstorMetadataResponse
 */
export interface RapidstorMetadataResponse {
    /**
     *
     * @type {string}
     * @memberof RapidstorMetadataResponse
     */
    corp_code?: string;
    /**
     *
     * @type {string}
     * @memberof RapidstorMetadataResponse
     */
    s_location_code?: string;
    /**
     *
     * @type {string}
     * @memberof RapidstorMetadataResponse
     */
    tenant_id?: string;
    /**
     *
     * @type {number}
     * @memberof RapidstorMetadataResponse
     */
    i_anniv_days?: number;
    /**
     *
     * @type {string}
     * @memberof RapidstorMetadataResponse
     */
    tenant_default_currency?: string;
    /**
     *
     * @type {string}
     * @memberof RapidstorMetadataResponse
     */
    account_token?: string;
}
/**
 *
 * @export
 * @interface RecipientAccountFilters
 */
export interface RecipientAccountFilters {
    /**
     *
     * @type {string}
     * @memberof RecipientAccountFilters
     */
    business_unit: string;
}
/**
 *
 * @export
 * @interface RecipientAccountNumber
 */
export interface RecipientAccountNumber {
    /**
     * Type of account number. Possible values: LOCAL, IBAN
     * @type {string}
     * @memberof RecipientAccountNumber
     */
    type: RecipientAccountNumberTypeEnum;
    /**
     * Account number value
     * @type {string}
     * @memberof RecipientAccountNumber
     */
    number: string;
    /**
     * Account number value
     * @type {string}
     * @memberof RecipientAccountNumber
     */
    number_plaintext?: string | null;
}
export declare const RecipientAccountNumberTypeEnum: {
    readonly Local: "LOCAL";
    readonly Iban: "IBAN";
};
export type RecipientAccountNumberTypeEnum = (typeof RecipientAccountNumberTypeEnum)[keyof typeof RecipientAccountNumberTypeEnum];
/**
 *
 * @export
 * @interface RecipientAccountResponse
 */
export interface RecipientAccountResponse {
    /**
     * A unique identifier generated after creating recipient
     * @type {string}
     * @memberof RecipientAccountResponse
     */
    recipient_account_id?: string;
    /**
     * Accountholder name of the recipient\'s account
     * @type {string}
     * @memberof RecipientAccountResponse
     */
    accountholder_name?: string;
    /**
     *
     * @type {RecipientAccountNumber}
     * @memberof RecipientAccountResponse
     */
    account_number?: RecipientAccountNumber;
    /**
     * Type of recipient account.
     * @type {string}
     * @memberof RecipientAccountResponse
     */
    account_type?: RecipientAccountResponseAccountTypeEnum;
    /**
     * List of currencies supported by the recipient account
     * @type {Array<string>}
     * @memberof RecipientAccountResponse
     */
    currencies?: Array<string>;
    /**
     * Finverse Institution ID for the recipient’s institution.
     * @type {string}
     * @memberof RecipientAccountResponse
     */
    institution_id?: string;
    /**
     * Institution Name for the sender’s institution.
     * @type {string}
     * @memberof RecipientAccountResponse
     */
    institution_name?: string;
    /**
     * 3-digit code associated with bank
     * @type {string}
     * @memberof RecipientAccountResponse
     */
    bank_code?: string;
    /**
     * 3-digit code used to identify specific bank branch
     * @type {string}
     * @memberof RecipientAccountResponse
     */
    branch_code?: string;
}
export declare const RecipientAccountResponseAccountTypeEnum: {
    readonly ExternalAccount: "EXTERNAL_ACCOUNT";
    readonly SettlementAccount: "SETTLEMENT_ACCOUNT";
};
export type RecipientAccountResponseAccountTypeEnum = (typeof RecipientAccountResponseAccountTypeEnum)[keyof typeof RecipientAccountResponseAccountTypeEnum];
/**
 *
 * @export
 * @interface RedirectUriResponse
 */
export interface RedirectUriResponse {
    /**
     *
     * @type {string}
     * @memberof RedirectUriResponse
     */
    redirect_uri?: string;
}
/**
 *
 * @export
 * @interface RefreshData
 */
export interface RefreshData {
    /**
     *
     * @type {boolean}
     * @memberof RefreshData
     */
    credentials_stored: boolean;
    /**
     *
     * @type {boolean}
     * @memberof RefreshData
     */
    refresh_allowed: boolean;
}
/**
 *
 * @export
 * @interface RefreshLoginIdentityLinkCustomizations
 */
export interface RefreshLoginIdentityLinkCustomizations {
    /**
     * ISO639-1 language code. Language to display when user open the link, default to English (en) if not specified
     * @type {string}
     * @memberof RefreshLoginIdentityLinkCustomizations
     */
    language?: RefreshLoginIdentityLinkCustomizationsLanguageEnum;
    /**
     *
     * @type {string}
     * @memberof RefreshLoginIdentityLinkCustomizations
     */
    ui_mode?: RefreshLoginIdentityLinkCustomizationsUiModeEnum;
    /**
     * Required if ui_mode is redirect or auto_redirect
     * @type {string}
     * @memberof RefreshLoginIdentityLinkCustomizations
     */
    redirect_uri?: string;
    /**
     *
     * @type {string}
     * @memberof RefreshLoginIdentityLinkCustomizations
     */
    state?: string;
}
export declare const RefreshLoginIdentityLinkCustomizationsLanguageEnum: {
    readonly En: "en";
    readonly Vi: "vi";
    readonly Zh: "zh";
};
export type RefreshLoginIdentityLinkCustomizationsLanguageEnum = (typeof RefreshLoginIdentityLinkCustomizationsLanguageEnum)[keyof typeof RefreshLoginIdentityLinkCustomizationsLanguageEnum];
export declare const RefreshLoginIdentityLinkCustomizationsUiModeEnum: {
    readonly Iframe: "iframe";
    readonly Redirect: "redirect";
    readonly AutoRedirect: "auto_redirect";
    readonly Standalone: "standalone";
};
export type RefreshLoginIdentityLinkCustomizationsUiModeEnum = (typeof RefreshLoginIdentityLinkCustomizationsUiModeEnum)[keyof typeof RefreshLoginIdentityLinkCustomizationsUiModeEnum];
/**
 *
 * @export
 * @interface RefreshLoginIdentityRequest
 */
export interface RefreshLoginIdentityRequest {
    /**
     * Indicate whether the user is present in this flow. If the user is not present, only institutions that do not require 2fa can be refreshed
     * @type {boolean}
     * @memberof RefreshLoginIdentityRequest
     */
    user_present?: boolean;
    /**
     *
     * @type {RefreshLoginIdentityLinkCustomizations}
     * @memberof RefreshLoginIdentityRequest
     */
    link_customizations?: RefreshLoginIdentityLinkCustomizations;
}
/**
 *
 * @export
 * @interface RefreshPaymentAttemptResponse
 */
export interface RefreshPaymentAttemptResponse {
    /**
     *
     * @type {string}
     * @memberof RefreshPaymentAttemptResponse
     */
    redirect_url?: string;
}
/**
 *
 * @export
 * @interface RefreshRequest
 */
export interface RefreshRequest {
    /**
     *
     * @type {string}
     * @memberof RefreshRequest
     */
    refresh_token: string;
}
/**
 *
 * @export
 * @interface RefreshTokenResponse
 */
export interface RefreshTokenResponse {
    /**
     *
     * @type {string}
     * @memberof RefreshTokenResponse
     */
    access_token: string;
    /**
     *
     * @type {string}
     * @memberof RefreshTokenResponse
     */
    token_type: string;
    /**
     * seconds
     * @type {number}
     * @memberof RefreshTokenResponse
     */
    expires_in: number;
    /**
     *
     * @type {string}
     * @memberof RefreshTokenResponse
     */
    issued_at: string;
    /**
     *
     * @type {string}
     * @memberof RefreshTokenResponse
     */
    link_url: string;
    /**
     *
     * @type {string}
     * @memberof RefreshTokenResponse
     */
    login_identity_id: string;
}
/**
 *
 * @export
 * @interface RelinkRequest
 */
export interface RelinkRequest {
    /**
     *
     * @type {boolean}
     * @memberof RelinkRequest
     */
    store_credential: boolean;
    /**
     * this is a mandatory field
     * @type {boolean}
     * @memberof RelinkRequest
     */
    consent?: boolean | null;
}
/**
 *
 * @export
 * @interface SenderAccountFvLinkResponse
 */
export interface SenderAccountFvLinkResponse {
    /**
     *
     * @type {string}
     * @memberof SenderAccountFvLinkResponse
     */
    account_number_masked?: string;
    /**
     *
     * @type {string}
     * @memberof SenderAccountFvLinkResponse
     */
    institution_id?: string;
    /**
     *
     * @type {string}
     * @memberof SenderAccountFvLinkResponse
     */
    institution_name?: string;
}
/**
 *
 * @export
 * @interface SenderDetail
 */
export interface SenderDetail {
    /**
     * The type of the details. For e.g. HK_ID, PASSPORT etc
     * @type {string}
     * @memberof SenderDetail
     */
    details_type?: SenderDetailDetailsTypeEnum;
    /**
     * The possible values of the detail. For e.g. A123456 for HK_ID
     * @type {Array<string>}
     * @memberof SenderDetail
     */
    values?: Array<string>;
}
export declare const SenderDetailDetailsTypeEnum: {
    readonly HkId: "HK_ID";
    readonly Passport: "PASSPORT";
    readonly HkBusinessRegistration: "HK_BUSINESS_REGISTRATION";
    readonly HkCertificateOfIncorporation: "HK_CERTIFICATE_OF_INCORPORATION";
};
export type SenderDetailDetailsTypeEnum = (typeof SenderDetailDetailsTypeEnum)[keyof typeof SenderDetailDetailsTypeEnum];
/**
 *
 * @export
 * @interface SetAutopayConsentRequest
 */
export interface SetAutopayConsentRequest {
    /**
     *
     * @type {boolean}
     * @memberof SetAutopayConsentRequest
     */
    autopay_consent: boolean;
}
/**
 *
 * @export
 * @interface SetMandateInstitutionRequest
 */
export interface SetMandateInstitutionRequest {
    /**
     * Finverse Institution ID
     * @type {string}
     * @memberof SetMandateInstitutionRequest
     */
    institution_id: string;
}
/**
 *
 * @export
 * @interface SetMandateInstitutionResponse
 */
export interface SetMandateInstitutionResponse {
    /**
     * Finverse Mandate ID
     * @type {string}
     * @memberof SetMandateInstitutionResponse
     */
    mandate_id: string;
}
/**
 *
 * @export
 * @interface SingleSourceIncome
 */
export interface SingleSourceIncome {
    /**
     *
     * @type {Array<IncomeStream>}
     * @memberof SingleSourceIncome
     */
    income_streams: Array<IncomeStream>;
    /**
     *
     * @type {IncomeTotal}
     * @memberof SingleSourceIncome
     */
    income_total: IncomeTotal;
    /**
     * Where the income estimate was sourced from
     * @type {string}
     * @memberof SingleSourceIncome
     */
    source: string;
    /**
     * Unknown
     * @type {string}
     * @memberof SingleSourceIncome
     */
    source_id: string;
}
/**
 *
 * @export
 * @interface Statement
 */
export interface Statement {
    /**
     *
     * @type {string}
     * @memberof Statement
     */
    id?: string;
    /**
     * YYYY-MM-DD
     * @type {string}
     * @memberof Statement
     */
    date?: string;
    /**
     *
     * @type {string}
     * @memberof Statement
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof Statement
     */
    created_at?: string;
}
/**
 *
 * @export
 * @interface StatementLink
 */
export interface StatementLink {
    /**
     * signedURL to download statement
     * @type {string}
     * @memberof StatementLink
     */
    url?: string;
    /**
     * expiry of the signedURL
     * @type {string}
     * @memberof StatementLink
     */
    expiry?: string;
    /**
     *
     * @type {string}
     * @memberof StatementLink
     */
    statement_id?: string;
}
/**
 *
 * @export
 * @interface SubmitAuthChecklistRequest
 */
export interface SubmitAuthChecklistRequest {
    /**
     * The key_id that was used to encrypt the envelope key
     * @type {string}
     * @memberof SubmitAuthChecklistRequest
     */
    key_id: string;
    /**
     * The encrypted envelope key
     * @type {string}
     * @memberof SubmitAuthChecklistRequest
     */
    envelope_encryption_key: string;
    /**
     * The initialization vector used for enncrypting the payload
     * @type {string}
     * @memberof SubmitAuthChecklistRequest
     */
    initialization_vector: string;
    /**
     * The authentication code is used to authenticate the origin of the message
     * @type {string}
     * @memberof SubmitAuthChecklistRequest
     */
    message_authentication_code: string;
    /**
     * The encrypted payload that contains auth checklist items
     * @type {string}
     * @memberof SubmitAuthChecklistRequest
     */
    ciphertext: string;
}
/**
 *
 * @export
 * @interface SubmitAuthChecklistResponse
 */
export interface SubmitAuthChecklistResponse {
    /**
     * Finverse Mandate ID
     * @type {string}
     * @memberof SubmitAuthChecklistResponse
     */
    mandate_id: string;
    /**
     * Checklist of the authorization factors needed to complete Mandate authorization
     * @type {Array<AuthChecklistFactor>}
     * @memberof SubmitAuthChecklistResponse
     */
    auth_checklist: Array<AuthChecklistFactor>;
    /**
     * Mandate status
     * @type {string}
     * @memberof SubmitAuthChecklistResponse
     */
    mandate_status: SubmitAuthChecklistResponseMandateStatusEnum;
    /**
     * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
     * @type {string}
     * @memberof SubmitAuthChecklistResponse
     */
    last_update: string;
}
export declare const SubmitAuthChecklistResponseMandateStatusEnum: {
    readonly Created: "CREATED";
    readonly Processing: "PROCESSING";
    readonly Submitted: "SUBMITTED";
    readonly Error: "ERROR";
};
export type SubmitAuthChecklistResponseMandateStatusEnum = (typeof SubmitAuthChecklistResponseMandateStatusEnum)[keyof typeof SubmitAuthChecklistResponseMandateStatusEnum];
/**
 *
 * @export
 * @interface SwaggerErrBodyModel
 */
export interface SwaggerErrBodyModel {
    /**
     *
     * @type {number}
     * @memberof SwaggerErrBodyModel
     */
    code?: number;
    /**
     *
     * @type {string}
     * @memberof SwaggerErrBodyModel
     */
    message?: string;
    /**
     *
     * @type {FvErrorModel}
     * @memberof SwaggerErrBodyModel
     */
    error?: FvErrorModel;
}
/**
 *
 * @export
 * @interface TokenRequest
 */
export interface TokenRequest {
    /**
     *
     * @type {string}
     * @memberof TokenRequest
     */
    client_id: string;
    /**
     *
     * @type {string}
     * @memberof TokenRequest
     */
    client_secret: string;
    /**
     * support only client_credentials
     * @type {string}
     * @memberof TokenRequest
     */
    grant_type: string;
}
/**
 *
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     *
     * @type {string}
     * @memberof TokenResponse
     */
    access_token: string;
    /**
     *
     * @type {string}
     * @memberof TokenResponse
     */
    token_type: string;
    /**
     * seconds
     * @type {number}
     * @memberof TokenResponse
     */
    expires_in: number;
    /**
     *
     * @type {string}
     * @memberof TokenResponse
     */
    issued_at: string;
}
/**
 *
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     *
     * @type {string}
     * @memberof Transaction
     */
    transaction_id?: string;
    /**
     *
     * @type {string}
     * @memberof Transaction
     */
    account_id?: string;
    /**
     *
     * @type {string}
     * @memberof Transaction
     */
    transaction_state?: string;
    /**
     *
     * @type {string}
     * @memberof Transaction
     */
    transaction_type?: string;
    /**
     * (Deprecated)
     * @type {string}
     * @memberof Transaction
     */
    category?: string;
    /**
     * (Deprecated)
     * @type {string}
     * @memberof Transaction
     */
    category_id?: string;
    /**
     *
     * @type {string}
     * @memberof Transaction
     */
    merchant_name?: string;
    /**
     *
     * @type {string}
     * @memberof Transaction
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof Transaction
     */
    location?: string;
    /**
     *
     * @type {boolean}
     * @memberof Transaction
     */
    is_pending: boolean;
    /**
     *
     * @type {string}
     * @memberof Transaction
     */
    status?: string;
    /**
     * YYYY-MM-DD
     * @type {string}
     * @memberof Transaction
     */
    posted_date?: string;
    /**
     *
     * @type {CurrencyAmount}
     * @memberof Transaction
     */
    amount?: CurrencyAmount;
    /**
     * Transaction Details
     * @type {object}
     * @memberof Transaction
     */
    transaction_details?: object;
    /**
     *
     * @type {string}
     * @memberof Transaction
     */
    created_at?: string;
    /**
     *
     * @type {string}
     * @memberof Transaction
     */
    updated_at?: string;
    /**
     * Array of category labels
     * @type {Array<string>}
     * @memberof Transaction
     */
    categories?: Array<string>;
    /**
     * Optional field indicating when the transaction happened
     * @type {string}
     * @memberof Transaction
     */
    transaction_time?: string | null;
    /**
     * Transaction reference provided by the bank
     * @type {string}
     * @memberof Transaction
     */
    transaction_reference?: string;
    /**
     *
     * @type {Array<CategoryPredictions>}
     * @memberof Transaction
     */
    category_predictions?: Array<CategoryPredictions>;
}
/**
 *
 * @export
 * @interface TransactionLimits
 */
export interface TransactionLimits {
    /**
     * Maximum amount of money that can be paid during the reference period (across any number of transactions). Expressed in currency\'s smallest unit or “minor unit”, as defined in ISO 4217.
     * @type {number}
     * @memberof TransactionLimits
     */
    max_period_amount?: number;
    /**
     * Maximum number of transactions (of any amount) that can be executed during the reference period.
     * @type {number}
     * @memberof TransactionLimits
     */
    max_period_count?: number;
    /**
     * The maximum amount of money that can be transferred in a single transaction under this mandate. Expressed in currency\'s smallest unit or “minor unit”, as defined in ISO 4217.
     * @type {number}
     * @memberof TransactionLimits
     */
    max_transaction_amount: number;
    /**
     * Reference calendar periods for the payment limits. Possible values (DAILY, WEEKLY, MONTHLY, QUARTERLY, YEARLY)
     * @type {string}
     * @memberof TransactionLimits
     */
    period?: TransactionLimitsPeriodEnum | null;
}
export declare const TransactionLimitsPeriodEnum: {
    readonly Daily: "DAILY";
    readonly Weekly: "WEEKLY";
    readonly Monthly: "MONTHLY";
    readonly Quarterly: "QUARTERLY";
    readonly Yearly: "YEARLY";
};
export type TransactionLimitsPeriodEnum = (typeof TransactionLimitsPeriodEnum)[keyof typeof TransactionLimitsPeriodEnum];
/**
 *
 * @export
 * @interface UpdatePaymentRequest
 */
export interface UpdatePaymentRequest {
    [key: string]: any;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof UpdatePaymentRequest
     */
    metadata?: {
        [key: string]: string;
    };
}
/**
 *
 * @export
 * @interface UpdatePaymentUserRequest
 */
export interface UpdatePaymentUserRequest {
    [key: string]: any;
    /**
     *
     * @type {boolean}
     * @memberof UpdatePaymentUserRequest
     */
    autopay_consent?: boolean | null;
    /**
     *
     * @type {string}
     * @memberof UpdatePaymentUserRequest
     */
    email?: string | null;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof UpdatePaymentUserRequest
     */
    metadata?: {
        [key: string]: string;
    } | null;
    /**
     *
     * @type {string}
     * @memberof UpdatePaymentUserRequest
     */
    name?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdatePaymentUserRequest
     */
    next_bill_update?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdatePaymentUserRequest
     */
    user_type?: UpdatePaymentUserRequestUserTypeEnum | null;
}
export declare const UpdatePaymentUserRequestUserTypeEnum: {
    readonly Individual: "INDIVIDUAL";
    readonly Business: "BUSINESS";
};
export type UpdatePaymentUserRequestUserTypeEnum = (typeof UpdatePaymentUserRequestUserTypeEnum)[keyof typeof UpdatePaymentUserRequestUserTypeEnum];
/**
 *
 * @export
 * @interface UpdateTestPaymentStatusRequest
 */
export interface UpdateTestPaymentStatusRequest {
    /**
     * The payment status
     * @type {string}
     * @memberof UpdateTestPaymentStatusRequest
     */
    status?: UpdateTestPaymentStatusRequestStatusEnum;
}
export declare const UpdateTestPaymentStatusRequestStatusEnum: {
    readonly Executed: "EXECUTED";
};
export type UpdateTestPaymentStatusRequestStatusEnum = (typeof UpdateTestPaymentStatusRequestStatusEnum)[keyof typeof UpdateTestPaymentStatusRequestStatusEnum];
/**
 *
 * @export
 * @interface UserButton
 */
export interface UserButton {
    /**
     * The name of the button.
     * @type {string}
     * @memberof UserButton
     */
    name: string;
    /**
     * The text that will be displayed for this button
     * @type {string}
     * @memberof UserButton
     */
    value: string;
    /**
     * The type of button. Currently it can only be SUBMIT
     * @type {string}
     * @memberof UserButton
     */
    type: string;
}
/**
 *
 * @export
 * @interface UserField
 */
export interface UserField {
    /**
     * The name of the field. This will be used as the key when submitting response.
     * @type {string}
     * @memberof UserField
     */
    name: string;
    /**
     * The label for this field.
     * @type {string}
     * @memberof UserField
     */
    label?: string;
    /**
     * The placeholder for this field.
     * @type {string}
     * @memberof UserField
     */
    placeholder?: string;
    /**
     * The type of field. Currently it can only be SELECT, INPUT or PASSWORD
     * @type {string}
     * @memberof UserField
     */
    type: string;
    /**
     * This is only applicable when the field type is SELECT
     * @type {Array<UserFieldOption>}
     * @memberof UserField
     */
    options?: Array<UserFieldOption>;
}
/**
 *
 * @export
 * @interface UserFieldOption
 */
export interface UserFieldOption {
    /**
     * The value displayed in the select element.
     * @type {string}
     * @memberof UserFieldOption
     */
    label: string;
    /**
     * The value that will be submitted if this option was selected.
     * @type {string}
     * @memberof UserFieldOption
     */
    value: string;
}
/**
 *
 * @export
 * @interface UserMessage
 */
export interface UserMessage {
    /**
     * The name of the message
     * @type {string}
     * @memberof UserMessage
     */
    name: string;
    /**
     * The type of the message. This will help how the UI renders this text.
     * @type {string}
     * @memberof UserMessage
     */
    type: string;
    /**
     * The actual text value.
     * @type {string}
     * @memberof UserMessage
     */
    value: string;
}
/**
 * CustomerApi - axios parameter creator
 * @export
 */
export declare const CustomerApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Allows a customer to authorize a specific mandate
     * @param {string} mandateId The mandate_id that is being authorized
     * @param {AuthorizeMandateRequest} authorizeMandateRequest request body for authorizing a mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authorizeMandate: (mandateId: string, authorizeMandateRequest: AuthorizeMandateRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * CREATE Mandate
     * @param {CreateMandateRequest} createMandateRequest request body for creating mandate
     * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMandate: (createMandateRequest: CreateMandateRequest, idempotencyKey?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create new Payment
     * @param {CreatePaymentRequest} createPaymentRequest request body for creating payment
     * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPayment: (createPaymentRequest: CreatePaymentRequest, idempotencyKey?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * create payment account
     * @param {CreatePaymentAccountRequest} createPaymentAccountRequest request body for creating payment account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentAccount: (createPaymentAccountRequest: CreatePaymentAccountRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create a new payment instruction to be used when linking to perform new payment
     * @param {CustomerPaymentInstruction} paymentInstruction Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentInstruction: (paymentInstruction: CustomerPaymentInstruction, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create a payment user
     * @param {CreatePaymentUserRequest} createPaymentUserRequest request body for creating payment user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentUser: (createPaymentUserRequest: CreatePaymentUserRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * delete payment account
     * @param {string} paymentAccountId The payment account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePaymentAccount: (paymentAccountId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateLinkToken: (linkTokenRequest: LinkTokenRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a specific institution by institutionId
     * @param {string} institutionId The institution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstitution: (institutionId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get line items for display
     * @param {GetLineItemsForDisplayPaymentTypeEnum} paymentType The payment type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLineItemsForDisplay: (paymentType: GetLineItemsForDisplayPaymentTypeEnum, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentityById: (loginIdentityId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a history of events for a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentityHistory: (loginIdentityId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get Mandate details by mandate_id
     * @param {string} mandateId mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMandate: (mandateId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get Mandate Authorization by mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMandateAuth: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get link to launch FV Link UI in mandate authorization mode
     * @param {GetMandateAuthLinkRequest} getMandateAuthLinkRequest request body for mandate authorization link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMandateAuthLink: (getMandateAuthLinkRequest: GetMandateAuthLinkRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get Payment details by payment_id
     * @param {string} paymentId payment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayment: (paymentId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get payment instructions by payment_instruction_id
     * @param {string} paymentInstructionId The id of a payment instruction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentInstruction: (paymentInstructionId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a payment user
     * @param {string} paymentUserId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentUser: (paymentUserId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a list of institutions
     * @param {string} [country] (Deprecated) The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {ListInstitutionsInstitutionTypeEnum} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInstitutions: (country?: string, countries?: Array<string>, productsSupported?: string, institutionType?: ListInstitutionsInstitutionTypeEnum, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get payment account by user id
     * @param {string} paymentUserId The payment user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentAccounts: (paymentUserId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get payment account for customer app
     * @param {ListPaymentAccountsWithEnrichedDataAccountTypeEnum} [accountType] The account_type to filter for
     * @param {Array<string>} [currencies] The currencies to filter for
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentAccountsWithEnrichedData: (accountType?: ListPaymentAccountsWithEnrichedDataAccountTypeEnum, currencies?: Array<string>, offset?: number, limit?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Refresh an access token
     * @param {RefreshRequest} refreshRequest The refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken: (refreshRequest: RefreshRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update InstitutionID and SenderType for Mandate
     * @param {SetMandateInstitutionRequest} updateRequest request body for updating mandate institutionId and senderType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMandateInstitution: (updateRequest: SetMandateInstitutionRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Submit authorization checklist items
     * @param {SubmitAuthChecklistRequest} submitAuthChecklistRequest request body for submitting auth checklist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitAuthChecklist: (submitAuthChecklistRequest: SubmitAuthChecklistRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update payment
     * @param {string} paymentId payment id
     * @param {UpdatePaymentRequest} updatePaymentRequest request body for updating payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePayment: (paymentId: string, updatePaymentRequest: UpdatePaymentRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update the status of a test manual payment
     * @param {string} paymentId The test payment ID
     * @param {UpdateTestPaymentStatusRequest} paymentStatus Request body for updating the test manual payment status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTestPaymentStatus: (paymentId: string, paymentStatus: UpdateTestPaymentStatusRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * CustomerApi - functional programming interface
 * @export
 */
export declare const CustomerApiFp: (configuration?: Configuration) => {
    /**
     * Allows a customer to authorize a specific mandate
     * @param {string} mandateId The mandate_id that is being authorized
     * @param {AuthorizeMandateRequest} authorizeMandateRequest request body for authorizing a mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authorizeMandate(mandateId: string, authorizeMandateRequest: AuthorizeMandateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMandateResponse>>;
    /**
     * CREATE Mandate
     * @param {CreateMandateRequest} createMandateRequest request body for creating mandate
     * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMandate(createMandateRequest: CreateMandateRequest, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMandateResponse>>;
    /**
     * Create new Payment
     * @param {CreatePaymentRequest} createPaymentRequest request body for creating payment
     * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPayment(createPaymentRequest: CreatePaymentRequest, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentResponse>>;
    /**
     * create payment account
     * @param {CreatePaymentAccountRequest} createPaymentAccountRequest request body for creating payment account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentAccount(createPaymentAccountRequest: CreatePaymentAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentAccountDetails>>;
    /**
     * Create a new payment instruction to be used when linking to perform new payment
     * @param {CustomerPaymentInstruction} paymentInstruction Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentInstruction(paymentInstruction: CustomerPaymentInstruction, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePaymentInstructionResponse>>;
    /**
     * Create a payment user
     * @param {CreatePaymentUserRequest} createPaymentUserRequest request body for creating payment user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentUser(createPaymentUserRequest: CreatePaymentUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentUser>>;
    /**
     * delete payment account
     * @param {string} paymentAccountId The payment account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePaymentAccount(paymentAccountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkTokenResponse>>;
    /**
     * Get a specific institution by institutionId
     * @param {string} institutionId The institution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstitution(institutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Institution>>;
    /**
     * Get line items for display
     * @param {GetLineItemsForDisplayPaymentTypeEnum} paymentType The payment type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLineItemsForDisplay(paymentType: GetLineItemsForDisplayPaymentTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLineItemsForDisplayResponse>>;
    /**
     * Get a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentityById(loginIdentityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLoginIdentityByIdResponse>>;
    /**
     * Get a history of events for a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentityHistory(loginIdentityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLoginIdentityHistoryResponse>>;
    /**
     * Get Mandate details by mandate_id
     * @param {string} mandateId mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMandate(mandateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMandateResponse>>;
    /**
     * Get Mandate Authorization by mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMandateAuth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMandateAuthResponse>>;
    /**
     * Get link to launch FV Link UI in mandate authorization mode
     * @param {GetMandateAuthLinkRequest} getMandateAuthLinkRequest request body for mandate authorization link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMandateAuthLink(getMandateAuthLinkRequest: GetMandateAuthLinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMandateAuthLinkResponse>>;
    /**
     * Get Payment details by payment_id
     * @param {string} paymentId payment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayment(paymentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentResponse>>;
    /**
     * Get payment instructions by payment_instruction_id
     * @param {string} paymentInstructionId The id of a payment instruction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentInstruction(paymentInstructionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPaymentInstructionsResponse>>;
    /**
     * Get a payment user
     * @param {string} paymentUserId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentUser(paymentUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentUser>>;
    /**
     * Get a list of institutions
     * @param {string} [country] (Deprecated) The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {ListInstitutionsInstitutionTypeEnum} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInstitutions(country?: string, countries?: Array<string>, productsSupported?: string, institutionType?: ListInstitutionsInstitutionTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Institution>>>;
    /**
     * Get payment account by user id
     * @param {string} paymentUserId The payment user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentAccounts(paymentUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPaymentAccountsResponse>>;
    /**
     * Get payment account for customer app
     * @param {ListPaymentAccountsWithEnrichedDataAccountTypeEnum} [accountType] The account_type to filter for
     * @param {Array<string>} [currencies] The currencies to filter for
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentAccountsWithEnrichedData(accountType?: ListPaymentAccountsWithEnrichedDataAccountTypeEnum, currencies?: Array<string>, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPaymentAccountsWithEnrichedDataResponse>>;
    /**
     * Refresh an access token
     * @param {RefreshRequest} refreshRequest The refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken(refreshRequest: RefreshRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokenResponse>>;
    /**
     * Update InstitutionID and SenderType for Mandate
     * @param {SetMandateInstitutionRequest} updateRequest request body for updating mandate institutionId and senderType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMandateInstitution(updateRequest: SetMandateInstitutionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetMandateInstitutionResponse>>;
    /**
     * Submit authorization checklist items
     * @param {SubmitAuthChecklistRequest} submitAuthChecklistRequest request body for submitting auth checklist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitAuthChecklist(submitAuthChecklistRequest: SubmitAuthChecklistRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitAuthChecklistResponse>>;
    /**
     * Update payment
     * @param {string} paymentId payment id
     * @param {UpdatePaymentRequest} updatePaymentRequest request body for updating payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePayment(paymentId: string, updatePaymentRequest: UpdatePaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentResponse>>;
    /**
     * Update the status of a test manual payment
     * @param {string} paymentId The test payment ID
     * @param {UpdateTestPaymentStatusRequest} paymentStatus Request body for updating the test manual payment status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTestPaymentStatus(paymentId: string, paymentStatus: UpdateTestPaymentStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * CustomerApi - factory interface
 * @export
 */
export declare const CustomerApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Allows a customer to authorize a specific mandate
     * @param {string} mandateId The mandate_id that is being authorized
     * @param {AuthorizeMandateRequest} authorizeMandateRequest request body for authorizing a mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authorizeMandate(mandateId: string, authorizeMandateRequest: AuthorizeMandateRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetMandateResponse>;
    /**
     * CREATE Mandate
     * @param {CreateMandateRequest} createMandateRequest request body for creating mandate
     * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMandate(createMandateRequest: CreateMandateRequest, idempotencyKey?: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateMandateResponse>;
    /**
     * Create new Payment
     * @param {CreatePaymentRequest} createPaymentRequest request body for creating payment
     * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPayment(createPaymentRequest: CreatePaymentRequest, idempotencyKey?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentResponse>;
    /**
     * create payment account
     * @param {CreatePaymentAccountRequest} createPaymentAccountRequest request body for creating payment account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentAccount(createPaymentAccountRequest: CreatePaymentAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaymentAccountDetails>;
    /**
     * Create a new payment instruction to be used when linking to perform new payment
     * @param {CustomerPaymentInstruction} paymentInstruction Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentInstruction(paymentInstruction: CustomerPaymentInstruction, options?: RawAxiosRequestConfig): AxiosPromise<CreatePaymentInstructionResponse>;
    /**
     * Create a payment user
     * @param {CreatePaymentUserRequest} createPaymentUserRequest request body for creating payment user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentUser(createPaymentUserRequest: CreatePaymentUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaymentUser>;
    /**
     * delete payment account
     * @param {string} paymentAccountId The payment account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePaymentAccount(paymentAccountId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<LinkTokenResponse>;
    /**
     * Get a specific institution by institutionId
     * @param {string} institutionId The institution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstitution(institutionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Institution>;
    /**
     * Get line items for display
     * @param {GetLineItemsForDisplayPaymentTypeEnum} paymentType The payment type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLineItemsForDisplay(paymentType: GetLineItemsForDisplayPaymentTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetLineItemsForDisplayResponse>;
    /**
     * Get a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentityById(loginIdentityId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetLoginIdentityByIdResponse>;
    /**
     * Get a history of events for a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentityHistory(loginIdentityId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetLoginIdentityHistoryResponse>;
    /**
     * Get Mandate details by mandate_id
     * @param {string} mandateId mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMandate(mandateId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetMandateResponse>;
    /**
     * Get Mandate Authorization by mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMandateAuth(options?: RawAxiosRequestConfig): AxiosPromise<GetMandateAuthResponse>;
    /**
     * Get link to launch FV Link UI in mandate authorization mode
     * @param {GetMandateAuthLinkRequest} getMandateAuthLinkRequest request body for mandate authorization link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMandateAuthLink(getMandateAuthLinkRequest: GetMandateAuthLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetMandateAuthLinkResponse>;
    /**
     * Get Payment details by payment_id
     * @param {string} paymentId payment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayment(paymentId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentResponse>;
    /**
     * Get payment instructions by payment_instruction_id
     * @param {string} paymentInstructionId The id of a payment instruction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentInstruction(paymentInstructionId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetPaymentInstructionsResponse>;
    /**
     * Get a payment user
     * @param {string} paymentUserId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentUser(paymentUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentUser>;
    /**
     * Get a list of institutions
     * @param {string} [country] (Deprecated) The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {ListInstitutionsInstitutionTypeEnum} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInstitutions(country?: string, countries?: Array<string>, productsSupported?: string, institutionType?: ListInstitutionsInstitutionTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<Institution>>;
    /**
     * Get payment account by user id
     * @param {string} paymentUserId The payment user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentAccounts(paymentUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<ListPaymentAccountsResponse>;
    /**
     * Get payment account for customer app
     * @param {ListPaymentAccountsWithEnrichedDataAccountTypeEnum} [accountType] The account_type to filter for
     * @param {Array<string>} [currencies] The currencies to filter for
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentAccountsWithEnrichedData(accountType?: ListPaymentAccountsWithEnrichedDataAccountTypeEnum, currencies?: Array<string>, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListPaymentAccountsWithEnrichedDataResponse>;
    /**
     * Refresh an access token
     * @param {RefreshRequest} refreshRequest The refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken(refreshRequest: RefreshRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccessTokenResponse>;
    /**
     * Update InstitutionID and SenderType for Mandate
     * @param {SetMandateInstitutionRequest} updateRequest request body for updating mandate institutionId and senderType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMandateInstitution(updateRequest: SetMandateInstitutionRequest, options?: RawAxiosRequestConfig): AxiosPromise<SetMandateInstitutionResponse>;
    /**
     * Submit authorization checklist items
     * @param {SubmitAuthChecklistRequest} submitAuthChecklistRequest request body for submitting auth checklist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitAuthChecklist(submitAuthChecklistRequest: SubmitAuthChecklistRequest, options?: RawAxiosRequestConfig): AxiosPromise<SubmitAuthChecklistResponse>;
    /**
     * Update payment
     * @param {string} paymentId payment id
     * @param {UpdatePaymentRequest} updatePaymentRequest request body for updating payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePayment(paymentId: string, updatePaymentRequest: UpdatePaymentRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaymentResponse>;
    /**
     * Update the status of a test manual payment
     * @param {string} paymentId The test payment ID
     * @param {UpdateTestPaymentStatusRequest} paymentStatus Request body for updating the test manual payment status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTestPaymentStatus(paymentId: string, paymentStatus: UpdateTestPaymentStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;
};
/**
 * CustomerApi - interface
 * @export
 * @interface CustomerApi
 */
export interface CustomerApiInterface {
    /**
     * Allows a customer to authorize a specific mandate
     * @param {string} mandateId The mandate_id that is being authorized
     * @param {AuthorizeMandateRequest} authorizeMandateRequest request body for authorizing a mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    authorizeMandate(mandateId: string, authorizeMandateRequest: AuthorizeMandateRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetMandateResponse>;
    /**
     * CREATE Mandate
     * @param {CreateMandateRequest} createMandateRequest request body for creating mandate
     * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    createMandate(createMandateRequest: CreateMandateRequest, idempotencyKey?: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateMandateResponse>;
    /**
     * Create new Payment
     * @param {CreatePaymentRequest} createPaymentRequest request body for creating payment
     * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    createPayment(createPaymentRequest: CreatePaymentRequest, idempotencyKey?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentResponse>;
    /**
     * create payment account
     * @param {CreatePaymentAccountRequest} createPaymentAccountRequest request body for creating payment account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    createPaymentAccount(createPaymentAccountRequest: CreatePaymentAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaymentAccountDetails>;
    /**
     * Create a new payment instruction to be used when linking to perform new payment
     * @param {CustomerPaymentInstruction} paymentInstruction Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    createPaymentInstruction(paymentInstruction: CustomerPaymentInstruction, options?: RawAxiosRequestConfig): AxiosPromise<CreatePaymentInstructionResponse>;
    /**
     * Create a payment user
     * @param {CreatePaymentUserRequest} createPaymentUserRequest request body for creating payment user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    createPaymentUser(createPaymentUserRequest: CreatePaymentUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaymentUser>;
    /**
     * delete payment account
     * @param {string} paymentAccountId The payment account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    deletePaymentAccount(paymentAccountId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<LinkTokenResponse>;
    /**
     * Get a specific institution by institutionId
     * @param {string} institutionId The institution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    getInstitution(institutionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Institution>;
    /**
     * Get line items for display
     * @param {GetLineItemsForDisplayPaymentTypeEnum} paymentType The payment type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    getLineItemsForDisplay(paymentType: GetLineItemsForDisplayPaymentTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetLineItemsForDisplayResponse>;
    /**
     * Get a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    getLoginIdentityById(loginIdentityId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetLoginIdentityByIdResponse>;
    /**
     * Get a history of events for a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    getLoginIdentityHistory(loginIdentityId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetLoginIdentityHistoryResponse>;
    /**
     * Get Mandate details by mandate_id
     * @param {string} mandateId mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    getMandate(mandateId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetMandateResponse>;
    /**
     * Get Mandate Authorization by mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    getMandateAuth(options?: RawAxiosRequestConfig): AxiosPromise<GetMandateAuthResponse>;
    /**
     * Get link to launch FV Link UI in mandate authorization mode
     * @param {GetMandateAuthLinkRequest} getMandateAuthLinkRequest request body for mandate authorization link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    getMandateAuthLink(getMandateAuthLinkRequest: GetMandateAuthLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetMandateAuthLinkResponse>;
    /**
     * Get Payment details by payment_id
     * @param {string} paymentId payment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    getPayment(paymentId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentResponse>;
    /**
     * Get payment instructions by payment_instruction_id
     * @param {string} paymentInstructionId The id of a payment instruction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    getPaymentInstruction(paymentInstructionId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetPaymentInstructionsResponse>;
    /**
     * Get a payment user
     * @param {string} paymentUserId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    getPaymentUser(paymentUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentUser>;
    /**
     * Get a list of institutions
     * @param {string} [country] (Deprecated) The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {ListInstitutionsInstitutionTypeEnum} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    listInstitutions(country?: string, countries?: Array<string>, productsSupported?: string, institutionType?: ListInstitutionsInstitutionTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<Institution>>;
    /**
     * Get payment account by user id
     * @param {string} paymentUserId The payment user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    listPaymentAccounts(paymentUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<ListPaymentAccountsResponse>;
    /**
     * Get payment account for customer app
     * @param {ListPaymentAccountsWithEnrichedDataAccountTypeEnum} [accountType] The account_type to filter for
     * @param {Array<string>} [currencies] The currencies to filter for
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    listPaymentAccountsWithEnrichedData(accountType?: ListPaymentAccountsWithEnrichedDataAccountTypeEnum, currencies?: Array<string>, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListPaymentAccountsWithEnrichedDataResponse>;
    /**
     * Refresh an access token
     * @param {RefreshRequest} refreshRequest The refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    refreshToken(refreshRequest: RefreshRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccessTokenResponse>;
    /**
     * Update InstitutionID and SenderType for Mandate
     * @param {SetMandateInstitutionRequest} updateRequest request body for updating mandate institutionId and senderType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    setMandateInstitution(updateRequest: SetMandateInstitutionRequest, options?: RawAxiosRequestConfig): AxiosPromise<SetMandateInstitutionResponse>;
    /**
     * Submit authorization checklist items
     * @param {SubmitAuthChecklistRequest} submitAuthChecklistRequest request body for submitting auth checklist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    submitAuthChecklist(submitAuthChecklistRequest: SubmitAuthChecklistRequest, options?: RawAxiosRequestConfig): AxiosPromise<SubmitAuthChecklistResponse>;
    /**
     * Update payment
     * @param {string} paymentId payment id
     * @param {UpdatePaymentRequest} updatePaymentRequest request body for updating payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    updatePayment(paymentId: string, updatePaymentRequest: UpdatePaymentRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaymentResponse>;
    /**
     * Update the status of a test manual payment
     * @param {string} paymentId The test payment ID
     * @param {UpdateTestPaymentStatusRequest} paymentStatus Request body for updating the test manual payment status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    updateTestPaymentStatus(paymentId: string, paymentStatus: UpdateTestPaymentStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;
}
/**
 * CustomerApi - object-oriented interface
 * @export
 * @class CustomerApi
 * @extends {BaseAPI}
 */
export declare class CustomerApi extends BaseAPI implements CustomerApiInterface {
    /**
     * Allows a customer to authorize a specific mandate
     * @param {string} mandateId The mandate_id that is being authorized
     * @param {AuthorizeMandateRequest} authorizeMandateRequest request body for authorizing a mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    authorizeMandate(mandateId: string, authorizeMandateRequest: AuthorizeMandateRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetMandateResponse, any>>;
    /**
     * CREATE Mandate
     * @param {CreateMandateRequest} createMandateRequest request body for creating mandate
     * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    createMandate(createMandateRequest: CreateMandateRequest, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<CreateMandateResponse, any>>;
    /**
     * Create new Payment
     * @param {CreatePaymentRequest} createPaymentRequest request body for creating payment
     * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    createPayment(createPaymentRequest: CreatePaymentRequest, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaymentResponse, any>>;
    /**
     * create payment account
     * @param {CreatePaymentAccountRequest} createPaymentAccountRequest request body for creating payment account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    createPaymentAccount(createPaymentAccountRequest: CreatePaymentAccountRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaymentAccountDetails, any>>;
    /**
     * Create a new payment instruction to be used when linking to perform new payment
     * @param {CustomerPaymentInstruction} paymentInstruction Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    createPaymentInstruction(paymentInstruction: CustomerPaymentInstruction, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<CreatePaymentInstructionResponse, any>>;
    /**
     * Create a payment user
     * @param {CreatePaymentUserRequest} createPaymentUserRequest request body for creating payment user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    createPaymentUser(createPaymentUserRequest: CreatePaymentUserRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaymentUser, any>>;
    /**
     * delete payment account
     * @param {string} paymentAccountId The payment account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    deletePaymentAccount(paymentAccountId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<LinkTokenResponse, any>>;
    /**
     * Get a specific institution by institutionId
     * @param {string} institutionId The institution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    getInstitution(institutionId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Institution, any>>;
    /**
     * Get line items for display
     * @param {GetLineItemsForDisplayPaymentTypeEnum} paymentType The payment type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    getLineItemsForDisplay(paymentType: GetLineItemsForDisplayPaymentTypeEnum, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetLineItemsForDisplayResponse, any>>;
    /**
     * Get a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    getLoginIdentityById(loginIdentityId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetLoginIdentityByIdResponse, any>>;
    /**
     * Get a history of events for a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    getLoginIdentityHistory(loginIdentityId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetLoginIdentityHistoryResponse, any>>;
    /**
     * Get Mandate details by mandate_id
     * @param {string} mandateId mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    getMandate(mandateId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetMandateResponse, any>>;
    /**
     * Get Mandate Authorization by mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    getMandateAuth(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetMandateAuthResponse, any>>;
    /**
     * Get link to launch FV Link UI in mandate authorization mode
     * @param {GetMandateAuthLinkRequest} getMandateAuthLinkRequest request body for mandate authorization link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    getMandateAuthLink(getMandateAuthLinkRequest: GetMandateAuthLinkRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetMandateAuthLinkResponse, any>>;
    /**
     * Get Payment details by payment_id
     * @param {string} paymentId payment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    getPayment(paymentId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaymentResponse, any>>;
    /**
     * Get payment instructions by payment_instruction_id
     * @param {string} paymentInstructionId The id of a payment instruction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    getPaymentInstruction(paymentInstructionId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetPaymentInstructionsResponse, any>>;
    /**
     * Get a payment user
     * @param {string} paymentUserId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    getPaymentUser(paymentUserId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaymentUser, any>>;
    /**
     * Get a list of institutions
     * @param {string} [country] (Deprecated) The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {ListInstitutionsInstitutionTypeEnum} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    listInstitutions(country?: string, countries?: Array<string>, productsSupported?: string, institutionType?: ListInstitutionsInstitutionTypeEnum, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Institution[], any>>;
    /**
     * Get payment account by user id
     * @param {string} paymentUserId The payment user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    listPaymentAccounts(paymentUserId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListPaymentAccountsResponse, any>>;
    /**
     * Get payment account for customer app
     * @param {ListPaymentAccountsWithEnrichedDataAccountTypeEnum} [accountType] The account_type to filter for
     * @param {Array<string>} [currencies] The currencies to filter for
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    listPaymentAccountsWithEnrichedData(accountType?: ListPaymentAccountsWithEnrichedDataAccountTypeEnum, currencies?: Array<string>, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListPaymentAccountsWithEnrichedDataResponse, any>>;
    /**
     * Refresh an access token
     * @param {RefreshRequest} refreshRequest The refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    refreshToken(refreshRequest: RefreshRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<AccessTokenResponse, any>>;
    /**
     * Update InstitutionID and SenderType for Mandate
     * @param {SetMandateInstitutionRequest} updateRequest request body for updating mandate institutionId and senderType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    setMandateInstitution(updateRequest: SetMandateInstitutionRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<SetMandateInstitutionResponse, any>>;
    /**
     * Submit authorization checklist items
     * @param {SubmitAuthChecklistRequest} submitAuthChecklistRequest request body for submitting auth checklist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    submitAuthChecklist(submitAuthChecklistRequest: SubmitAuthChecklistRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<SubmitAuthChecklistResponse, any>>;
    /**
     * Update payment
     * @param {string} paymentId payment id
     * @param {UpdatePaymentRequest} updatePaymentRequest request body for updating payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    updatePayment(paymentId: string, updatePaymentRequest: UpdatePaymentRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaymentResponse, any>>;
    /**
     * Update the status of a test manual payment
     * @param {string} paymentId The test payment ID
     * @param {UpdateTestPaymentStatusRequest} paymentStatus Request body for updating the test manual payment status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    updateTestPaymentStatus(paymentId: string, paymentStatus: UpdateTestPaymentStatusRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * @export
 */
export declare const GetLineItemsForDisplayPaymentTypeEnum: {
    readonly Mandate: "MANDATE";
    readonly Manual: "MANUAL";
};
export type GetLineItemsForDisplayPaymentTypeEnum = (typeof GetLineItemsForDisplayPaymentTypeEnum)[keyof typeof GetLineItemsForDisplayPaymentTypeEnum];
/**
 * @export
 */
export declare const ListInstitutionsInstitutionTypeEnum: {
    readonly Bank: "BANK";
    readonly Wallet: "WALLET";
    readonly Test: "TEST";
};
export type ListInstitutionsInstitutionTypeEnum = (typeof ListInstitutionsInstitutionTypeEnum)[keyof typeof ListInstitutionsInstitutionTypeEnum];
/**
 * @export
 */
export declare const ListPaymentAccountsWithEnrichedDataAccountTypeEnum: {
    readonly ExternalAccount: "EXTERNAL_ACCOUNT";
    readonly SettlementAccount: "SETTLEMENT_ACCOUNT";
};
export type ListPaymentAccountsWithEnrichedDataAccountTypeEnum = (typeof ListPaymentAccountsWithEnrichedDataAccountTypeEnum)[keyof typeof ListPaymentAccountsWithEnrichedDataAccountTypeEnum];
/**
 * DefaultApi - axios parameter creator
 * @export
 */
export declare const DefaultApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Cancel a payment link
     * @param {string} paymentLinkId The payment link id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelPaymentLink: (paymentLinkId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Cancel Payout by payout_id
     * @param {string} payoutId payout id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelPayout: (payoutId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Initiate change payment method from payment link front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePaymentMethodPaymentLink: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Submit manual payment confirmation
     * @param {ManualPaymentConfirmationRequest} manualPaymentIdentifiers Request body containing information to identify manual payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmManualPayment: (manualPaymentIdentifiers: ManualPaymentConfirmationRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Confirm a payment against a payment Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmPayment: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create token for fps flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFpsToken: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create mandate for an existing sender account
     * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {CreateMandateWithSenderAccountRequest} createMandateRequest request body for creating mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMandateForExistingSender: (idempotencyKey: string, createMandateRequest: CreateMandateWithSenderAccountRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create payment link
     * @param {CreatePaymentLinkRequest} createPaymentLinkRequest Parameters required to create a payment link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentLink: (createPaymentLinkRequest: CreatePaymentLinkRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Initiate Card Payment for a Payment Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentLinkCardPayment: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * CREATE Mandate for payment link
     * @param {CreatePaymentLinkMandateRequest} createPaymentLinkMandateRequest request body for creating mandate for payment-link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentLinkMandate: (createPaymentLinkMandateRequest: CreatePaymentLinkMandateRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create a Payment Method for a user
     * @param {string} paymentUserId Payment User ID
     * @param {CreatePaymentMethodRequest} createPaymentMethodRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentMethod: (paymentUserId: string, createPaymentMethodRequest: CreatePaymentMethodRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create a scheduled payout
     * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {CreateScheduledPayoutRequest} createScheduledPayoutRequest Request body containing information to create scheduled payout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createScheduledPayout: (idempotencyKey: string, createScheduledPayoutRequest: CreateScheduledPayoutRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Demote payment attempt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    demotePaymentAttempt: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Download the balance statement for the ledger (CSV)
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<string>} [currencies] The currencies to filter for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadBalanceStatement: (dateFrom?: string, dateTo?: string, currencies?: Array<string>, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the FPS QR code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFpsQrCode: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a customer-specific list of institutions for Finverse Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstitutionsForCustomer: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get payment link
     * @param {string} paymentLinkId The payment link id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentLink: (paymentLinkId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a payment method
     * @param {string} paymentMethodId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentMethod: (paymentMethodId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get payment method in payment link flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentMethodPaymentLink: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get payment (if exists) on the payment link for front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentPaymentLink: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get payout by payout_id
     * @param {string} payoutId payout id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayoutById: (payoutId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get sender payment user in payment link flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSenderPaymentUser: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List mandates details
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListDetokenizedMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
     * @param {ListDetokenizedMandatesSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDetokenizedMandates: (dateFrom?: string, dateTo?: string, statuses?: Array<ListDetokenizedMandatesStatusesEnum>, senderType?: ListDetokenizedMandatesSenderTypeEnum, userId?: string, institutionId?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List Disputes
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListDisputesStatusesEnum>} [statuses] The dispute statuses to filter for, comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDisputes: (dateFrom?: string, dateTo?: string, statuses?: Array<ListDisputesStatusesEnum>, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List mandates
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
     * @param {ListMandatesSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMandates: (dateFrom?: string, dateTo?: string, statuses?: Array<ListMandatesStatusesEnum>, senderType?: ListMandatesSenderTypeEnum, userId?: string, institutionId?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List Payment Methods for a User
     * @param {string} paymentUserId Payment User Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentMethods: (paymentUserId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List Payments
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListPaymentsStatusesEnum>} [statuses] The payment statuses to filter for, comma separated
     * @param {ListPaymentsSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {ListPaymentsPaymentTypeEnum} [paymentType] Deprecated - The type of payment
     * @param {Array<ListPaymentsPaymentTypesEnum>} [paymentTypes]
     * @param {string} [mandateId] The mandate the payment belongs to
     * @param {string} [currency] Deprecated - The currency the payment is made in
     * @param {Array<string>} [currencies]
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPayments: (dateFrom?: string, dateTo?: string, statuses?: Array<ListPaymentsStatusesEnum>, senderType?: ListPaymentsSenderTypeEnum, userId?: string, institutionId?: string, paymentType?: ListPaymentsPaymentTypeEnum, paymentTypes?: Array<ListPaymentsPaymentTypesEnum>, mandateId?: string, currency?: string, currencies?: Array<string>, offset?: number, limit?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List payouts
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListPayoutsStatusesEnum>} [statuses] The payout statuses to filter for, comma separated
     * @param {Array<string>} [currencies]
     * @param {Array<ListPayoutsPayoutTypesEnum>} [payoutTypes]
     * @param {string} [mandateId]
     * @param {string} [senderAccountId]
     * @param {string} [recipientAccountId]
     * @param {string} [recipientUserId]
     * @param {string} [recipientExternalUserId]
     * @param {number} [offset] Default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPayouts: (dateFrom?: string, dateTo?: string, statuses?: Array<ListPayoutsStatusesEnum>, currencies?: Array<string>, payoutTypes?: Array<ListPayoutsPayoutTypesEnum>, mandateId?: string, senderAccountId?: string, recipientAccountId?: string, recipientUserId?: string, recipientExternalUserId?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Refresh payment attempt from payment link front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshPaymentAttempt: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Set autopay consent for payment user
     * @param {SetAutopayConsentRequest} setAutopayConsentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setAutopayConsent: (setAutopayConsentRequest: SetAutopayConsentRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update a payment user
     * @param {string} paymentUserId
     * @param {UpdatePaymentUserRequest} updatePaymentUserRequest request body for updating payment user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePaymentUser: (paymentUserId: string, updatePaymentUserRequest: UpdatePaymentUserRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * DefaultApi - functional programming interface
 * @export
 */
export declare const DefaultApiFp: (configuration?: Configuration) => {
    /**
     * Cancel a payment link
     * @param {string} paymentLinkId The payment link id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelPaymentLink(paymentLinkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentLinkResponse>>;
    /**
     * Cancel Payout by payout_id
     * @param {string} payoutId payout id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelPayout(payoutId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutSnapshotResponse>>;
    /**
     * Initiate change payment method from payment link front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePaymentMethodPaymentLink(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangePaymentMethodFvLinkResponse>>;
    /**
     * Submit manual payment confirmation
     * @param {ManualPaymentConfirmationRequest} manualPaymentIdentifiers Request body containing information to identify manual payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmManualPayment(manualPaymentIdentifiers: ManualPaymentConfirmationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManualPaymentConfirmationResponse>>;
    /**
     * Confirm a payment against a payment Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmPayment(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfirmPaymentResponse>>;
    /**
     * Create token for fps flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFpsToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFpsTokenResponse>>;
    /**
     * Create mandate for an existing sender account
     * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {CreateMandateWithSenderAccountRequest} createMandateRequest request body for creating mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMandateForExistingSender(idempotencyKey: string, createMandateRequest: CreateMandateWithSenderAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMandateResponse>>;
    /**
     * Create payment link
     * @param {CreatePaymentLinkRequest} createPaymentLinkRequest Parameters required to create a payment link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentLink(createPaymentLinkRequest: CreatePaymentLinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentLinkResponse>>;
    /**
     * Initiate Card Payment for a Payment Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentLinkCardPayment(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePaymentLinkCardPaymentResponse>>;
    /**
     * CREATE Mandate for payment link
     * @param {CreatePaymentLinkMandateRequest} createPaymentLinkMandateRequest request body for creating mandate for payment-link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentLinkMandate(createPaymentLinkMandateRequest: CreatePaymentLinkMandateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePaymentLinkMandateResponse>>;
    /**
     * Create a Payment Method for a user
     * @param {string} paymentUserId Payment User ID
     * @param {CreatePaymentMethodRequest} createPaymentMethodRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentMethod(paymentUserId: string, createPaymentMethodRequest: CreatePaymentMethodRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethodResponse>>;
    /**
     * Create a scheduled payout
     * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {CreateScheduledPayoutRequest} createScheduledPayoutRequest Request body containing information to create scheduled payout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createScheduledPayout(idempotencyKey: string, createScheduledPayoutRequest: CreateScheduledPayoutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutSnapshotResponse>>;
    /**
     * Demote payment attempt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    demotePaymentAttempt(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Download the balance statement for the ledger (CSV)
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<string>} [currencies] The currencies to filter for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadBalanceStatement(dateFrom?: string, dateTo?: string, currencies?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DownloadBalanceStatementResponse>>;
    /**
     * Get the FPS QR code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFpsQrCode(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FpsQrCodeResponse>>;
    /**
     * Get a customer-specific list of institutions for Finverse Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstitutionsForCustomer(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Institution>>>;
    /**
     * Get payment link
     * @param {string} paymentLinkId The payment link id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentLink(paymentLinkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentLinkResponse>>;
    /**
     * Get a payment method
     * @param {string} paymentMethodId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentMethod(paymentMethodId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethodResponse>>;
    /**
     * Get payment method in payment link flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentMethodPaymentLink(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethodFvLinkResponse>>;
    /**
     * Get payment (if exists) on the payment link for front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentPaymentLink(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentFvLinkResponse>>;
    /**
     * Get payout by payout_id
     * @param {string} payoutId payout id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayoutById(payoutId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutSnapshotResponse>>;
    /**
     * Get sender payment user in payment link flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSenderPaymentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPaymentUserResponse>>;
    /**
     * List mandates details
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListDetokenizedMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
     * @param {ListDetokenizedMandatesSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDetokenizedMandates(dateFrom?: string, dateTo?: string, statuses?: Array<ListDetokenizedMandatesStatusesEnum>, senderType?: ListDetokenizedMandatesSenderTypeEnum, userId?: string, institutionId?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMandatesResponse>>;
    /**
     * List Disputes
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListDisputesStatusesEnum>} [statuses] The dispute statuses to filter for, comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDisputes(dateFrom?: string, dateTo?: string, statuses?: Array<ListDisputesStatusesEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDisputesResponse>>;
    /**
     * List mandates
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
     * @param {ListMandatesSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMandates(dateFrom?: string, dateTo?: string, statuses?: Array<ListMandatesStatusesEnum>, senderType?: ListMandatesSenderTypeEnum, userId?: string, institutionId?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMandatesResponse>>;
    /**
     * List Payment Methods for a User
     * @param {string} paymentUserId Payment User Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentMethods(paymentUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPaymentMethodsResponse>>;
    /**
     * List Payments
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListPaymentsStatusesEnum>} [statuses] The payment statuses to filter for, comma separated
     * @param {ListPaymentsSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {ListPaymentsPaymentTypeEnum} [paymentType] Deprecated - The type of payment
     * @param {Array<ListPaymentsPaymentTypesEnum>} [paymentTypes]
     * @param {string} [mandateId] The mandate the payment belongs to
     * @param {string} [currency] Deprecated - The currency the payment is made in
     * @param {Array<string>} [currencies]
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPayments(dateFrom?: string, dateTo?: string, statuses?: Array<ListPaymentsStatusesEnum>, senderType?: ListPaymentsSenderTypeEnum, userId?: string, institutionId?: string, paymentType?: ListPaymentsPaymentTypeEnum, paymentTypes?: Array<ListPaymentsPaymentTypesEnum>, mandateId?: string, currency?: string, currencies?: Array<string>, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPaymentsResponse>>;
    /**
     * List payouts
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListPayoutsStatusesEnum>} [statuses] The payout statuses to filter for, comma separated
     * @param {Array<string>} [currencies]
     * @param {Array<ListPayoutsPayoutTypesEnum>} [payoutTypes]
     * @param {string} [mandateId]
     * @param {string} [senderAccountId]
     * @param {string} [recipientAccountId]
     * @param {string} [recipientUserId]
     * @param {string} [recipientExternalUserId]
     * @param {number} [offset] Default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPayouts(dateFrom?: string, dateTo?: string, statuses?: Array<ListPayoutsStatusesEnum>, currencies?: Array<string>, payoutTypes?: Array<ListPayoutsPayoutTypesEnum>, mandateId?: string, senderAccountId?: string, recipientAccountId?: string, recipientUserId?: string, recipientExternalUserId?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPayoutsResponse>>;
    /**
     * Refresh payment attempt from payment link front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshPaymentAttempt(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshPaymentAttemptResponse>>;
    /**
     * Set autopay consent for payment user
     * @param {SetAutopayConsentRequest} setAutopayConsentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setAutopayConsent(setAutopayConsentRequest: SetAutopayConsentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Update a payment user
     * @param {string} paymentUserId
     * @param {UpdatePaymentUserRequest} updatePaymentUserRequest request body for updating payment user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePaymentUser(paymentUserId: string, updatePaymentUserRequest: UpdatePaymentUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentUser>>;
};
/**
 * DefaultApi - factory interface
 * @export
 */
export declare const DefaultApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Cancel a payment link
     * @param {string} paymentLinkId The payment link id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelPaymentLink(paymentLinkId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentLinkResponse>;
    /**
     * Cancel Payout by payout_id
     * @param {string} payoutId payout id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelPayout(payoutId: string, options?: RawAxiosRequestConfig): AxiosPromise<PayoutSnapshotResponse>;
    /**
     * Initiate change payment method from payment link front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePaymentMethodPaymentLink(options?: RawAxiosRequestConfig): AxiosPromise<ChangePaymentMethodFvLinkResponse>;
    /**
     * Submit manual payment confirmation
     * @param {ManualPaymentConfirmationRequest} manualPaymentIdentifiers Request body containing information to identify manual payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmManualPayment(manualPaymentIdentifiers: ManualPaymentConfirmationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ManualPaymentConfirmationResponse>;
    /**
     * Confirm a payment against a payment Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmPayment(options?: RawAxiosRequestConfig): AxiosPromise<ConfirmPaymentResponse>;
    /**
     * Create token for fps flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFpsToken(options?: RawAxiosRequestConfig): AxiosPromise<CreateFpsTokenResponse>;
    /**
     * Create mandate for an existing sender account
     * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {CreateMandateWithSenderAccountRequest} createMandateRequest request body for creating mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMandateForExistingSender(idempotencyKey: string, createMandateRequest: CreateMandateWithSenderAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateMandateResponse>;
    /**
     * Create payment link
     * @param {CreatePaymentLinkRequest} createPaymentLinkRequest Parameters required to create a payment link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentLink(createPaymentLinkRequest: CreatePaymentLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaymentLinkResponse>;
    /**
     * Initiate Card Payment for a Payment Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentLinkCardPayment(options?: RawAxiosRequestConfig): AxiosPromise<CreatePaymentLinkCardPaymentResponse>;
    /**
     * CREATE Mandate for payment link
     * @param {CreatePaymentLinkMandateRequest} createPaymentLinkMandateRequest request body for creating mandate for payment-link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentLinkMandate(createPaymentLinkMandateRequest: CreatePaymentLinkMandateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreatePaymentLinkMandateResponse>;
    /**
     * Create a Payment Method for a user
     * @param {string} paymentUserId Payment User ID
     * @param {CreatePaymentMethodRequest} createPaymentMethodRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentMethod(paymentUserId: string, createPaymentMethodRequest: CreatePaymentMethodRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaymentMethodResponse>;
    /**
     * Create a scheduled payout
     * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {CreateScheduledPayoutRequest} createScheduledPayoutRequest Request body containing information to create scheduled payout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createScheduledPayout(idempotencyKey: string, createScheduledPayoutRequest: CreateScheduledPayoutRequest, options?: RawAxiosRequestConfig): AxiosPromise<PayoutSnapshotResponse>;
    /**
     * Demote payment attempt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    demotePaymentAttempt(options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     * Download the balance statement for the ledger (CSV)
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<string>} [currencies] The currencies to filter for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadBalanceStatement(dateFrom?: string, dateTo?: string, currencies?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<DownloadBalanceStatementResponse>;
    /**
     * Get the FPS QR code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFpsQrCode(options?: RawAxiosRequestConfig): AxiosPromise<FpsQrCodeResponse>;
    /**
     * Get a customer-specific list of institutions for Finverse Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstitutionsForCustomer(options?: RawAxiosRequestConfig): AxiosPromise<Array<Institution>>;
    /**
     * Get payment link
     * @param {string} paymentLinkId The payment link id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentLink(paymentLinkId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentLinkResponse>;
    /**
     * Get a payment method
     * @param {string} paymentMethodId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentMethod(paymentMethodId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentMethodResponse>;
    /**
     * Get payment method in payment link flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentMethodPaymentLink(options?: RawAxiosRequestConfig): AxiosPromise<PaymentMethodFvLinkResponse>;
    /**
     * Get payment (if exists) on the payment link for front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentPaymentLink(options?: RawAxiosRequestConfig): AxiosPromise<PaymentFvLinkResponse>;
    /**
     * Get payout by payout_id
     * @param {string} payoutId payout id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayoutById(payoutId: string, options?: RawAxiosRequestConfig): AxiosPromise<PayoutSnapshotResponse>;
    /**
     * Get sender payment user in payment link flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSenderPaymentUser(options?: RawAxiosRequestConfig): AxiosPromise<GetPaymentUserResponse>;
    /**
     * List mandates details
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListDetokenizedMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
     * @param {ListDetokenizedMandatesSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDetokenizedMandates(dateFrom?: string, dateTo?: string, statuses?: Array<ListDetokenizedMandatesStatusesEnum>, senderType?: ListDetokenizedMandatesSenderTypeEnum, userId?: string, institutionId?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListMandatesResponse>;
    /**
     * List Disputes
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListDisputesStatusesEnum>} [statuses] The dispute statuses to filter for, comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDisputes(dateFrom?: string, dateTo?: string, statuses?: Array<ListDisputesStatusesEnum>, options?: RawAxiosRequestConfig): AxiosPromise<ListDisputesResponse>;
    /**
     * List mandates
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
     * @param {ListMandatesSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMandates(dateFrom?: string, dateTo?: string, statuses?: Array<ListMandatesStatusesEnum>, senderType?: ListMandatesSenderTypeEnum, userId?: string, institutionId?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListMandatesResponse>;
    /**
     * List Payment Methods for a User
     * @param {string} paymentUserId Payment User Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentMethods(paymentUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<ListPaymentMethodsResponse>;
    /**
     * List Payments
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListPaymentsStatusesEnum>} [statuses] The payment statuses to filter for, comma separated
     * @param {ListPaymentsSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {ListPaymentsPaymentTypeEnum} [paymentType] Deprecated - The type of payment
     * @param {Array<ListPaymentsPaymentTypesEnum>} [paymentTypes]
     * @param {string} [mandateId] The mandate the payment belongs to
     * @param {string} [currency] Deprecated - The currency the payment is made in
     * @param {Array<string>} [currencies]
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPayments(dateFrom?: string, dateTo?: string, statuses?: Array<ListPaymentsStatusesEnum>, senderType?: ListPaymentsSenderTypeEnum, userId?: string, institutionId?: string, paymentType?: ListPaymentsPaymentTypeEnum, paymentTypes?: Array<ListPaymentsPaymentTypesEnum>, mandateId?: string, currency?: string, currencies?: Array<string>, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListPaymentsResponse>;
    /**
     * List payouts
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListPayoutsStatusesEnum>} [statuses] The payout statuses to filter for, comma separated
     * @param {Array<string>} [currencies]
     * @param {Array<ListPayoutsPayoutTypesEnum>} [payoutTypes]
     * @param {string} [mandateId]
     * @param {string} [senderAccountId]
     * @param {string} [recipientAccountId]
     * @param {string} [recipientUserId]
     * @param {string} [recipientExternalUserId]
     * @param {number} [offset] Default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPayouts(dateFrom?: string, dateTo?: string, statuses?: Array<ListPayoutsStatusesEnum>, currencies?: Array<string>, payoutTypes?: Array<ListPayoutsPayoutTypesEnum>, mandateId?: string, senderAccountId?: string, recipientAccountId?: string, recipientUserId?: string, recipientExternalUserId?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListPayoutsResponse>;
    /**
     * Refresh payment attempt from payment link front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshPaymentAttempt(options?: RawAxiosRequestConfig): AxiosPromise<RefreshPaymentAttemptResponse>;
    /**
     * Set autopay consent for payment user
     * @param {SetAutopayConsentRequest} setAutopayConsentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setAutopayConsent(setAutopayConsentRequest: SetAutopayConsentRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     * Update a payment user
     * @param {string} paymentUserId
     * @param {UpdatePaymentUserRequest} updatePaymentUserRequest request body for updating payment user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePaymentUser(paymentUserId: string, updatePaymentUserRequest: UpdatePaymentUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaymentUser>;
};
/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
    /**
     * Cancel a payment link
     * @param {string} paymentLinkId The payment link id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    cancelPaymentLink(paymentLinkId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentLinkResponse>;
    /**
     * Cancel Payout by payout_id
     * @param {string} payoutId payout id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    cancelPayout(payoutId: string, options?: RawAxiosRequestConfig): AxiosPromise<PayoutSnapshotResponse>;
    /**
     * Initiate change payment method from payment link front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    changePaymentMethodPaymentLink(options?: RawAxiosRequestConfig): AxiosPromise<ChangePaymentMethodFvLinkResponse>;
    /**
     * Submit manual payment confirmation
     * @param {ManualPaymentConfirmationRequest} manualPaymentIdentifiers Request body containing information to identify manual payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    confirmManualPayment(manualPaymentIdentifiers: ManualPaymentConfirmationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ManualPaymentConfirmationResponse>;
    /**
     * Confirm a payment against a payment Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    confirmPayment(options?: RawAxiosRequestConfig): AxiosPromise<ConfirmPaymentResponse>;
    /**
     * Create token for fps flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    createFpsToken(options?: RawAxiosRequestConfig): AxiosPromise<CreateFpsTokenResponse>;
    /**
     * Create mandate for an existing sender account
     * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {CreateMandateWithSenderAccountRequest} createMandateRequest request body for creating mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    createMandateForExistingSender(idempotencyKey: string, createMandateRequest: CreateMandateWithSenderAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateMandateResponse>;
    /**
     * Create payment link
     * @param {CreatePaymentLinkRequest} createPaymentLinkRequest Parameters required to create a payment link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    createPaymentLink(createPaymentLinkRequest: CreatePaymentLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaymentLinkResponse>;
    /**
     * Initiate Card Payment for a Payment Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    createPaymentLinkCardPayment(options?: RawAxiosRequestConfig): AxiosPromise<CreatePaymentLinkCardPaymentResponse>;
    /**
     * CREATE Mandate for payment link
     * @param {CreatePaymentLinkMandateRequest} createPaymentLinkMandateRequest request body for creating mandate for payment-link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    createPaymentLinkMandate(createPaymentLinkMandateRequest: CreatePaymentLinkMandateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreatePaymentLinkMandateResponse>;
    /**
     * Create a Payment Method for a user
     * @param {string} paymentUserId Payment User ID
     * @param {CreatePaymentMethodRequest} createPaymentMethodRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    createPaymentMethod(paymentUserId: string, createPaymentMethodRequest: CreatePaymentMethodRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaymentMethodResponse>;
    /**
     * Create a scheduled payout
     * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {CreateScheduledPayoutRequest} createScheduledPayoutRequest Request body containing information to create scheduled payout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    createScheduledPayout(idempotencyKey: string, createScheduledPayoutRequest: CreateScheduledPayoutRequest, options?: RawAxiosRequestConfig): AxiosPromise<PayoutSnapshotResponse>;
    /**
     * Demote payment attempt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    demotePaymentAttempt(options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     * Download the balance statement for the ledger (CSV)
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<string>} [currencies] The currencies to filter for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    downloadBalanceStatement(dateFrom?: string, dateTo?: string, currencies?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<DownloadBalanceStatementResponse>;
    /**
     * Get the FPS QR code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getFpsQrCode(options?: RawAxiosRequestConfig): AxiosPromise<FpsQrCodeResponse>;
    /**
     * Get a customer-specific list of institutions for Finverse Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getInstitutionsForCustomer(options?: RawAxiosRequestConfig): AxiosPromise<Array<Institution>>;
    /**
     * Get payment link
     * @param {string} paymentLinkId The payment link id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getPaymentLink(paymentLinkId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentLinkResponse>;
    /**
     * Get a payment method
     * @param {string} paymentMethodId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getPaymentMethod(paymentMethodId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentMethodResponse>;
    /**
     * Get payment method in payment link flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getPaymentMethodPaymentLink(options?: RawAxiosRequestConfig): AxiosPromise<PaymentMethodFvLinkResponse>;
    /**
     * Get payment (if exists) on the payment link for front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getPaymentPaymentLink(options?: RawAxiosRequestConfig): AxiosPromise<PaymentFvLinkResponse>;
    /**
     * Get payout by payout_id
     * @param {string} payoutId payout id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getPayoutById(payoutId: string, options?: RawAxiosRequestConfig): AxiosPromise<PayoutSnapshotResponse>;
    /**
     * Get sender payment user in payment link flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getSenderPaymentUser(options?: RawAxiosRequestConfig): AxiosPromise<GetPaymentUserResponse>;
    /**
     * List mandates details
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListDetokenizedMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
     * @param {ListDetokenizedMandatesSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    listDetokenizedMandates(dateFrom?: string, dateTo?: string, statuses?: Array<ListDetokenizedMandatesStatusesEnum>, senderType?: ListDetokenizedMandatesSenderTypeEnum, userId?: string, institutionId?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListMandatesResponse>;
    /**
     * List Disputes
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListDisputesStatusesEnum>} [statuses] The dispute statuses to filter for, comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    listDisputes(dateFrom?: string, dateTo?: string, statuses?: Array<ListDisputesStatusesEnum>, options?: RawAxiosRequestConfig): AxiosPromise<ListDisputesResponse>;
    /**
     * List mandates
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
     * @param {ListMandatesSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    listMandates(dateFrom?: string, dateTo?: string, statuses?: Array<ListMandatesStatusesEnum>, senderType?: ListMandatesSenderTypeEnum, userId?: string, institutionId?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListMandatesResponse>;
    /**
     * List Payment Methods for a User
     * @param {string} paymentUserId Payment User Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    listPaymentMethods(paymentUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<ListPaymentMethodsResponse>;
    /**
     * List Payments
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListPaymentsStatusesEnum>} [statuses] The payment statuses to filter for, comma separated
     * @param {ListPaymentsSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {ListPaymentsPaymentTypeEnum} [paymentType] Deprecated - The type of payment
     * @param {Array<ListPaymentsPaymentTypesEnum>} [paymentTypes]
     * @param {string} [mandateId] The mandate the payment belongs to
     * @param {string} [currency] Deprecated - The currency the payment is made in
     * @param {Array<string>} [currencies]
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    listPayments(dateFrom?: string, dateTo?: string, statuses?: Array<ListPaymentsStatusesEnum>, senderType?: ListPaymentsSenderTypeEnum, userId?: string, institutionId?: string, paymentType?: ListPaymentsPaymentTypeEnum, paymentTypes?: Array<ListPaymentsPaymentTypesEnum>, mandateId?: string, currency?: string, currencies?: Array<string>, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListPaymentsResponse>;
    /**
     * List payouts
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListPayoutsStatusesEnum>} [statuses] The payout statuses to filter for, comma separated
     * @param {Array<string>} [currencies]
     * @param {Array<ListPayoutsPayoutTypesEnum>} [payoutTypes]
     * @param {string} [mandateId]
     * @param {string} [senderAccountId]
     * @param {string} [recipientAccountId]
     * @param {string} [recipientUserId]
     * @param {string} [recipientExternalUserId]
     * @param {number} [offset] Default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    listPayouts(dateFrom?: string, dateTo?: string, statuses?: Array<ListPayoutsStatusesEnum>, currencies?: Array<string>, payoutTypes?: Array<ListPayoutsPayoutTypesEnum>, mandateId?: string, senderAccountId?: string, recipientAccountId?: string, recipientUserId?: string, recipientExternalUserId?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListPayoutsResponse>;
    /**
     * Refresh payment attempt from payment link front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    refreshPaymentAttempt(options?: RawAxiosRequestConfig): AxiosPromise<RefreshPaymentAttemptResponse>;
    /**
     * Set autopay consent for payment user
     * @param {SetAutopayConsentRequest} setAutopayConsentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    setAutopayConsent(setAutopayConsentRequest: SetAutopayConsentRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     * Update a payment user
     * @param {string} paymentUserId
     * @param {UpdatePaymentUserRequest} updatePaymentUserRequest request body for updating payment user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    updatePaymentUser(paymentUserId: string, updatePaymentUserRequest: UpdatePaymentUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaymentUser>;
}
/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export declare class DefaultApi extends BaseAPI implements DefaultApiInterface {
    /**
     * Cancel a payment link
     * @param {string} paymentLinkId The payment link id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    cancelPaymentLink(paymentLinkId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaymentLinkResponse, any>>;
    /**
     * Cancel Payout by payout_id
     * @param {string} payoutId payout id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    cancelPayout(payoutId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PayoutSnapshotResponse, any>>;
    /**
     * Initiate change payment method from payment link front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    changePaymentMethodPaymentLink(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ChangePaymentMethodFvLinkResponse, any>>;
    /**
     * Submit manual payment confirmation
     * @param {ManualPaymentConfirmationRequest} manualPaymentIdentifiers Request body containing information to identify manual payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    confirmManualPayment(manualPaymentIdentifiers: ManualPaymentConfirmationRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ManualPaymentConfirmationResponse, any>>;
    /**
     * Confirm a payment against a payment Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    confirmPayment(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ConfirmPaymentResponse, any>>;
    /**
     * Create token for fps flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createFpsToken(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<CreateFpsTokenResponse, any>>;
    /**
     * Create mandate for an existing sender account
     * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {CreateMandateWithSenderAccountRequest} createMandateRequest request body for creating mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createMandateForExistingSender(idempotencyKey: string, createMandateRequest: CreateMandateWithSenderAccountRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<CreateMandateResponse, any>>;
    /**
     * Create payment link
     * @param {CreatePaymentLinkRequest} createPaymentLinkRequest Parameters required to create a payment link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createPaymentLink(createPaymentLinkRequest: CreatePaymentLinkRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaymentLinkResponse, any>>;
    /**
     * Initiate Card Payment for a Payment Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createPaymentLinkCardPayment(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<CreatePaymentLinkCardPaymentResponse, any>>;
    /**
     * CREATE Mandate for payment link
     * @param {CreatePaymentLinkMandateRequest} createPaymentLinkMandateRequest request body for creating mandate for payment-link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createPaymentLinkMandate(createPaymentLinkMandateRequest: CreatePaymentLinkMandateRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<CreatePaymentLinkMandateResponse, any>>;
    /**
     * Create a Payment Method for a user
     * @param {string} paymentUserId Payment User ID
     * @param {CreatePaymentMethodRequest} createPaymentMethodRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createPaymentMethod(paymentUserId: string, createPaymentMethodRequest: CreatePaymentMethodRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaymentMethodResponse, any>>;
    /**
     * Create a scheduled payout
     * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {CreateScheduledPayoutRequest} createScheduledPayoutRequest Request body containing information to create scheduled payout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createScheduledPayout(idempotencyKey: string, createScheduledPayoutRequest: CreateScheduledPayoutRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PayoutSnapshotResponse, any>>;
    /**
     * Demote payment attempt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    demotePaymentAttempt(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Download the balance statement for the ledger (CSV)
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<string>} [currencies] The currencies to filter for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadBalanceStatement(dateFrom?: string, dateTo?: string, currencies?: Array<string>, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<DownloadBalanceStatementResponse, any>>;
    /**
     * Get the FPS QR code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getFpsQrCode(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<FpsQrCodeResponse, any>>;
    /**
     * Get a customer-specific list of institutions for Finverse Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getInstitutionsForCustomer(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Institution[], any>>;
    /**
     * Get payment link
     * @param {string} paymentLinkId The payment link id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getPaymentLink(paymentLinkId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaymentLinkResponse, any>>;
    /**
     * Get a payment method
     * @param {string} paymentMethodId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getPaymentMethod(paymentMethodId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaymentMethodResponse, any>>;
    /**
     * Get payment method in payment link flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getPaymentMethodPaymentLink(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaymentMethodFvLinkResponse, any>>;
    /**
     * Get payment (if exists) on the payment link for front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getPaymentPaymentLink(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaymentFvLinkResponse, any>>;
    /**
     * Get payout by payout_id
     * @param {string} payoutId payout id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getPayoutById(payoutId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PayoutSnapshotResponse, any>>;
    /**
     * Get sender payment user in payment link flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getSenderPaymentUser(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetPaymentUserResponse, any>>;
    /**
     * List mandates details
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListDetokenizedMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
     * @param {ListDetokenizedMandatesSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listDetokenizedMandates(dateFrom?: string, dateTo?: string, statuses?: Array<ListDetokenizedMandatesStatusesEnum>, senderType?: ListDetokenizedMandatesSenderTypeEnum, userId?: string, institutionId?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListMandatesResponse, any>>;
    /**
     * List Disputes
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListDisputesStatusesEnum>} [statuses] The dispute statuses to filter for, comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listDisputes(dateFrom?: string, dateTo?: string, statuses?: Array<ListDisputesStatusesEnum>, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListDisputesResponse, any>>;
    /**
     * List mandates
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
     * @param {ListMandatesSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listMandates(dateFrom?: string, dateTo?: string, statuses?: Array<ListMandatesStatusesEnum>, senderType?: ListMandatesSenderTypeEnum, userId?: string, institutionId?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListMandatesResponse, any>>;
    /**
     * List Payment Methods for a User
     * @param {string} paymentUserId Payment User Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listPaymentMethods(paymentUserId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListPaymentMethodsResponse, any>>;
    /**
     * List Payments
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListPaymentsStatusesEnum>} [statuses] The payment statuses to filter for, comma separated
     * @param {ListPaymentsSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {ListPaymentsPaymentTypeEnum} [paymentType] Deprecated - The type of payment
     * @param {Array<ListPaymentsPaymentTypesEnum>} [paymentTypes]
     * @param {string} [mandateId] The mandate the payment belongs to
     * @param {string} [currency] Deprecated - The currency the payment is made in
     * @param {Array<string>} [currencies]
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listPayments(dateFrom?: string, dateTo?: string, statuses?: Array<ListPaymentsStatusesEnum>, senderType?: ListPaymentsSenderTypeEnum, userId?: string, institutionId?: string, paymentType?: ListPaymentsPaymentTypeEnum, paymentTypes?: Array<ListPaymentsPaymentTypesEnum>, mandateId?: string, currency?: string, currencies?: Array<string>, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListPaymentsResponse, any>>;
    /**
     * List payouts
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListPayoutsStatusesEnum>} [statuses] The payout statuses to filter for, comma separated
     * @param {Array<string>} [currencies]
     * @param {Array<ListPayoutsPayoutTypesEnum>} [payoutTypes]
     * @param {string} [mandateId]
     * @param {string} [senderAccountId]
     * @param {string} [recipientAccountId]
     * @param {string} [recipientUserId]
     * @param {string} [recipientExternalUserId]
     * @param {number} [offset] Default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listPayouts(dateFrom?: string, dateTo?: string, statuses?: Array<ListPayoutsStatusesEnum>, currencies?: Array<string>, payoutTypes?: Array<ListPayoutsPayoutTypesEnum>, mandateId?: string, senderAccountId?: string, recipientAccountId?: string, recipientUserId?: string, recipientExternalUserId?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListPayoutsResponse, any>>;
    /**
     * Refresh payment attempt from payment link front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    refreshPaymentAttempt(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<RefreshPaymentAttemptResponse, any>>;
    /**
     * Set autopay consent for payment user
     * @param {SetAutopayConsentRequest} setAutopayConsentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    setAutopayConsent(setAutopayConsentRequest: SetAutopayConsentRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Update a payment user
     * @param {string} paymentUserId
     * @param {UpdatePaymentUserRequest} updatePaymentUserRequest request body for updating payment user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    updatePaymentUser(paymentUserId: string, updatePaymentUserRequest: UpdatePaymentUserRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaymentUser, any>>;
}
/**
 * @export
 */
export declare const ListDetokenizedMandatesStatusesEnum: {
    readonly AuthorizationRequired: "AUTHORIZATION_REQUIRED";
    readonly Authorizing: "AUTHORIZING";
    readonly Processing: "PROCESSING";
    readonly Submitted: "SUBMITTED";
    readonly Succeeded: "SUCCEEDED";
    readonly Failed: "FAILED";
    readonly Revoked: "REVOKED";
    readonly ReadyToSubmit: "READY_TO_SUBMIT";
    readonly Closed: "CLOSED";
    readonly Cancelled: "CANCELLED";
};
export type ListDetokenizedMandatesStatusesEnum = (typeof ListDetokenizedMandatesStatusesEnum)[keyof typeof ListDetokenizedMandatesStatusesEnum];
/**
 * @export
 */
export declare const ListDetokenizedMandatesSenderTypeEnum: {
    readonly Individual: "INDIVIDUAL";
    readonly Business: "BUSINESS";
};
export type ListDetokenizedMandatesSenderTypeEnum = (typeof ListDetokenizedMandatesSenderTypeEnum)[keyof typeof ListDetokenizedMandatesSenderTypeEnum];
/**
 * @export
 */
export declare const ListDisputesStatusesEnum: {
    readonly Unknown: "UNKNOWN";
    readonly Undefended: "UNDEFENDED";
    readonly ActionRequired: "ACTION_REQUIRED";
    readonly Processing: "PROCESSING";
    readonly Accepted: "ACCEPTED";
    readonly Lost: "LOST";
    readonly Won: "WON";
};
export type ListDisputesStatusesEnum = (typeof ListDisputesStatusesEnum)[keyof typeof ListDisputesStatusesEnum];
/**
 * @export
 */
export declare const ListMandatesStatusesEnum: {
    readonly AuthorizationRequired: "AUTHORIZATION_REQUIRED";
    readonly Authorizing: "AUTHORIZING";
    readonly Processing: "PROCESSING";
    readonly Submitted: "SUBMITTED";
    readonly Succeeded: "SUCCEEDED";
    readonly Failed: "FAILED";
    readonly Revoked: "REVOKED";
    readonly ReadyToSubmit: "READY_TO_SUBMIT";
    readonly Closed: "CLOSED";
    readonly Cancelled: "CANCELLED";
};
export type ListMandatesStatusesEnum = (typeof ListMandatesStatusesEnum)[keyof typeof ListMandatesStatusesEnum];
/**
 * @export
 */
export declare const ListMandatesSenderTypeEnum: {
    readonly Individual: "INDIVIDUAL";
    readonly Business: "BUSINESS";
};
export type ListMandatesSenderTypeEnum = (typeof ListMandatesSenderTypeEnum)[keyof typeof ListMandatesSenderTypeEnum];
/**
 * @export
 */
export declare const ListPaymentsStatusesEnum: {
    readonly AuthorizationRequired: "AUTHORIZATION_REQUIRED";
    readonly Authorizing: "AUTHORIZING";
    readonly Processing: "PROCESSING";
    readonly Submitted: "SUBMITTED";
    readonly Executed: "EXECUTED";
    readonly Failed: "FAILED";
    readonly Revoked: "REVOKED";
    readonly Cancelled: "CANCELLED";
    readonly Created: "CREATED";
};
export type ListPaymentsStatusesEnum = (typeof ListPaymentsStatusesEnum)[keyof typeof ListPaymentsStatusesEnum];
/**
 * @export
 */
export declare const ListPaymentsSenderTypeEnum: {
    readonly Individual: "INDIVIDUAL";
    readonly Business: "BUSINESS";
};
export type ListPaymentsSenderTypeEnum = (typeof ListPaymentsSenderTypeEnum)[keyof typeof ListPaymentsSenderTypeEnum];
/**
 * @export
 */
export declare const ListPaymentsPaymentTypeEnum: {
    readonly Mandate: "MANDATE";
    readonly Single: "SINGLE";
    readonly Card: "CARD";
    readonly Manual: "MANUAL";
};
export type ListPaymentsPaymentTypeEnum = (typeof ListPaymentsPaymentTypeEnum)[keyof typeof ListPaymentsPaymentTypeEnum];
/**
 * @export
 */
export declare const ListPaymentsPaymentTypesEnum: {
    readonly Mandate: "MANDATE";
    readonly Single: "SINGLE";
    readonly Card: "CARD";
    readonly Manual: "MANUAL";
};
export type ListPaymentsPaymentTypesEnum = (typeof ListPaymentsPaymentTypesEnum)[keyof typeof ListPaymentsPaymentTypesEnum];
/**
 * @export
 */
export declare const ListPayoutsStatusesEnum: {
    readonly Executed: "EXECUTED";
    readonly Created: "CREATED";
    readonly Processing: "PROCESSING";
    readonly ProcessingFunds: "PROCESSING_FUNDS";
    readonly Cancelled: "CANCELLED";
    readonly Failed: "FAILED";
    readonly Funded: "FUNDED";
    readonly Submitted: "SUBMITTED";
};
export type ListPayoutsStatusesEnum = (typeof ListPayoutsStatusesEnum)[keyof typeof ListPayoutsStatusesEnum];
/**
 * @export
 */
export declare const ListPayoutsPayoutTypesEnum: {
    readonly Manual: "MANUAL";
    readonly Scheduled: "SCHEDULED";
};
export type ListPayoutsPayoutTypesEnum = (typeof ListPayoutsPayoutTypesEnum)[keyof typeof ListPayoutsPayoutTypesEnum];
/**
 * LinkApi - axios parameter creator
 * @export
 */
export declare const LinkApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a new link and submit credentials
     * @param {ApiLinkRequest} apiLinkRequest Request body for creating a new link and submitting credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLink: (apiLinkRequest: ApiLinkRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Creates a new link
     * @param {LinkRequest} linkRequest Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLinkWoauth: (linkRequest: LinkRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Post the user action value
     * @param {string} loginIdentityId The login identity id
     * @param {ActionRequest} actionRequest Request body for post link action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkAction: (loginIdentityId: string, actionRequest: ActionRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Check the status of a given loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkStatus: (loginIdentityId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Check the status of a given login identity via FVLink
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkStatusNonSensitive: (loginIdentityId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update an existing link
     * @param {RelinkRequest} relinkRequest Request body for updating Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    relink: (relinkRequest: RelinkRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create a new link using an existing LIID
     * @param {string} loginIdentityId The login identity id
     * @param {ApiRelinkRequest} apiRelinkRequest Request body for relinking and submitting credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    relinkV2: (loginIdentityId: string, apiRelinkRequest: ApiRelinkRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Exchange authorization code for token
     * @param {TokenGrantTypeEnum} grantType
     * @param {string} code
     * @param {string} clientId
     * @param {string} redirectUri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    token: (grantType: TokenGrantTypeEnum, code: string, clientId: string, redirectUri: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * LinkApi - functional programming interface
 * @export
 */
export declare const LinkApiFp: (configuration?: Configuration) => {
    /**
     * Create a new link and submit credentials
     * @param {ApiLinkRequest} apiLinkRequest Request body for creating a new link and submitting credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLink(apiLinkRequest: ApiLinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLoginIdentityByIdResponse>>;
    /**
     * Creates a new link
     * @param {LinkRequest} linkRequest Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLinkWoauth(linkRequest: LinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkResponse>>;
    /**
     * Post the user action value
     * @param {string} loginIdentityId The login identity id
     * @param {ActionRequest} actionRequest Request body for post link action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkAction(loginIdentityId: string, actionRequest: ActionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLoginIdentityByIdResponse>>;
    /**
     * Check the status of a given loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkStatus(loginIdentityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkStatusResponse>>;
    /**
     * Check the status of a given login identity via FVLink
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkStatusNonSensitive(loginIdentityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonSensitiveLinkStatusResponse>>;
    /**
     * Update an existing link
     * @param {RelinkRequest} relinkRequest Request body for updating Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    relink(relinkRequest: RelinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkResponse>>;
    /**
     * Create a new link using an existing LIID
     * @param {string} loginIdentityId The login identity id
     * @param {ApiRelinkRequest} apiRelinkRequest Request body for relinking and submitting credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    relinkV2(loginIdentityId: string, apiRelinkRequest: ApiRelinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLoginIdentityByIdResponse>>;
    /**
     * Exchange authorization code for token
     * @param {TokenGrantTypeEnum} grantType
     * @param {string} code
     * @param {string} clientId
     * @param {string} redirectUri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    token(grantType: TokenGrantTypeEnum, code: string, clientId: string, redirectUri: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokenResponse>>;
};
/**
 * LinkApi - factory interface
 * @export
 */
export declare const LinkApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a new link and submit credentials
     * @param {ApiLinkRequest} apiLinkRequest Request body for creating a new link and submitting credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLink(apiLinkRequest: ApiLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetLoginIdentityByIdResponse>;
    /**
     * Creates a new link
     * @param {LinkRequest} linkRequest Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLinkWoauth(linkRequest: LinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<LinkResponse>;
    /**
     * Post the user action value
     * @param {string} loginIdentityId The login identity id
     * @param {ActionRequest} actionRequest Request body for post link action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkAction(loginIdentityId: string, actionRequest: ActionRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetLoginIdentityByIdResponse>;
    /**
     * Check the status of a given loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkStatus(loginIdentityId: string, options?: RawAxiosRequestConfig): AxiosPromise<LinkStatusResponse>;
    /**
     * Check the status of a given login identity via FVLink
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkStatusNonSensitive(loginIdentityId: string, options?: RawAxiosRequestConfig): AxiosPromise<NonSensitiveLinkStatusResponse>;
    /**
     * Update an existing link
     * @param {RelinkRequest} relinkRequest Request body for updating Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    relink(relinkRequest: RelinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<LinkResponse>;
    /**
     * Create a new link using an existing LIID
     * @param {string} loginIdentityId The login identity id
     * @param {ApiRelinkRequest} apiRelinkRequest Request body for relinking and submitting credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    relinkV2(loginIdentityId: string, apiRelinkRequest: ApiRelinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetLoginIdentityByIdResponse>;
    /**
     * Exchange authorization code for token
     * @param {TokenGrantTypeEnum} grantType
     * @param {string} code
     * @param {string} clientId
     * @param {string} redirectUri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    token(grantType: TokenGrantTypeEnum, code: string, clientId: string, redirectUri: string, options?: RawAxiosRequestConfig): AxiosPromise<AccessTokenResponse>;
};
/**
 * LinkApi - interface
 * @export
 * @interface LinkApi
 */
export interface LinkApiInterface {
    /**
     * Create a new link and submit credentials
     * @param {ApiLinkRequest} apiLinkRequest Request body for creating a new link and submitting credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApiInterface
     */
    createLink(apiLinkRequest: ApiLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetLoginIdentityByIdResponse>;
    /**
     * Creates a new link
     * @param {LinkRequest} linkRequest Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApiInterface
     */
    createLinkWoauth(linkRequest: LinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<LinkResponse>;
    /**
     * Post the user action value
     * @param {string} loginIdentityId The login identity id
     * @param {ActionRequest} actionRequest Request body for post link action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApiInterface
     */
    linkAction(loginIdentityId: string, actionRequest: ActionRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetLoginIdentityByIdResponse>;
    /**
     * Check the status of a given loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApiInterface
     */
    linkStatus(loginIdentityId: string, options?: RawAxiosRequestConfig): AxiosPromise<LinkStatusResponse>;
    /**
     * Check the status of a given login identity via FVLink
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApiInterface
     */
    linkStatusNonSensitive(loginIdentityId: string, options?: RawAxiosRequestConfig): AxiosPromise<NonSensitiveLinkStatusResponse>;
    /**
     * Update an existing link
     * @param {RelinkRequest} relinkRequest Request body for updating Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApiInterface
     */
    relink(relinkRequest: RelinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<LinkResponse>;
    /**
     * Create a new link using an existing LIID
     * @param {string} loginIdentityId The login identity id
     * @param {ApiRelinkRequest} apiRelinkRequest Request body for relinking and submitting credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApiInterface
     */
    relinkV2(loginIdentityId: string, apiRelinkRequest: ApiRelinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetLoginIdentityByIdResponse>;
    /**
     * Exchange authorization code for token
     * @param {TokenGrantTypeEnum} grantType
     * @param {string} code
     * @param {string} clientId
     * @param {string} redirectUri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApiInterface
     */
    token(grantType: TokenGrantTypeEnum, code: string, clientId: string, redirectUri: string, options?: RawAxiosRequestConfig): AxiosPromise<AccessTokenResponse>;
}
/**
 * LinkApi - object-oriented interface
 * @export
 * @class LinkApi
 * @extends {BaseAPI}
 */
export declare class LinkApi extends BaseAPI implements LinkApiInterface {
    /**
     * Create a new link and submit credentials
     * @param {ApiLinkRequest} apiLinkRequest Request body for creating a new link and submitting credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApi
     */
    createLink(apiLinkRequest: ApiLinkRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetLoginIdentityByIdResponse, any>>;
    /**
     * Creates a new link
     * @param {LinkRequest} linkRequest Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApi
     */
    createLinkWoauth(linkRequest: LinkRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<LinkResponse, any>>;
    /**
     * Post the user action value
     * @param {string} loginIdentityId The login identity id
     * @param {ActionRequest} actionRequest Request body for post link action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApi
     */
    linkAction(loginIdentityId: string, actionRequest: ActionRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetLoginIdentityByIdResponse, any>>;
    /**
     * Check the status of a given loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApi
     */
    linkStatus(loginIdentityId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<LinkStatusResponse, any>>;
    /**
     * Check the status of a given login identity via FVLink
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApi
     */
    linkStatusNonSensitive(loginIdentityId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<NonSensitiveLinkStatusResponse, any>>;
    /**
     * Update an existing link
     * @param {RelinkRequest} relinkRequest Request body for updating Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApi
     */
    relink(relinkRequest: RelinkRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<LinkResponse, any>>;
    /**
     * Create a new link using an existing LIID
     * @param {string} loginIdentityId The login identity id
     * @param {ApiRelinkRequest} apiRelinkRequest Request body for relinking and submitting credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApi
     */
    relinkV2(loginIdentityId: string, apiRelinkRequest: ApiRelinkRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetLoginIdentityByIdResponse, any>>;
    /**
     * Exchange authorization code for token
     * @param {TokenGrantTypeEnum} grantType
     * @param {string} code
     * @param {string} clientId
     * @param {string} redirectUri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinkApi
     */
    token(grantType: TokenGrantTypeEnum, code: string, clientId: string, redirectUri: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<AccessTokenResponse, any>>;
}
/**
 * @export
 */
export declare const TokenGrantTypeEnum: {
    readonly AuthorizationCode: "authorization_code";
};
export type TokenGrantTypeEnum = (typeof TokenGrantTypeEnum)[keyof typeof TokenGrantTypeEnum];
/**
 * LoginIdentityApi - axios parameter creator
 * @export
 */
export declare const LoginIdentityApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Delete a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLoginIdentity: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateLinkToken: (linkTokenRequest: LinkTokenRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a specific account\'s information
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount: (accountId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the account number for a specific account
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountNumber: (accountId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the balance history for a specific account
     * @param {string} accountId The account id
     * @param {GetBalanceHistorySourceEnum} [source] The source will determine what type of balance history will be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalanceHistory: (accountId: string, source?: GetBalanceHistorySourceEnum, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Download composite statement
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompositeStatement: (redirect?: boolean, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * \\[BETA] Get a list of identity data for a given login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentity: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get income figures for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIncomeEstimateByLoginIdentityId: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentity: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Download statement
     * @param {string} statementId The statement id
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatement: (statementId: string, redirect?: boolean, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get list of available statements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatements: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a list of accounts for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAccounts: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a list of card details for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCardDetails: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsByAccountId: (accountId: string, offset?: number, limit?: number, enrichments?: boolean, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsByLoginIdentityId: (offset?: number, limit?: number, enrichments?: boolean, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create a refresh job for a login identity
     * @param {RefreshLoginIdentityRequest} [refreshLoginIdentityReq]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshLoginIdentity: (refreshLoginIdentityReq?: RefreshLoginIdentityRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * LoginIdentityApi - functional programming interface
 * @export
 */
export declare const LoginIdentityApiFp: (configuration?: Configuration) => {
    /**
     * Delete a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLoginIdentity(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteLoginIdentityResponse>>;
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkTokenResponse>>;
    /**
     * Get a specific account\'s information
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountResponse>>;
    /**
     * Get the account number for a specific account
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountNumber(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountNumberResponse>>;
    /**
     * Get the balance history for a specific account
     * @param {string} accountId The account id
     * @param {GetBalanceHistorySourceEnum} [source] The source will determine what type of balance history will be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalanceHistory(accountId: string, source?: GetBalanceHistorySourceEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBalanceHistoryResponse>>;
    /**
     * Download composite statement
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompositeStatement(redirect?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompositeStatementLink>>;
    /**
     * \\[BETA] Get a list of identity data for a given login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentity(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIdentityResponse>>;
    /**
     * Get income figures for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIncomeEstimateByLoginIdentityId(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncomeResponse>>;
    /**
     * Get a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentity(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLoginIdentityByIdResponse>>;
    /**
     * Download statement
     * @param {string} statementId The statement id
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatement(statementId: string, redirect?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatementLinkResponse>>;
    /**
     * Get list of available statements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatements(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatementsResponse>>;
    /**
     * Get a list of accounts for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAccounts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAccountsResponse>>;
    /**
     * Get a list of card details for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCardDetails(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCardsDetailsResponse>>;
    /**
     * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsByAccountId(accountId: string, offset?: number, limit?: number, enrichments?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTransactionsResponse>>;
    /**
     * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsByLoginIdentityId(offset?: number, limit?: number, enrichments?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTransactionsResponse>>;
    /**
     * Create a refresh job for a login identity
     * @param {RefreshLoginIdentityRequest} [refreshLoginIdentityReq]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshLoginIdentity(refreshLoginIdentityReq?: RefreshLoginIdentityRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshTokenResponse>>;
};
/**
 * LoginIdentityApi - factory interface
 * @export
 */
export declare const LoginIdentityApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Delete a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLoginIdentity(options?: RawAxiosRequestConfig): AxiosPromise<DeleteLoginIdentityResponse>;
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<LinkTokenResponse>;
    /**
     * Get a specific account\'s information
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount(accountId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountResponse>;
    /**
     * Get the account number for a specific account
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountNumber(accountId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountNumberResponse>;
    /**
     * Get the balance history for a specific account
     * @param {string} accountId The account id
     * @param {GetBalanceHistorySourceEnum} [source] The source will determine what type of balance history will be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalanceHistory(accountId: string, source?: GetBalanceHistorySourceEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetBalanceHistoryResponse>;
    /**
     * Download composite statement
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompositeStatement(redirect?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<CompositeStatementLink>;
    /**
     * \\[BETA] Get a list of identity data for a given login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentity(options?: RawAxiosRequestConfig): AxiosPromise<GetIdentityResponse>;
    /**
     * Get income figures for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIncomeEstimateByLoginIdentityId(options?: RawAxiosRequestConfig): AxiosPromise<IncomeResponse>;
    /**
     * Get a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentity(options?: RawAxiosRequestConfig): AxiosPromise<GetLoginIdentityByIdResponse>;
    /**
     * Download statement
     * @param {string} statementId The statement id
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatement(statementId: string, redirect?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<GetStatementLinkResponse>;
    /**
     * Get list of available statements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatements(options?: RawAxiosRequestConfig): AxiosPromise<GetStatementsResponse>;
    /**
     * Get a list of accounts for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAccounts(options?: RawAxiosRequestConfig): AxiosPromise<ListAccountsResponse>;
    /**
     * Get a list of card details for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCardDetails(options?: RawAxiosRequestConfig): AxiosPromise<ListCardsDetailsResponse>;
    /**
     * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsByAccountId(accountId: string, offset?: number, limit?: number, enrichments?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ListTransactionsResponse>;
    /**
     * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsByLoginIdentityId(offset?: number, limit?: number, enrichments?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ListTransactionsResponse>;
    /**
     * Create a refresh job for a login identity
     * @param {RefreshLoginIdentityRequest} [refreshLoginIdentityReq]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshLoginIdentity(refreshLoginIdentityReq?: RefreshLoginIdentityRequest, options?: RawAxiosRequestConfig): AxiosPromise<RefreshTokenResponse>;
};
/**
 * LoginIdentityApi - interface
 * @export
 * @interface LoginIdentityApi
 */
export interface LoginIdentityApiInterface {
    /**
     * Delete a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApiInterface
     */
    deleteLoginIdentity(options?: RawAxiosRequestConfig): AxiosPromise<DeleteLoginIdentityResponse>;
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApiInterface
     */
    generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<LinkTokenResponse>;
    /**
     * Get a specific account\'s information
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApiInterface
     */
    getAccount(accountId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountResponse>;
    /**
     * Get the account number for a specific account
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApiInterface
     */
    getAccountNumber(accountId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountNumberResponse>;
    /**
     * Get the balance history for a specific account
     * @param {string} accountId The account id
     * @param {GetBalanceHistorySourceEnum} [source] The source will determine what type of balance history will be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApiInterface
     */
    getBalanceHistory(accountId: string, source?: GetBalanceHistorySourceEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetBalanceHistoryResponse>;
    /**
     * Download composite statement
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApiInterface
     */
    getCompositeStatement(redirect?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<CompositeStatementLink>;
    /**
     * \\[BETA] Get a list of identity data for a given login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApiInterface
     */
    getIdentity(options?: RawAxiosRequestConfig): AxiosPromise<GetIdentityResponse>;
    /**
     * Get income figures for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApiInterface
     */
    getIncomeEstimateByLoginIdentityId(options?: RawAxiosRequestConfig): AxiosPromise<IncomeResponse>;
    /**
     * Get a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApiInterface
     */
    getLoginIdentity(options?: RawAxiosRequestConfig): AxiosPromise<GetLoginIdentityByIdResponse>;
    /**
     * Download statement
     * @param {string} statementId The statement id
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApiInterface
     */
    getStatement(statementId: string, redirect?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<GetStatementLinkResponse>;
    /**
     * Get list of available statements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApiInterface
     */
    getStatements(options?: RawAxiosRequestConfig): AxiosPromise<GetStatementsResponse>;
    /**
     * Get a list of accounts for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApiInterface
     */
    listAccounts(options?: RawAxiosRequestConfig): AxiosPromise<ListAccountsResponse>;
    /**
     * Get a list of card details for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApiInterface
     */
    listCardDetails(options?: RawAxiosRequestConfig): AxiosPromise<ListCardsDetailsResponse>;
    /**
     * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApiInterface
     */
    listTransactionsByAccountId(accountId: string, offset?: number, limit?: number, enrichments?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ListTransactionsResponse>;
    /**
     * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApiInterface
     */
    listTransactionsByLoginIdentityId(offset?: number, limit?: number, enrichments?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ListTransactionsResponse>;
    /**
     * Create a refresh job for a login identity
     * @param {RefreshLoginIdentityRequest} [refreshLoginIdentityReq]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApiInterface
     */
    refreshLoginIdentity(refreshLoginIdentityReq?: RefreshLoginIdentityRequest, options?: RawAxiosRequestConfig): AxiosPromise<RefreshTokenResponse>;
}
/**
 * LoginIdentityApi - object-oriented interface
 * @export
 * @class LoginIdentityApi
 * @extends {BaseAPI}
 */
export declare class LoginIdentityApi extends BaseAPI implements LoginIdentityApiInterface {
    /**
     * Delete a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    deleteLoginIdentity(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<DeleteLoginIdentityResponse, any>>;
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<LinkTokenResponse, any>>;
    /**
     * Get a specific account\'s information
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    getAccount(accountId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetAccountResponse, any>>;
    /**
     * Get the account number for a specific account
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    getAccountNumber(accountId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetAccountNumberResponse, any>>;
    /**
     * Get the balance history for a specific account
     * @param {string} accountId The account id
     * @param {GetBalanceHistorySourceEnum} [source] The source will determine what type of balance history will be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    getBalanceHistory(accountId: string, source?: GetBalanceHistorySourceEnum, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetBalanceHistoryResponse, any>>;
    /**
     * Download composite statement
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    getCompositeStatement(redirect?: boolean, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<CompositeStatementLink, any>>;
    /**
     * \\[BETA] Get a list of identity data for a given login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    getIdentity(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetIdentityResponse, any>>;
    /**
     * Get income figures for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    getIncomeEstimateByLoginIdentityId(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<IncomeResponse, any>>;
    /**
     * Get a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    getLoginIdentity(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetLoginIdentityByIdResponse, any>>;
    /**
     * Download statement
     * @param {string} statementId The statement id
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    getStatement(statementId: string, redirect?: boolean, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetStatementLinkResponse, any>>;
    /**
     * Get list of available statements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    getStatements(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetStatementsResponse, any>>;
    /**
     * Get a list of accounts for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    listAccounts(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListAccountsResponse, any>>;
    /**
     * Get a list of card details for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    listCardDetails(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListCardsDetailsResponse, any>>;
    /**
     * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    listTransactionsByAccountId(accountId: string, offset?: number, limit?: number, enrichments?: boolean, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListTransactionsResponse, any>>;
    /**
     * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    listTransactionsByLoginIdentityId(offset?: number, limit?: number, enrichments?: boolean, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListTransactionsResponse, any>>;
    /**
     * Create a refresh job for a login identity
     * @param {RefreshLoginIdentityRequest} [refreshLoginIdentityReq]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginIdentityApi
     */
    refreshLoginIdentity(refreshLoginIdentityReq?: RefreshLoginIdentityRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<RefreshTokenResponse, any>>;
}
/**
 * @export
 */
export declare const GetBalanceHistorySourceEnum: {
    readonly Institution: "INSTITUTION";
    readonly Computed: "COMPUTED";
};
export type GetBalanceHistorySourceEnum = (typeof GetBalanceHistorySourceEnum)[keyof typeof GetBalanceHistorySourceEnum];
/**
 * PublicApi - axios parameter creator
 * @export
 */
export declare const PublicApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Callback url to get the oauth authorization token
     * @param {string} state The state of the client when oauth was initialized
     * @param {string} [code] The authorization code generated by the Oauth provider
     * @param {string} [error] error
     * @param {string} [errorDescription] error description
     * @param {string} [errorDetails] error details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authCallback: (state: string, code?: string, error?: string, errorDescription?: string, errorDetails?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * generate an access_token
     * @param {TokenRequest} [tokenRequest] token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateCustomerAccessToken: (tokenRequest?: TokenRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * get jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredSubmitJwks: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * get payment jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentsJwks: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * PublicApi - functional programming interface
 * @export
 */
export declare const PublicApiFp: (configuration?: Configuration) => {
    /**
     * Callback url to get the oauth authorization token
     * @param {string} state The state of the client when oauth was initialized
     * @param {string} [code] The authorization code generated by the Oauth provider
     * @param {string} [error] error
     * @param {string} [errorDescription] error description
     * @param {string} [errorDetails] error details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authCallback(state: string, code?: string, error?: string, errorDescription?: string, errorDetails?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RedirectUriResponse>>;
    /**
     * generate an access_token
     * @param {TokenRequest} [tokenRequest] token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateCustomerAccessToken(tokenRequest?: TokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>>;
    /**
     * get jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredSubmitJwks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * get payment jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentsJwks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJWKSResponse>>;
};
/**
 * PublicApi - factory interface
 * @export
 */
export declare const PublicApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Callback url to get the oauth authorization token
     * @param {string} state The state of the client when oauth was initialized
     * @param {string} [code] The authorization code generated by the Oauth provider
     * @param {string} [error] error
     * @param {string} [errorDescription] error description
     * @param {string} [errorDetails] error details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authCallback(state: string, code?: string, error?: string, errorDescription?: string, errorDetails?: string, options?: RawAxiosRequestConfig): AxiosPromise<RedirectUriResponse>;
    /**
     * generate an access_token
     * @param {TokenRequest} [tokenRequest] token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateCustomerAccessToken(tokenRequest?: TokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponse>;
    /**
     * get jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredSubmitJwks(options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     * get payment jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentsJwks(options?: RawAxiosRequestConfig): AxiosPromise<GetJWKSResponse>;
};
/**
 * PublicApi - interface
 * @export
 * @interface PublicApi
 */
export interface PublicApiInterface {
    /**
     * Callback url to get the oauth authorization token
     * @param {string} state The state of the client when oauth was initialized
     * @param {string} [code] The authorization code generated by the Oauth provider
     * @param {string} [error] error
     * @param {string} [errorDescription] error description
     * @param {string} [errorDetails] error details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiInterface
     */
    authCallback(state: string, code?: string, error?: string, errorDescription?: string, errorDetails?: string, options?: RawAxiosRequestConfig): AxiosPromise<RedirectUriResponse>;
    /**
     * generate an access_token
     * @param {TokenRequest} [tokenRequest] token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiInterface
     */
    generateCustomerAccessToken(tokenRequest?: TokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponse>;
    /**
     * get jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiInterface
     */
    getCredSubmitJwks(options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     * get payment jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiInterface
     */
    getPaymentsJwks(options?: RawAxiosRequestConfig): AxiosPromise<GetJWKSResponse>;
}
/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
export declare class PublicApi extends BaseAPI implements PublicApiInterface {
    /**
     * Callback url to get the oauth authorization token
     * @param {string} state The state of the client when oauth was initialized
     * @param {string} [code] The authorization code generated by the Oauth provider
     * @param {string} [error] error
     * @param {string} [errorDescription] error description
     * @param {string} [errorDetails] error details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    authCallback(state: string, code?: string, error?: string, errorDescription?: string, errorDetails?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<RedirectUriResponse, any>>;
    /**
     * generate an access_token
     * @param {TokenRequest} [tokenRequest] token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    generateCustomerAccessToken(tokenRequest?: TokenRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<TokenResponse, any>>;
    /**
     * get jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    getCredSubmitJwks(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * get payment jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    getPaymentsJwks(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetJWKSResponse, any>>;
}
